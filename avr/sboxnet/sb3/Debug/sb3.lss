
sb3.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .bldrapp      00000cd0  00007000  00007000  0000168e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bldrinit     0000019e  00008000  00008000  0000235e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bldrvec      00000040  00008200  00008200  000024fc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .bootloader   00000b18  00008240  00008240  0000253c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  4 .bldrstatic   000001cc  00008e00  00008e00  00003054  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  5 .bldrstatvec  00000008  00008ff8  00008ff8  00003220  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  6 .text         0000155a  00000000  00000000  00000134  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  7 .data         00000000  00802000  00802000  00003329  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  8 .bss          000000e9  00802000  00802000  00003228  2**0
                  ALLOC
  9 .eeprom       00000101  00810000  00810000  00003228  2**0
                  CONTENTS, ALLOC, LOAD, DATA
 10 .comment      00000030  00000000  00000000  00003329  2**0
                  CONTENTS, READONLY
 11 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000335c  2**2
                  CONTENTS, READONLY
 12 .debug_aranges 00000330  00000000  00000000  000033a0  2**3
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   0000afca  00000000  00000000  000036d0  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 0000371b  00000000  00000000  0000e69a  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   000044d3  00000000  00000000  00011db5  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_frame  00000880  00000000  00000000  00016288  2**2
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_str    00022777  00000000  00000000  00016b08  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    00003f57  00000000  00000000  0003927f  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_ranges 00000670  00000000  00000000  0003d1d6  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .debug_macro  0000a244  00000000  00000000  0003d846  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .bldrapp:

00007000 <sboxnet_all_sent>:
 * Verhindert das der Linker diesen Bereich nutzt.
 * 
 */
BLDR_CRC_SECTION NOINLINE __ATTR_NAKED __ATTR_USED
static void bldr_crc_section(void) {
    __asm__ __volatile__ (
    7000:	90 91 4a 2f 	lds	r25, 0x2F4A	; 0x802f4a <__bss_end+0xe61>
    7004:	81 e0       	ldi	r24, 0x01	; 1
    7006:	91 11       	cpse	r25, r1
    7008:	80 e0       	ldi	r24, 0x00	; 0
    700a:	08 95       	ret

0000700c <crc_ccitt_update>:
    700c:	86 27       	eor	r24, r22
    700e:	08 2e       	mov	r0, r24
    7010:	82 95       	swap	r24
    7012:	80 7f       	andi	r24, 0xF0	; 240
    7014:	80 25       	eor	r24, r0
    7016:	09 2e       	mov	r0, r25
    7018:	98 2f       	mov	r25, r24
    701a:	82 95       	swap	r24
    701c:	8f 70       	andi	r24, 0x0F	; 15
    701e:	08 26       	eor	r0, r24
    7020:	86 95       	lsr	r24
    7022:	98 27       	eor	r25, r24
    7024:	89 27       	eor	r24, r25
    7026:	88 0f       	add	r24, r24
    7028:	88 0f       	add	r24, r24
    702a:	88 0f       	add	r24, r24
    702c:	80 25       	eor	r24, r0
    702e:	08 95       	ret

00007030 <bldr_process_cmd_net_reset>:
    7030:	8f b7       	in	r24, 0x3f	; 63
    7032:	f8 94       	cli
    7034:	9f ef       	ldi	r25, 0xFF	; 255
    7036:	90 93 8b 2e 	sts	0x2E8B, r25	; 0x802e8b <__bss_end+0xda2>
    703a:	03 9a       	sbi	0x00, 3	; 0
    703c:	8f bf       	out	0x3f, r24	; 63
    703e:	08 95       	ret

00007040 <bldr_process_msg>:
    7040:	cf 92       	push	r12
    7042:	df 92       	push	r13
    7044:	ef 92       	push	r14
    7046:	ff 92       	push	r15
    7048:	0f 93       	push	r16
    704a:	1f 93       	push	r17
    704c:	cf 93       	push	r28
    704e:	df 93       	push	r29
    7050:	ec 01       	movw	r28, r24
    7052:	89 81       	ldd	r24, Y+1	; 0x01
    7054:	81 11       	cpse	r24, r1
    7056:	03 c0       	rjmp	.+6      	; 0x705e <bldr_process_msg+0x1e>
    7058:	80 e8       	ldi	r24, 0x80	; 128
    705a:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <__bss_end+0xda9>
    705e:	8c 81       	ldd	r24, Y+4	; 0x04
    7060:	88 23       	and	r24, r24
    7062:	0c f4       	brge	.+2      	; 0x7066 <bldr_process_msg+0x26>
    7064:	43 c1       	rjmp	.+646    	; 0x72ec <bldr_process_msg+0x2ac>
    7066:	8b 01       	movw	r16, r22
    7068:	82 30       	cpi	r24, 0x02	; 2
    706a:	09 f4       	brne	.+2      	; 0x706e <bldr_process_msg+0x2e>
    706c:	26 c1       	rjmp	.+588    	; 0x72ba <bldr_process_msg+0x27a>
    706e:	85 31       	cpi	r24, 0x15	; 21
    7070:	41 f0       	breq	.+16     	; 0x7082 <bldr_process_msg+0x42>
    7072:	81 30       	cpi	r24, 0x01	; 1
    7074:	79 f4       	brne	.+30     	; 0x7094 <bldr_process_msg+0x54>
    7076:	89 81       	ldd	r24, Y+1	; 0x01
    7078:	81 11       	cpse	r24, r1
    707a:	58 c1       	rjmp	.+688    	; 0x732c <bldr_process_msg+0x2ec>
    707c:	0e 94 18 38 	call	0x7030	; 0x7030 <bldr_process_cmd_net_reset>
    7080:	55 c1       	rjmp	.+682    	; 0x732c <bldr_process_msg+0x2ec>
    7082:	06 9a       	sbi	0x00, 6	; 0
    7084:	88 81       	ld	r24, Y
    7086:	8f 3f       	cpi	r24, 0xFF	; 255
    7088:	09 f4       	brne	.+2      	; 0x708c <bldr_process_msg+0x4c>
    708a:	50 c1       	rjmp	.+672    	; 0x732c <bldr_process_msg+0x2ec>
    708c:	8b 81       	ldd	r24, Y+3	; 0x03
    708e:	80 7c       	andi	r24, 0xC0	; 192
    7090:	8b 83       	std	Y+3, r24	; 0x03
    7092:	4a c1       	rjmp	.+660    	; 0x7328 <bldr_process_msg+0x2e8>
    7094:	98 81       	ld	r25, Y
    7096:	9f 3f       	cpi	r25, 0xFF	; 255
    7098:	09 f4       	brne	.+2      	; 0x709c <bldr_process_msg+0x5c>
    709a:	48 c1       	rjmp	.+656    	; 0x732c <bldr_process_msg+0x2ec>
    709c:	80 32       	cpi	r24, 0x20	; 32
    709e:	31 f0       	breq	.+12     	; 0x70ac <bldr_process_msg+0x6c>
    70a0:	81 32       	cpi	r24, 0x21	; 33
    70a2:	69 f1       	breq	.+90     	; 0x70fe <bldr_process_msg+0xbe>
    70a4:	89 31       	cpi	r24, 0x19	; 25
    70a6:	09 f0       	breq	.+2      	; 0x70aa <bldr_process_msg+0x6a>
    70a8:	03 c1       	rjmp	.+518    	; 0x72b0 <bldr_process_msg+0x270>
    70aa:	47 c0       	rjmp	.+142    	; 0x713a <bldr_process_msg+0xfa>
    70ac:	1b 81       	ldd	r17, Y+3	; 0x03
    70ae:	1f 73       	andi	r17, 0x3F	; 63
    70b0:	13 30       	cpi	r17, 0x03	; 3
    70b2:	09 f0       	breq	.+2      	; 0x70b6 <bldr_process_msg+0x76>
    70b4:	1d c1       	rjmp	.+570    	; 0x72f0 <bldr_process_msg+0x2b0>
    70b6:	0f 81       	ldd	r16, Y+7	; 0x07
    70b8:	00 32       	cpi	r16, 0x20	; 32
    70ba:	08 f0       	brcs	.+2      	; 0x70be <bldr_process_msg+0x7e>
    70bc:	05 c1       	rjmp	.+522    	; 0x72c8 <bldr_process_msg+0x288>
    70be:	8d 81       	ldd	r24, Y+5	; 0x05
    70c0:	9e 81       	ldd	r25, Y+6	; 0x06
    70c2:	20 2f       	mov	r18, r16
    70c4:	22 0f       	add	r18, r18
    70c6:	2e 73       	andi	r18, 0x3E	; 62
    70c8:	3b 81       	ldd	r19, Y+3	; 0x03
    70ca:	30 7c       	andi	r19, 0xC0	; 192
    70cc:	23 2b       	or	r18, r19
    70ce:	2b 83       	std	Y+3, r18	; 0x03
    70d0:	00 23       	and	r16, r16
    70d2:	09 f4       	brne	.+2      	; 0x70d6 <bldr_process_msg+0x96>
    70d4:	29 c1       	rjmp	.+594    	; 0x7328 <bldr_process_msg+0x2e8>
    70d6:	be 01       	movw	r22, r28
    70d8:	6b 5f       	subi	r22, 0xFB	; 251
    70da:	7f 4f       	sbci	r23, 0xFF	; 255
    70dc:	6b 01       	movw	r12, r22
    70de:	22 e0       	ldi	r18, 0x02	; 2
    70e0:	c2 0e       	add	r12, r18
    70e2:	d1 1c       	adc	r13, r1
    70e4:	7c 01       	movw	r14, r24
    70e6:	ef ef       	ldi	r30, 0xFF	; 255
    70e8:	ee 1a       	sub	r14, r30
    70ea:	fe 0a       	sbc	r15, r30
    70ec:	0e 94 06 41 	call	0x820c	; 0x820c <bldr_reg_read>
    70f0:	81 11       	cpse	r24, r1
    70f2:	1e c1       	rjmp	.+572    	; 0x7330 <bldr_process_msg+0x2f0>
    70f4:	01 50       	subi	r16, 0x01	; 1
    70f6:	b6 01       	movw	r22, r12
    70f8:	c7 01       	movw	r24, r14
    70fa:	81 f7       	brne	.-32     	; 0x70dc <bldr_process_msg+0x9c>
    70fc:	15 c1       	rjmp	.+554    	; 0x7328 <bldr_process_msg+0x2e8>
    70fe:	2b 81       	ldd	r18, Y+3	; 0x03
    7100:	2f 73       	andi	r18, 0x3F	; 63
    7102:	82 2f       	mov	r24, r18
    7104:	90 e0       	ldi	r25, 0x00	; 0
    7106:	20 fd       	sbrc	r18, 0
    7108:	f5 c0       	rjmp	.+490    	; 0x72f4 <bldr_process_msg+0x2b4>
    710a:	95 95       	asr	r25
    710c:	87 95       	ror	r24
    710e:	18 2f       	mov	r17, r24
    7110:	88 23       	and	r24, r24
    7112:	09 f4       	brne	.+2      	; 0x7116 <bldr_process_msg+0xd6>
    7114:	09 c1       	rjmp	.+530    	; 0x7328 <bldr_process_msg+0x2e8>
    7116:	7e 01       	movw	r14, r28
    7118:	f5 e0       	ldi	r31, 0x05	; 5
    711a:	ef 0e       	add	r14, r31
    711c:	f1 1c       	adc	r15, r1
    711e:	b7 01       	movw	r22, r14
    7120:	f7 01       	movw	r30, r14
    7122:	80 81       	ld	r24, Z
    7124:	91 81       	ldd	r25, Z+1	; 0x01
    7126:	0e 94 06 41 	call	0x820c	; 0x820c <bldr_reg_read>
    712a:	81 11       	cpse	r24, r1
    712c:	03 c1       	rjmp	.+518    	; 0x7334 <bldr_process_msg+0x2f4>
    712e:	f2 e0       	ldi	r31, 0x02	; 2
    7130:	ef 0e       	add	r14, r31
    7132:	f1 1c       	adc	r15, r1
    7134:	11 50       	subi	r17, 0x01	; 1
    7136:	99 f7       	brne	.-26     	; 0x711e <bldr_process_msg+0xde>
    7138:	f7 c0       	rjmp	.+494    	; 0x7328 <bldr_process_msg+0x2e8>
    713a:	80 b1       	in	r24, 0x00	; 0
    713c:	86 70       	andi	r24, 0x06	; 6
    713e:	09 f4       	brne	.+2      	; 0x7142 <bldr_process_msg+0x102>
    7140:	db c0       	rjmp	.+438    	; 0x72f8 <bldr_process_msg+0x2b8>
    7142:	9b 81       	ldd	r25, Y+3	; 0x03
    7144:	9f 73       	andi	r25, 0x3F	; 63
    7146:	93 50       	subi	r25, 0x03	; 3
    7148:	91 32       	cpi	r25, 0x21	; 33
    714a:	08 f0       	brcs	.+2      	; 0x714e <bldr_process_msg+0x10e>
    714c:	d7 c0       	rjmp	.+430    	; 0x72fc <bldr_process_msg+0x2bc>
    714e:	2d 81       	ldd	r18, Y+5	; 0x05
    7150:	3e 81       	ldd	r19, Y+6	; 0x06
    7152:	8f 81       	ldd	r24, Y+7	; 0x07
    7154:	80 ff       	sbrs	r24, 0
    7156:	0d c0       	rjmp	.+26     	; 0x7172 <bldr_process_msg+0x132>
    7158:	80 b1       	in	r24, 0x00	; 0
    715a:	86 70       	andi	r24, 0x06	; 6
    715c:	84 30       	cpi	r24, 0x04	; 4
    715e:	09 f0       	breq	.+2      	; 0x7162 <bldr_process_msg+0x122>
    7160:	cf c0       	rjmp	.+414    	; 0x7300 <bldr_process_msg+0x2c0>
    7162:	a9 01       	movw	r20, r18
    7164:	49 0f       	add	r20, r25
    7166:	51 1d       	adc	r21, r1
    7168:	41 30       	cpi	r20, 0x01	; 1
    716a:	5e 41       	sbci	r21, 0x1E	; 30
    716c:	08 f0       	brcs	.+2      	; 0x7170 <bldr_process_msg+0x130>
    716e:	ca c0       	rjmp	.+404    	; 0x7304 <bldr_process_msg+0x2c4>
    7170:	0c c0       	rjmp	.+24     	; 0x718a <bldr_process_msg+0x14a>
    7172:	80 b1       	in	r24, 0x00	; 0
    7174:	86 70       	andi	r24, 0x06	; 6
    7176:	82 30       	cpi	r24, 0x02	; 2
    7178:	09 f0       	breq	.+2      	; 0x717c <bldr_process_msg+0x13c>
    717a:	c6 c0       	rjmp	.+396    	; 0x7308 <bldr_process_msg+0x2c8>
    717c:	a9 01       	movw	r20, r18
    717e:	49 0f       	add	r20, r25
    7180:	51 1d       	adc	r21, r1
    7182:	41 30       	cpi	r20, 0x01	; 1
    7184:	50 47       	sbci	r21, 0x70	; 112
    7186:	08 f0       	brcs	.+2      	; 0x718a <bldr_process_msg+0x14a>
    7188:	c1 c0       	rjmp	.+386    	; 0x730c <bldr_process_msg+0x2cc>
    718a:	4b e8       	ldi	r20, 0x8B	; 139
    718c:	5e e2       	ldi	r21, 0x2E	; 46
    718e:	fa 01       	movw	r30, r20
    7190:	a0 89       	ldd	r26, Z+16	; 0x10
    7192:	b1 89       	ldd	r27, Z+17	; 0x11
    7194:	42 89       	ldd	r20, Z+18	; 0x12
    7196:	53 89       	ldd	r21, Z+19	; 0x13
    7198:	bd 01       	movw	r22, r26
    719a:	64 0f       	add	r22, r20
    719c:	75 1f       	adc	r23, r21
    719e:	26 17       	cp	r18, r22
    71a0:	37 07       	cpc	r19, r23
    71a2:	09 f0       	breq	.+2      	; 0x71a6 <bldr_process_msg+0x166>
    71a4:	b5 c0       	rjmp	.+362    	; 0x7310 <bldr_process_msg+0x2d0>
    71a6:	91 11       	cpse	r25, r1
    71a8:	73 c0       	rjmp	.+230    	; 0x7290 <bldr_process_msg+0x250>
    71aa:	45 2b       	or	r20, r21
    71ac:	39 f0       	breq	.+14     	; 0x71bc <bldr_process_msg+0x17c>
    71ae:	40 e0       	ldi	r20, 0x00	; 0
    71b0:	b8 01       	movw	r22, r16
    71b2:	cd 01       	movw	r24, r26
    71b4:	0e 94 ff 47 	call	0x8ffe	; 0x8ffe <sbldr_prog_page>
    71b8:	81 11       	cpse	r24, r1
    71ba:	ac c0       	rjmp	.+344    	; 0x7314 <bldr_process_msg+0x2d4>
    71bc:	80 b1       	in	r24, 0x00	; 0
    71be:	86 70       	andi	r24, 0x06	; 6
    71c0:	82 30       	cpi	r24, 0x02	; 2
    71c2:	61 f4       	brne	.+24     	; 0x71dc <bldr_process_msg+0x19c>
    71c4:	eb e8       	ldi	r30, 0x8B	; 139
    71c6:	fe e2       	ldi	r31, 0x2E	; 46
    71c8:	20 89       	ldd	r18, Z+16	; 0x10
    71ca:	31 89       	ldd	r19, Z+17	; 0x11
    71cc:	82 89       	ldd	r24, Z+18	; 0x12
    71ce:	93 89       	ldd	r25, Z+19	; 0x13
    71d0:	82 0f       	add	r24, r18
    71d2:	93 1f       	adc	r25, r19
    71d4:	81 15       	cp	r24, r1
    71d6:	9e 41       	sbci	r25, 0x1E	; 30
    71d8:	09 f0       	breq	.+2      	; 0x71dc <bldr_process_msg+0x19c>
    71da:	9e c0       	rjmp	.+316    	; 0x7318 <bldr_process_msg+0x2d8>
    71dc:	80 b1       	in	r24, 0x00	; 0
    71de:	86 70       	andi	r24, 0x06	; 6
    71e0:	84 30       	cpi	r24, 0x04	; 4
    71e2:	71 f4       	brne	.+28     	; 0x7200 <bldr_process_msg+0x1c0>
    71e4:	eb e8       	ldi	r30, 0x8B	; 139
    71e6:	fe e2       	ldi	r31, 0x2E	; 46
    71e8:	20 89       	ldd	r18, Z+16	; 0x10
    71ea:	31 89       	ldd	r19, Z+17	; 0x11
    71ec:	82 89       	ldd	r24, Z+18	; 0x12
    71ee:	93 89       	ldd	r25, Z+19	; 0x13
    71f0:	82 0f       	add	r24, r18
    71f2:	93 1f       	adc	r25, r19
    71f4:	24 89       	ldd	r18, Z+20	; 0x14
    71f6:	35 89       	ldd	r19, Z+21	; 0x15
    71f8:	82 17       	cp	r24, r18
    71fa:	93 07       	cpc	r25, r19
    71fc:	09 f0       	breq	.+2      	; 0x7200 <bldr_process_msg+0x1c0>
    71fe:	8e c0       	rjmp	.+284    	; 0x731c <bldr_process_msg+0x2dc>
    7200:	eb e8       	ldi	r30, 0x8B	; 139
    7202:	fe e2       	ldi	r31, 0x2E	; 46
    7204:	86 89       	ldd	r24, Z+22	; 0x16
    7206:	97 89       	ldd	r25, Z+23	; 0x17
    7208:	04 89       	ldd	r16, Z+20	; 0x14
    720a:	15 89       	ldd	r17, Z+21	; 0x15
    720c:	e0 e0       	ldi	r30, 0x00	; 0
    720e:	f0 e0       	ldi	r31, 0x00	; 0
    7210:	0a c0       	rjmp	.+20     	; 0x7226 <bldr_process_msg+0x1e6>
    7212:	7f 01       	movw	r14, r30
    7214:	2f ef       	ldi	r18, 0xFF	; 255
    7216:	e2 1a       	sub	r14, r18
    7218:	f2 0a       	sbc	r15, r18
    721a:	64 91       	lpm	r22, Z
    721c:	0e 94 06 38 	call	0x700c	; 0x700c <crc_ccitt_update>
    7220:	01 50       	subi	r16, 0x01	; 1
    7222:	11 09       	sbc	r17, r1
    7224:	f7 01       	movw	r30, r14
    7226:	01 15       	cp	r16, r1
    7228:	11 05       	cpc	r17, r1
    722a:	99 f7       	brne	.-26     	; 0x7212 <bldr_process_msg+0x1d2>
    722c:	89 2b       	or	r24, r25
    722e:	09 f0       	breq	.+2      	; 0x7232 <bldr_process_msg+0x1f2>
    7230:	77 c0       	rjmp	.+238    	; 0x7320 <bldr_process_msg+0x2e0>
    7232:	1e ef       	ldi	r17, 0xFE	; 254
    7234:	52 c0       	rjmp	.+164    	; 0x72da <bldr_process_msg+0x29a>
    7236:	6b e8       	ldi	r22, 0x8B	; 139
    7238:	7e e2       	ldi	r23, 0x2E	; 46
    723a:	fb 01       	movw	r30, r22
    723c:	82 89       	ldd	r24, Z+18	; 0x12
    723e:	93 89       	ldd	r25, Z+19	; 0x13
    7240:	ac 01       	movw	r20, r24
    7242:	4f 5f       	subi	r20, 0xFF	; 255
    7244:	5f 4f       	sbci	r21, 0xFF	; 255
    7246:	42 8b       	std	Z+18, r20	; 0x12
    7248:	53 8b       	std	Z+19, r21	; 0x13
    724a:	d8 01       	movw	r26, r16
    724c:	a8 0f       	add	r26, r24
    724e:	b9 1f       	adc	r27, r25
    7250:	2c 0f       	add	r18, r28
    7252:	3d 1f       	adc	r19, r29
    7254:	f9 01       	movw	r30, r18
    7256:	25 81       	ldd	r18, Z+5	; 0x05
    7258:	2c 93       	st	X, r18
    725a:	fb 01       	movw	r30, r22
    725c:	82 89       	ldd	r24, Z+18	; 0x12
    725e:	93 89       	ldd	r25, Z+19	; 0x13
    7260:	81 15       	cp	r24, r1
    7262:	91 40       	sbci	r25, 0x01	; 1
    7264:	99 f4       	brne	.+38     	; 0x728c <bldr_process_msg+0x24c>
    7266:	40 e0       	ldi	r20, 0x00	; 0
    7268:	b8 01       	movw	r22, r16
    726a:	80 91 9b 2e 	lds	r24, 0x2E9B	; 0x802e9b <__bss_end+0xdb2>
    726e:	90 91 9c 2e 	lds	r25, 0x2E9C	; 0x802e9c <__bss_end+0xdb3>
    7272:	0e 94 ff 47 	call	0x8ffe	; 0x8ffe <sbldr_prog_page>
    7276:	81 11       	cpse	r24, r1
    7278:	55 c0       	rjmp	.+170    	; 0x7324 <bldr_process_msg+0x2e4>
    727a:	eb e8       	ldi	r30, 0x8B	; 139
    727c:	fe e2       	ldi	r31, 0x2E	; 46
    727e:	80 89       	ldd	r24, Z+16	; 0x10
    7280:	91 89       	ldd	r25, Z+17	; 0x11
    7282:	93 95       	inc	r25
    7284:	80 8b       	std	Z+16, r24	; 0x10
    7286:	91 8b       	std	Z+17, r25	; 0x11
    7288:	12 8a       	std	Z+18, r1	; 0x12
    728a:	13 8a       	std	Z+19, r1	; 0x13
    728c:	f3 94       	inc	r15
    728e:	04 c0       	rjmp	.+8      	; 0x7298 <bldr_process_msg+0x258>
    7290:	0f 2e       	mov	r0, r31
    7292:	f3 e0       	ldi	r31, 0x03	; 3
    7294:	ff 2e       	mov	r15, r31
    7296:	f0 2d       	mov	r31, r0
    7298:	2f 2d       	mov	r18, r15
    729a:	30 e0       	ldi	r19, 0x00	; 0
    729c:	8b 81       	ldd	r24, Y+3	; 0x03
    729e:	8f 73       	andi	r24, 0x3F	; 63
    72a0:	90 e0       	ldi	r25, 0x00	; 0
    72a2:	28 17       	cp	r18, r24
    72a4:	39 07       	cpc	r19, r25
    72a6:	3c f2       	brlt	.-114    	; 0x7236 <bldr_process_msg+0x1f6>
    72a8:	8b 81       	ldd	r24, Y+3	; 0x03
    72aa:	80 7c       	andi	r24, 0xC0	; 192
    72ac:	8b 83       	std	Y+3, r24	; 0x03
    72ae:	3c c0       	rjmp	.+120    	; 0x7328 <bldr_process_msg+0x2e8>
    72b0:	ce 01       	movw	r24, r28
    72b2:	0e 94 04 41 	call	0x8208	; 0x8208 <bldr_process_basic_msg>
    72b6:	18 2f       	mov	r17, r24
    72b8:	01 c0       	rjmp	.+2      	; 0x72bc <bldr_process_msg+0x27c>
    72ba:	1f ef       	ldi	r17, 0xFF	; 255
    72bc:	1f 3f       	cpi	r17, 0xFF	; 255
    72be:	e9 f1       	breq	.+122    	; 0x733a <bldr_process_msg+0x2fa>
    72c0:	11 23       	and	r17, r17
    72c2:	59 f0       	breq	.+22     	; 0x72da <bldr_process_msg+0x29a>
    72c4:	1e 3f       	cpi	r17, 0xFE	; 254
    72c6:	49 f0       	breq	.+18     	; 0x72da <bldr_process_msg+0x29a>
    72c8:	8b 81       	ldd	r24, Y+3	; 0x03
    72ca:	80 7c       	andi	r24, 0xC0	; 192
    72cc:	82 60       	ori	r24, 0x02	; 2
    72ce:	8b 83       	std	Y+3, r24	; 0x03
    72d0:	8c 81       	ldd	r24, Y+4	; 0x04
    72d2:	8d 83       	std	Y+5, r24	; 0x05
    72d4:	1e 83       	std	Y+6, r17	; 0x06
    72d6:	80 e8       	ldi	r24, 0x80	; 128
    72d8:	8c 83       	std	Y+4, r24	; 0x04
    72da:	89 81       	ldd	r24, Y+1	; 0x01
    72dc:	88 83       	st	Y, r24
    72de:	8c 81       	ldd	r24, Y+4	; 0x04
    72e0:	80 68       	ori	r24, 0x80	; 128
    72e2:	8c 83       	std	Y+4, r24	; 0x04
    72e4:	ce 01       	movw	r24, r28
    72e6:	0e 94 71 45 	call	0x8ae2	; 0x8ae2 <sboxnet_send_msg>
    72ea:	27 c0       	rjmp	.+78     	; 0x733a <bldr_process_msg+0x2fa>
    72ec:	10 e0       	ldi	r17, 0x00	; 0
    72ee:	25 c0       	rjmp	.+74     	; 0x733a <bldr_process_msg+0x2fa>
    72f0:	13 e0       	ldi	r17, 0x03	; 3
    72f2:	ea cf       	rjmp	.-44     	; 0x72c8 <bldr_process_msg+0x288>
    72f4:	13 e0       	ldi	r17, 0x03	; 3
    72f6:	e8 cf       	rjmp	.-48     	; 0x72c8 <bldr_process_msg+0x288>
    72f8:	15 e6       	ldi	r17, 0x65	; 101
    72fa:	e6 cf       	rjmp	.-52     	; 0x72c8 <bldr_process_msg+0x288>
    72fc:	13 e0       	ldi	r17, 0x03	; 3
    72fe:	e4 cf       	rjmp	.-56     	; 0x72c8 <bldr_process_msg+0x288>
    7300:	15 e6       	ldi	r17, 0x65	; 101
    7302:	e2 cf       	rjmp	.-60     	; 0x72c8 <bldr_process_msg+0x288>
    7304:	16 e6       	ldi	r17, 0x66	; 102
    7306:	e0 cf       	rjmp	.-64     	; 0x72c8 <bldr_process_msg+0x288>
    7308:	15 e6       	ldi	r17, 0x65	; 101
    730a:	de cf       	rjmp	.-68     	; 0x72c8 <bldr_process_msg+0x288>
    730c:	16 e6       	ldi	r17, 0x66	; 102
    730e:	dc cf       	rjmp	.-72     	; 0x72c8 <bldr_process_msg+0x288>
    7310:	17 e6       	ldi	r17, 0x67	; 103
    7312:	da cf       	rjmp	.-76     	; 0x72c8 <bldr_process_msg+0x288>
    7314:	1a e6       	ldi	r17, 0x6A	; 106
    7316:	d8 cf       	rjmp	.-80     	; 0x72c8 <bldr_process_msg+0x288>
    7318:	16 e6       	ldi	r17, 0x66	; 102
    731a:	d6 cf       	rjmp	.-84     	; 0x72c8 <bldr_process_msg+0x288>
    731c:	16 e6       	ldi	r17, 0x66	; 102
    731e:	d4 cf       	rjmp	.-88     	; 0x72c8 <bldr_process_msg+0x288>
    7320:	1b e6       	ldi	r17, 0x6B	; 107
    7322:	d2 cf       	rjmp	.-92     	; 0x72c8 <bldr_process_msg+0x288>
    7324:	1a e6       	ldi	r17, 0x6A	; 106
    7326:	d0 cf       	rjmp	.-96     	; 0x72c8 <bldr_process_msg+0x288>
    7328:	10 e0       	ldi	r17, 0x00	; 0
    732a:	d7 cf       	rjmp	.-82     	; 0x72da <bldr_process_msg+0x29a>
    732c:	1f ef       	ldi	r17, 0xFF	; 255
    732e:	05 c0       	rjmp	.+10     	; 0x733a <bldr_process_msg+0x2fa>
    7330:	18 2f       	mov	r17, r24
    7332:	01 c0       	rjmp	.+2      	; 0x7336 <bldr_process_msg+0x2f6>
    7334:	18 2f       	mov	r17, r24
    7336:	1f 3f       	cpi	r17, 0xFF	; 255
    7338:	29 f6       	brne	.-118    	; 0x72c4 <bldr_process_msg+0x284>
    733a:	81 2f       	mov	r24, r17
    733c:	df 91       	pop	r29
    733e:	cf 91       	pop	r28
    7340:	1f 91       	pop	r17
    7342:	0f 91       	pop	r16
    7344:	ff 90       	pop	r15
    7346:	ef 90       	pop	r14
    7348:	df 90       	pop	r13
    734a:	cf 90       	pop	r12
    734c:	08 95       	ret

0000734e <bldr_main>:
    734e:	cf 93       	push	r28
    7350:	df 93       	push	r29
    7352:	cd b7       	in	r28, 0x3d	; 61
    7354:	de b7       	in	r29, 0x3e	; 62
    7356:	c5 54       	subi	r28, 0x45	; 69
    7358:	d1 40       	sbci	r29, 0x01	; 1
    735a:	cd bf       	out	0x3d, r28	; 61
    735c:	de bf       	out	0x3e, r29	; 62
    735e:	98 ed       	ldi	r25, 0xD8	; 216
    7360:	94 bf       	out	0x34, r25	; 52
    7362:	92 e4       	ldi	r25, 0x42	; 66
    7364:	90 93 a2 00 	sts	0x00A2, r25	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7f70a2>
    7368:	00 9a       	sbi	0x00, 0	; 0
    736a:	88 23       	and	r24, r24
    736c:	21 f0       	breq	.+8      	; 0x7376 <bldr_main+0x28>
    736e:	0e 94 18 38 	call	0x7030	; 0x7030 <bldr_process_cmd_net_reset>
    7372:	0e 94 c9 41 	call	0x8392	; 0x8392 <sboxnet_init>
    7376:	e8 e4       	ldi	r30, 0x48	; 72
    7378:	f0 e0       	ldi	r31, 0x00	; 0
    737a:	80 81       	ld	r24, Z
    737c:	81 7f       	andi	r24, 0xF1	; 241
    737e:	80 83       	st	Z, r24
    7380:	78 94       	sei
    7382:	ce 01       	movw	r24, r28
    7384:	01 96       	adiw	r24, 0x01	; 1
    7386:	0e 94 02 41 	call	0x8204	; 0x8204 <bldr_task>
    738a:	81 11       	cpse	r24, r1
    738c:	18 c0       	rjmp	.+48     	; 0x73be <bldr_main+0x70>
    738e:	65 e4       	ldi	r22, 0x45	; 69
    7390:	ce 01       	movw	r24, r28
    7392:	01 96       	adiw	r24, 0x01	; 1
    7394:	0e 94 da 44 	call	0x89b4	; 0x89b4 <sboxnet_receive_msg>
    7398:	18 16       	cp	r1, r24
    739a:	8c f4       	brge	.+34     	; 0x73be <bldr_main+0x70>
    739c:	be 01       	movw	r22, r28
    739e:	6a 5b       	subi	r22, 0xBA	; 186
    73a0:	7f 4f       	sbci	r23, 0xFF	; 255
    73a2:	ce 01       	movw	r24, r28
    73a4:	01 96       	adiw	r24, 0x01	; 1
    73a6:	0e 94 20 38 	call	0x7040	; 0x7040 <bldr_process_msg>
    73aa:	8e 3f       	cpi	r24, 0xFE	; 254
    73ac:	41 f4       	brne	.+16     	; 0x73be <bldr_main+0x70>
    73ae:	0e 94 00 38 	call	0x7000	; 0x7000 <sboxnet_all_sent>
    73b2:	88 23       	and	r24, r24
    73b4:	e1 f3       	breq	.-8      	; 0x73ae <bldr_main+0x60>
    73b6:	80 b1       	in	r24, 0x00	; 0
    73b8:	84 70       	andi	r24, 0x04	; 4
    73ba:	0e 94 fe 47 	call	0x8ffc	; 0x8ffc <sbldr_finish_fwup>
    73be:	e8 e4       	ldi	r30, 0x48	; 72
    73c0:	f0 e0       	ldi	r31, 0x00	; 0
    73c2:	80 81       	ld	r24, Z
    73c4:	81 60       	ori	r24, 0x01	; 1
    73c6:	80 83       	st	Z, r24
    73c8:	88 95       	sleep
    73ca:	80 81       	ld	r24, Z
    73cc:	8e 7f       	andi	r24, 0xFE	; 254
    73ce:	80 83       	st	Z, r24
    73d0:	d8 cf       	rjmp	.-80     	; 0x7382 <bldr_main+0x34>

000073d2 <sboxnet_can_send_msg>:
    73d2:	fc 01       	movw	r30, r24
    73d4:	23 81       	ldd	r18, Z+3	; 0x03
    73d6:	2f 73       	andi	r18, 0x3F	; 63
    73d8:	2a 5f       	subi	r18, 0xFA	; 250
    73da:	8f b7       	in	r24, 0x3f	; 63
    73dc:	f8 94       	cli
    73de:	e4 e4       	ldi	r30, 0x44	; 68
    73e0:	ff e2       	ldi	r31, 0x2F	; 47
    73e2:	97 81       	ldd	r25, Z+7	; 0x07
    73e4:	36 81       	ldd	r19, Z+6	; 0x06
    73e6:	93 1b       	sub	r25, r19
    73e8:	34 81       	ldd	r19, Z+4	; 0x04
    73ea:	93 1b       	sub	r25, r19
    73ec:	8f bf       	out	0x3f, r24	; 63
    73ee:	81 e0       	ldi	r24, 0x01	; 1
    73f0:	29 17       	cp	r18, r25
    73f2:	08 f0       	brcs	.+2      	; 0x73f6 <sboxnet_can_send_msg+0x24>
    73f4:	80 e0       	ldi	r24, 0x00	; 0
    73f6:	08 95       	ret

000073f8 <__vector_49>:
    73f8:	1f 92       	push	r1
    73fa:	0f 92       	push	r0
    73fc:	0f b6       	in	r0, 0x3f	; 63
    73fe:	0f 92       	push	r0
    7400:	11 24       	eor	r1, r1
    7402:	2f 93       	push	r18
    7404:	3f 93       	push	r19
    7406:	4f 93       	push	r20
    7408:	5f 93       	push	r21
    740a:	6f 93       	push	r22
    740c:	7f 93       	push	r23
    740e:	8f 93       	push	r24
    7410:	9f 93       	push	r25
    7412:	af 93       	push	r26
    7414:	bf 93       	push	r27
    7416:	ef 93       	push	r30
    7418:	ff 93       	push	r31
    741a:	0e 94 47 44 	call	0x888e	; 0x888e <sboxnet_timer_bit>
    741e:	ff 91       	pop	r31
    7420:	ef 91       	pop	r30
    7422:	bf 91       	pop	r27
    7424:	af 91       	pop	r26
    7426:	9f 91       	pop	r25
    7428:	8f 91       	pop	r24
    742a:	7f 91       	pop	r23
    742c:	6f 91       	pop	r22
    742e:	5f 91       	pop	r21
    7430:	4f 91       	pop	r20
    7432:	3f 91       	pop	r19
    7434:	2f 91       	pop	r18
    7436:	0f 90       	pop	r0
    7438:	0f be       	out	0x3f, r0	; 63
    743a:	0f 90       	pop	r0
    743c:	1f 90       	pop	r1
    743e:	18 95       	reti

00007440 <__vector_47>:
    7440:	1f 92       	push	r1
    7442:	0f 92       	push	r0
    7444:	0f b6       	in	r0, 0x3f	; 63
    7446:	0f 92       	push	r0
    7448:	11 24       	eor	r1, r1
    744a:	8f 93       	push	r24
    744c:	ef 93       	push	r30
    744e:	ff 93       	push	r31
    7450:	eb e8       	ldi	r30, 0x8B	; 139
    7452:	fe e2       	ldi	r31, 0x2E	; 46
    7454:	85 81       	ldd	r24, Z+5	; 0x05
    7456:	8f 5f       	subi	r24, 0xFF	; 255
    7458:	85 83       	std	Z+5, r24	; 0x05
    745a:	86 81       	ldd	r24, Z+6	; 0x06
    745c:	88 23       	and	r24, r24
    745e:	19 f0       	breq	.+6      	; 0x7466 <__vector_47+0x26>
    7460:	86 81       	ldd	r24, Z+6	; 0x06
    7462:	81 50       	subi	r24, 0x01	; 1
    7464:	86 83       	std	Z+6, r24	; 0x06
    7466:	80 91 93 2e 	lds	r24, 0x2E93	; 0x802e93 <__bss_end+0xdaa>
    746a:	88 23       	and	r24, r24
    746c:	29 f0       	breq	.+10     	; 0x7478 <__vector_47+0x38>
    746e:	eb e8       	ldi	r30, 0x8B	; 139
    7470:	fe e2       	ldi	r31, 0x2E	; 46
    7472:	80 85       	ldd	r24, Z+8	; 0x08
    7474:	81 50       	subi	r24, 0x01	; 1
    7476:	80 87       	std	Z+8, r24	; 0x08
    7478:	80 91 94 2e 	lds	r24, 0x2E94	; 0x802e94 <__bss_end+0xdab>
    747c:	88 23       	and	r24, r24
    747e:	29 f0       	breq	.+10     	; 0x748a <__vector_47+0x4a>
    7480:	eb e8       	ldi	r30, 0x8B	; 139
    7482:	fe e2       	ldi	r31, 0x2E	; 46
    7484:	81 85       	ldd	r24, Z+9	; 0x09
    7486:	81 50       	subi	r24, 0x01	; 1
    7488:	81 87       	std	Z+9, r24	; 0x09
    748a:	80 91 92 2e 	lds	r24, 0x2E92	; 0x802e92 <__bss_end+0xda9>
    748e:	88 23       	and	r24, r24
    7490:	39 f0       	breq	.+14     	; 0x74a0 <__vector_47+0x60>
    7492:	05 98       	cbi	0x00, 5	; 0
    7494:	eb e8       	ldi	r30, 0x8B	; 139
    7496:	fe e2       	ldi	r31, 0x2E	; 46
    7498:	87 81       	ldd	r24, Z+7	; 0x07
    749a:	81 50       	subi	r24, 0x01	; 1
    749c:	87 83       	std	Z+7, r24	; 0x07
    749e:	01 c0       	rjmp	.+2      	; 0x74a2 <__vector_47+0x62>
    74a0:	05 9a       	sbi	0x00, 5	; 0
    74a2:	ff 91       	pop	r31
    74a4:	ef 91       	pop	r30
    74a6:	8f 91       	pop	r24
    74a8:	0f 90       	pop	r0
    74aa:	0f be       	out	0x3f, r0	; 63
    74ac:	0f 90       	pop	r0
    74ae:	1f 90       	pop	r1
    74b0:	18 95       	reti

000074b2 <_bldr_process_basic_msg>:
    74b2:	ef 92       	push	r14
    74b4:	ff 92       	push	r15
    74b6:	0f 93       	push	r16
    74b8:	1f 93       	push	r17
    74ba:	cf 93       	push	r28
    74bc:	df 93       	push	r29
    74be:	fc 01       	movw	r30, r24
    74c0:	94 81       	ldd	r25, Z+4	; 0x04
    74c2:	96 31       	cpi	r25, 0x16	; 22
    74c4:	09 f4       	brne	.+2      	; 0x74c8 <_bldr_process_basic_msg+0x16>
    74c6:	c5 c0       	rjmp	.+394    	; 0x7652 <_bldr_process_basic_msg+0x1a0>
    74c8:	20 f4       	brcc	.+8      	; 0x74d2 <_bldr_process_basic_msg+0x20>
    74ca:	92 31       	cpi	r25, 0x12	; 18
    74cc:	09 f4       	brne	.+2      	; 0x74d0 <_bldr_process_basic_msg+0x1e>
    74ce:	84 c0       	rjmp	.+264    	; 0x75d8 <_bldr_process_basic_msg+0x126>
    74d0:	05 c0       	rjmp	.+10     	; 0x74dc <_bldr_process_basic_msg+0x2a>
    74d2:	98 31       	cpi	r25, 0x18	; 24
    74d4:	29 f0       	breq	.+10     	; 0x74e0 <_bldr_process_basic_msg+0x2e>
    74d6:	99 31       	cpi	r25, 0x19	; 25
    74d8:	09 f4       	brne	.+2      	; 0x74dc <_bldr_process_basic_msg+0x2a>
    74da:	ca c0       	rjmp	.+404    	; 0x7670 <_bldr_process_basic_msg+0x1be>
    74dc:	82 e0       	ldi	r24, 0x02	; 2
    74de:	dd c0       	rjmp	.+442    	; 0x769a <_bldr_process_basic_msg+0x1e8>
    74e0:	83 81       	ldd	r24, Z+3	; 0x03
    74e2:	8f 73       	andi	r24, 0x3F	; 63
    74e4:	01 98       	cbi	0x00, 1	; 0
    74e6:	02 98       	cbi	0x00, 2	; 0
    74e8:	83 32       	cpi	r24, 0x23	; 35
    74ea:	09 f0       	breq	.+2      	; 0x74ee <_bldr_process_basic_msg+0x3c>
    74ec:	c3 c0       	rjmp	.+390    	; 0x7674 <_bldr_process_basic_msg+0x1c2>
    74ee:	25 81       	ldd	r18, Z+5	; 0x05
    74f0:	36 81       	ldd	r19, Z+6	; 0x06
    74f2:	80 85       	ldd	r24, Z+8	; 0x08
    74f4:	91 85       	ldd	r25, Z+9	; 0x09
    74f6:	a2 85       	ldd	r26, Z+10	; 0x0a
    74f8:	b3 85       	ldd	r27, Z+11	; 0x0b
    74fa:	83 35       	cpi	r24, 0x53	; 83
    74fc:	42 e6       	ldi	r20, 0x62	; 98
    74fe:	94 07       	cpc	r25, r20
    7500:	4e e6       	ldi	r20, 0x6E	; 110
    7502:	a4 07       	cpc	r26, r20
    7504:	42 e4       	ldi	r20, 0x42	; 66
    7506:	b4 07       	cpc	r27, r20
    7508:	51 f4       	brne	.+20     	; 0x751e <_bldr_process_basic_msg+0x6c>
    750a:	87 81       	ldd	r24, Z+7	; 0x07
    750c:	80 fd       	sbrc	r24, 0
    750e:	b4 c0       	rjmp	.+360    	; 0x7678 <_bldr_process_basic_msg+0x1c6>
    7510:	21 15       	cp	r18, r1
    7512:	6e e1       	ldi	r22, 0x1E	; 30
    7514:	36 07       	cpc	r19, r22
    7516:	09 f0       	breq	.+2      	; 0x751a <_bldr_process_basic_msg+0x68>
    7518:	b1 c0       	rjmp	.+354    	; 0x767c <_bldr_process_basic_msg+0x1ca>
    751a:	01 9a       	sbi	0x00, 1	; 0
    751c:	3d c0       	rjmp	.+122    	; 0x7598 <_bldr_process_basic_msg+0xe6>
    751e:	83 35       	cpi	r24, 0x53	; 83
    7520:	92 46       	sbci	r25, 0x62	; 98
    7522:	ae 46       	sbci	r26, 0x6E	; 110
    7524:	b1 44       	sbci	r27, 0x41	; 65
    7526:	c1 f5       	brne	.+112    	; 0x7598 <_bldr_process_basic_msg+0xe6>
    7528:	87 81       	ldd	r24, Z+7	; 0x07
    752a:	80 ff       	sbrs	r24, 0
    752c:	a9 c0       	rjmp	.+338    	; 0x7680 <_bldr_process_basic_msg+0x1ce>
    752e:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    7532:	88 23       	and	r24, r24
    7534:	e4 f3       	brlt	.-8      	; 0x752e <_bldr_process_basic_msg+0x7c>
    7536:	ac ec       	ldi	r26, 0xCC	; 204
    7538:	b1 e0       	ldi	r27, 0x01	; 1
    753a:	8c 91       	ld	r24, X
    753c:	88 60       	ori	r24, 0x08	; 8
    753e:	8c 93       	st	X, r24
    7540:	40 91 05 13 	lds	r20, 0x1305	; 0x801305 <__TEXT_REGION_LENGTH__+0x7f8305>
    7544:	50 91 06 13 	lds	r21, 0x1306	; 0x801306 <__TEXT_REGION_LENGTH__+0x7f8306>
    7548:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    754c:	88 23       	and	r24, r24
    754e:	e4 f3       	brlt	.-8      	; 0x7548 <_bldr_process_basic_msg+0x96>
    7550:	ac ec       	ldi	r26, 0xCC	; 204
    7552:	b1 e0       	ldi	r27, 0x01	; 1
    7554:	8c 91       	ld	r24, X
    7556:	88 60       	ori	r24, 0x08	; 8
    7558:	8c 93       	st	X, r24
    755a:	80 91 07 13 	lds	r24, 0x1307	; 0x801307 <__TEXT_REGION_LENGTH__+0x7f8307>
    755e:	90 91 08 13 	lds	r25, 0x1308	; 0x801308 <__TEXT_REGION_LENGTH__+0x7f8308>
    7562:	4f 3f       	cpi	r20, 0xFF	; 255
    7564:	6f ef       	ldi	r22, 0xFF	; 255
    7566:	56 07       	cpc	r21, r22
    7568:	21 f4       	brne	.+8      	; 0x7572 <_bldr_process_basic_msg+0xc0>
    756a:	8f 3f       	cpi	r24, 0xFF	; 255
    756c:	6f ef       	ldi	r22, 0xFF	; 255
    756e:	96 07       	cpc	r25, r22
    7570:	61 f0       	breq	.+24     	; 0x758a <_bldr_process_basic_msg+0xd8>
    7572:	64 85       	ldd	r22, Z+12	; 0x0c
    7574:	75 85       	ldd	r23, Z+13	; 0x0d
    7576:	46 17       	cp	r20, r22
    7578:	57 07       	cpc	r21, r23
    757a:	09 f0       	breq	.+2      	; 0x757e <_bldr_process_basic_msg+0xcc>
    757c:	83 c0       	rjmp	.+262    	; 0x7684 <_bldr_process_basic_msg+0x1d2>
    757e:	46 85       	ldd	r20, Z+14	; 0x0e
    7580:	57 85       	ldd	r21, Z+15	; 0x0f
    7582:	84 17       	cp	r24, r20
    7584:	95 07       	cpc	r25, r21
    7586:	09 f0       	breq	.+2      	; 0x758a <_bldr_process_basic_msg+0xd8>
    7588:	7f c0       	rjmp	.+254    	; 0x7688 <_bldr_process_basic_msg+0x1d6>
    758a:	c9 01       	movw	r24, r18
    758c:	01 97       	sbiw	r24, 0x01	; 1
    758e:	8f 3f       	cpi	r24, 0xFF	; 255
    7590:	9f 46       	sbci	r25, 0x6F	; 111
    7592:	08 f0       	brcs	.+2      	; 0x7596 <_bldr_process_basic_msg+0xe4>
    7594:	7b c0       	rjmp	.+246    	; 0x768c <_bldr_process_basic_msg+0x1da>
    7596:	02 9a       	sbi	0x00, 2	; 0
    7598:	7f 01       	movw	r14, r30
    759a:	8f 01       	movw	r16, r30
    759c:	08 5f       	subi	r16, 0xF8	; 248
    759e:	1f 4f       	sbci	r17, 0xFF	; 255
    75a0:	eb e8       	ldi	r30, 0x8B	; 139
    75a2:	fe e2       	ldi	r31, 0x2E	; 46
    75a4:	10 8a       	std	Z+16, r1	; 0x10
    75a6:	11 8a       	std	Z+17, r1	; 0x11
    75a8:	12 8a       	std	Z+18, r1	; 0x12
    75aa:	13 8a       	std	Z+19, r1	; 0x13
    75ac:	24 8b       	std	Z+20, r18	; 0x14
    75ae:	35 8b       	std	Z+21, r19	; 0x15
    75b0:	c0 e2       	ldi	r28, 0x20	; 32
    75b2:	8f ef       	ldi	r24, 0xFF	; 255
    75b4:	9f ef       	ldi	r25, 0xFF	; 255
    75b6:	f8 01       	movw	r30, r16
    75b8:	61 91       	ld	r22, Z+
    75ba:	8f 01       	movw	r16, r30
    75bc:	0e 94 06 38 	call	0x700c	; 0x700c <crc_ccitt_update>
    75c0:	c1 50       	subi	r28, 0x01	; 1
    75c2:	c9 f7       	brne	.-14     	; 0x75b6 <_bldr_process_basic_msg+0x104>
    75c4:	80 93 a1 2e 	sts	0x2EA1, r24	; 0x802ea1 <__bss_end+0xdb8>
    75c8:	90 93 a2 2e 	sts	0x2EA2, r25	; 0x802ea2 <__bss_end+0xdb9>
    75cc:	f7 01       	movw	r30, r14
    75ce:	83 81       	ldd	r24, Z+3	; 0x03
    75d0:	80 7c       	andi	r24, 0xC0	; 192
    75d2:	83 83       	std	Z+3, r24	; 0x03
    75d4:	80 e0       	ldi	r24, 0x00	; 0
    75d6:	61 c0       	rjmp	.+194    	; 0x769a <_bldr_process_basic_msg+0x1e8>
    75d8:	83 81       	ldd	r24, Z+3	; 0x03
    75da:	8f 73       	andi	r24, 0x3F	; 63
    75dc:	90 e0       	ldi	r25, 0x00	; 0
    75de:	02 97       	sbiw	r24, 0x02	; 2
    75e0:	0c f0       	brlt	.+2      	; 0x75e4 <_bldr_process_basic_msg+0x132>
    75e2:	56 c0       	rjmp	.+172    	; 0x7690 <_bldr_process_basic_msg+0x1de>
    75e4:	83 81       	ldd	r24, Z+3	; 0x03
    75e6:	8f 73       	andi	r24, 0x3F	; 63
    75e8:	81 30       	cpi	r24, 0x01	; 1
    75ea:	29 f4       	brne	.+10     	; 0x75f6 <_bldr_process_basic_msg+0x144>
    75ec:	25 81       	ldd	r18, Z+5	; 0x05
    75ee:	23 30       	cpi	r18, 0x03	; 3
    75f0:	08 f0       	brcs	.+2      	; 0x75f4 <_bldr_process_basic_msg+0x142>
    75f2:	50 c0       	rjmp	.+160    	; 0x7694 <_bldr_process_basic_msg+0x1e2>
    75f4:	01 c0       	rjmp	.+2      	; 0x75f8 <_bldr_process_basic_msg+0x146>
    75f6:	20 e0       	ldi	r18, 0x00	; 0
    75f8:	40 e2       	ldi	r20, 0x20	; 32
    75fa:	24 9f       	mul	r18, r20
    75fc:	90 01       	movw	r18, r0
    75fe:	11 24       	eor	r1, r1
    7600:	20 5c       	subi	r18, 0xC0	; 192
    7602:	3c 4f       	sbci	r19, 0xFC	; 252
    7604:	90 e0       	ldi	r25, 0x00	; 0
    7606:	02 c0       	rjmp	.+4      	; 0x760c <_bldr_process_basic_msg+0x15a>
    7608:	92 2f       	mov	r25, r18
    760a:	9a 01       	movw	r18, r20
    760c:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    7610:	88 23       	and	r24, r24
    7612:	e4 f3       	brlt	.-8      	; 0x760c <_bldr_process_basic_msg+0x15a>
    7614:	ac ec       	ldi	r26, 0xCC	; 204
    7616:	b1 e0       	ldi	r27, 0x01	; 1
    7618:	8c 91       	ld	r24, X
    761a:	88 60       	ori	r24, 0x08	; 8
    761c:	8c 93       	st	X, r24
    761e:	a9 01       	movw	r20, r18
    7620:	4f 5f       	subi	r20, 0xFF	; 255
    7622:	5f 4f       	sbci	r21, 0xFF	; 255
    7624:	d9 01       	movw	r26, r18
    7626:	b0 5f       	subi	r27, 0xF0	; 240
    7628:	8c 91       	ld	r24, X
    762a:	2f ef       	ldi	r18, 0xFF	; 255
    762c:	28 0f       	add	r18, r24
    762e:	2e 3f       	cpi	r18, 0xFE	; 254
    7630:	48 f4       	brcc	.+18     	; 0x7644 <_bldr_process_basic_msg+0x192>
    7632:	21 e0       	ldi	r18, 0x01	; 1
    7634:	29 0f       	add	r18, r25
    7636:	ef 01       	movw	r28, r30
    7638:	c9 0f       	add	r28, r25
    763a:	d1 1d       	adc	r29, r1
    763c:	8d 83       	std	Y+5, r24	; 0x05
    763e:	20 32       	cpi	r18, 0x20	; 32
    7640:	18 f3       	brcs	.-58     	; 0x7608 <_bldr_process_basic_msg+0x156>
    7642:	92 2f       	mov	r25, r18
    7644:	9f 73       	andi	r25, 0x3F	; 63
    7646:	83 81       	ldd	r24, Z+3	; 0x03
    7648:	80 7c       	andi	r24, 0xC0	; 192
    764a:	98 2b       	or	r25, r24
    764c:	93 83       	std	Z+3, r25	; 0x03
    764e:	80 e0       	ldi	r24, 0x00	; 0
    7650:	24 c0       	rjmp	.+72     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7652:	83 81       	ldd	r24, Z+3	; 0x03
    7654:	8f 73       	andi	r24, 0x3F	; 63
    7656:	81 30       	cpi	r24, 0x01	; 1
    7658:	f9 f4       	brne	.+62     	; 0x7698 <_bldr_process_basic_msg+0x1e6>
    765a:	85 81       	ldd	r24, Z+5	; 0x05
    765c:	80 ff       	sbrs	r24, 0
    765e:	02 c0       	rjmp	.+4      	; 0x7664 <_bldr_process_basic_msg+0x1b2>
    7660:	04 9a       	sbi	0x00, 4	; 0
    7662:	01 c0       	rjmp	.+2      	; 0x7666 <_bldr_process_basic_msg+0x1b4>
    7664:	04 98       	cbi	0x00, 4	; 0
    7666:	83 81       	ldd	r24, Z+3	; 0x03
    7668:	80 7c       	andi	r24, 0xC0	; 192
    766a:	83 83       	std	Z+3, r24	; 0x03
    766c:	80 e0       	ldi	r24, 0x00	; 0
    766e:	15 c0       	rjmp	.+42     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7670:	85 e6       	ldi	r24, 0x65	; 101
    7672:	13 c0       	rjmp	.+38     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7674:	83 e0       	ldi	r24, 0x03	; 3
    7676:	11 c0       	rjmp	.+34     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7678:	89 e6       	ldi	r24, 0x69	; 105
    767a:	0f c0       	rjmp	.+30     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    767c:	86 e6       	ldi	r24, 0x66	; 102
    767e:	0d c0       	rjmp	.+26     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7680:	89 e6       	ldi	r24, 0x69	; 105
    7682:	0b c0       	rjmp	.+22     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7684:	88 e6       	ldi	r24, 0x68	; 104
    7686:	09 c0       	rjmp	.+18     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7688:	88 e6       	ldi	r24, 0x68	; 104
    768a:	07 c0       	rjmp	.+14     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    768c:	86 e6       	ldi	r24, 0x66	; 102
    768e:	05 c0       	rjmp	.+10     	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7690:	83 e0       	ldi	r24, 0x03	; 3
    7692:	03 c0       	rjmp	.+6      	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7694:	83 e0       	ldi	r24, 0x03	; 3
    7696:	01 c0       	rjmp	.+2      	; 0x769a <_bldr_process_basic_msg+0x1e8>
    7698:	83 e0       	ldi	r24, 0x03	; 3
    769a:	df 91       	pop	r29
    769c:	cf 91       	pop	r28
    769e:	1f 91       	pop	r17
    76a0:	0f 91       	pop	r16
    76a2:	ff 90       	pop	r15
    76a4:	ef 90       	pop	r14
    76a6:	08 95       	ret

000076a8 <_bldr_reg_read>:
    76a8:	8a 30       	cpi	r24, 0x0A	; 10
    76aa:	91 05       	cpc	r25, r1
    76ac:	09 f4       	brne	.+2      	; 0x76b0 <_bldr_reg_read+0x8>
    76ae:	e6 c0       	rjmp	.+460    	; 0x787c <_bldr_reg_read+0x1d4>
    76b0:	58 f5       	brcc	.+86     	; 0x7708 <_bldr_reg_read+0x60>
    76b2:	84 30       	cpi	r24, 0x04	; 4
    76b4:	91 05       	cpc	r25, r1
    76b6:	09 f4       	brne	.+2      	; 0x76ba <_bldr_reg_read+0x12>
    76b8:	aa c0       	rjmp	.+340    	; 0x780e <_bldr_reg_read+0x166>
    76ba:	78 f4       	brcc	.+30     	; 0x76da <_bldr_reg_read+0x32>
    76bc:	81 30       	cpi	r24, 0x01	; 1
    76be:	91 05       	cpc	r25, r1
    76c0:	09 f4       	brne	.+2      	; 0x76c4 <_bldr_reg_read+0x1c>
    76c2:	74 c0       	rjmp	.+232    	; 0x77ac <_bldr_reg_read+0x104>
    76c4:	08 f4       	brcc	.+2      	; 0x76c8 <_bldr_reg_read+0x20>
    76c6:	65 c0       	rjmp	.+202    	; 0x7792 <_bldr_reg_read+0xea>
    76c8:	82 30       	cpi	r24, 0x02	; 2
    76ca:	91 05       	cpc	r25, r1
    76cc:	09 f4       	brne	.+2      	; 0x76d0 <_bldr_reg_read+0x28>
    76ce:	7b c0       	rjmp	.+246    	; 0x77c6 <_bldr_reg_read+0x11e>
    76d0:	83 30       	cpi	r24, 0x03	; 3
    76d2:	91 05       	cpc	r25, r1
    76d4:	09 f4       	brne	.+2      	; 0x76d8 <_bldr_reg_read+0x30>
    76d6:	89 c0       	rjmp	.+274    	; 0x77ea <_bldr_reg_read+0x142>
    76d8:	2e c1       	rjmp	.+604    	; 0x7936 <_bldr_reg_read+0x28e>
    76da:	87 30       	cpi	r24, 0x07	; 7
    76dc:	91 05       	cpc	r25, r1
    76de:	09 f4       	brne	.+2      	; 0x76e2 <_bldr_reg_read+0x3a>
    76e0:	ac c0       	rjmp	.+344    	; 0x783a <_bldr_reg_read+0x192>
    76e2:	48 f4       	brcc	.+18     	; 0x76f6 <_bldr_reg_read+0x4e>
    76e4:	85 30       	cpi	r24, 0x05	; 5
    76e6:	91 05       	cpc	r25, r1
    76e8:	09 f4       	brne	.+2      	; 0x76ec <_bldr_reg_read+0x44>
    76ea:	98 c0       	rjmp	.+304    	; 0x781c <_bldr_reg_read+0x174>
    76ec:	86 30       	cpi	r24, 0x06	; 6
    76ee:	91 05       	cpc	r25, r1
    76f0:	09 f4       	brne	.+2      	; 0x76f4 <_bldr_reg_read+0x4c>
    76f2:	9b c0       	rjmp	.+310    	; 0x782a <_bldr_reg_read+0x182>
    76f4:	20 c1       	rjmp	.+576    	; 0x7936 <_bldr_reg_read+0x28e>
    76f6:	88 30       	cpi	r24, 0x08	; 8
    76f8:	91 05       	cpc	r25, r1
    76fa:	09 f4       	brne	.+2      	; 0x76fe <_bldr_reg_read+0x56>
    76fc:	a5 c0       	rjmp	.+330    	; 0x7848 <_bldr_reg_read+0x1a0>
    76fe:	89 30       	cpi	r24, 0x09	; 9
    7700:	91 05       	cpc	r25, r1
    7702:	09 f4       	brne	.+2      	; 0x7706 <_bldr_reg_read+0x5e>
    7704:	aa c0       	rjmp	.+340    	; 0x785a <_bldr_reg_read+0x1b2>
    7706:	17 c1       	rjmp	.+558    	; 0x7936 <_bldr_reg_read+0x28e>
    7708:	84 3d       	cpi	r24, 0xD4	; 212
    770a:	27 e0       	ldi	r18, 0x07	; 7
    770c:	92 07       	cpc	r25, r18
    770e:	09 f4       	brne	.+2      	; 0x7712 <_bldr_reg_read+0x6a>
    7710:	d6 c0       	rjmp	.+428    	; 0x78be <_bldr_reg_read+0x216>
    7712:	b8 f4       	brcc	.+46     	; 0x7742 <_bldr_reg_read+0x9a>
    7714:	81 3d       	cpi	r24, 0xD1	; 209
    7716:	a7 e0       	ldi	r26, 0x07	; 7
    7718:	9a 07       	cpc	r25, r26
    771a:	09 f4       	brne	.+2      	; 0x771e <_bldr_reg_read+0x76>
    771c:	bd c0       	rjmp	.+378    	; 0x7898 <_bldr_reg_read+0x1f0>
    771e:	30 f4       	brcc	.+12     	; 0x772c <_bldr_reg_read+0x84>
    7720:	80 3d       	cpi	r24, 0xD0	; 208
    7722:	e7 e0       	ldi	r30, 0x07	; 7
    7724:	9e 07       	cpc	r25, r30
    7726:	09 f4       	brne	.+2      	; 0x772a <_bldr_reg_read+0x82>
    7728:	b0 c0       	rjmp	.+352    	; 0x788a <_bldr_reg_read+0x1e2>
    772a:	05 c1       	rjmp	.+522    	; 0x7936 <_bldr_reg_read+0x28e>
    772c:	82 3d       	cpi	r24, 0xD2	; 210
    772e:	f7 e0       	ldi	r31, 0x07	; 7
    7730:	9f 07       	cpc	r25, r31
    7732:	09 f4       	brne	.+2      	; 0x7736 <_bldr_reg_read+0x8e>
    7734:	b6 c0       	rjmp	.+364    	; 0x78a2 <_bldr_reg_read+0x1fa>
    7736:	83 3d       	cpi	r24, 0xD3	; 211
    7738:	27 e0       	ldi	r18, 0x07	; 7
    773a:	92 07       	cpc	r25, r18
    773c:	09 f4       	brne	.+2      	; 0x7740 <_bldr_reg_read+0x98>
    773e:	b8 c0       	rjmp	.+368    	; 0x78b0 <_bldr_reg_read+0x208>
    7740:	fa c0       	rjmp	.+500    	; 0x7936 <_bldr_reg_read+0x28e>
    7742:	87 3d       	cpi	r24, 0xD7	; 215
    7744:	47 e0       	ldi	r20, 0x07	; 7
    7746:	94 07       	cpc	r25, r20
    7748:	b9 f0       	breq	.+46     	; 0x7778 <_bldr_reg_read+0xd0>
    774a:	58 f4       	brcc	.+22     	; 0x7762 <_bldr_reg_read+0xba>
    774c:	85 3d       	cpi	r24, 0xD5	; 213
    774e:	b7 e0       	ldi	r27, 0x07	; 7
    7750:	9b 07       	cpc	r25, r27
    7752:	09 f4       	brne	.+2      	; 0x7756 <_bldr_reg_read+0xae>
    7754:	bb c0       	rjmp	.+374    	; 0x78cc <_bldr_reg_read+0x224>
    7756:	86 3d       	cpi	r24, 0xD6	; 214
    7758:	e7 e0       	ldi	r30, 0x07	; 7
    775a:	9e 07       	cpc	r25, r30
    775c:	09 f4       	brne	.+2      	; 0x7760 <_bldr_reg_read+0xb8>
    775e:	bd c0       	rjmp	.+378    	; 0x78da <_bldr_reg_read+0x232>
    7760:	ea c0       	rjmp	.+468    	; 0x7936 <_bldr_reg_read+0x28e>
    7762:	8a 3f       	cpi	r24, 0xFA	; 250
    7764:	f7 e0       	ldi	r31, 0x07	; 7
    7766:	9f 07       	cpc	r25, r31
    7768:	09 f4       	brne	.+2      	; 0x776c <_bldr_reg_read+0xc4>
    776a:	d5 c0       	rjmp	.+426    	; 0x7916 <_bldr_reg_read+0x26e>
    776c:	8b 3f       	cpi	r24, 0xFB	; 251
    776e:	27 e0       	ldi	r18, 0x07	; 7
    7770:	92 07       	cpc	r25, r18
    7772:	09 f4       	brne	.+2      	; 0x7776 <_bldr_reg_read+0xce>
    7774:	d8 c0       	rjmp	.+432    	; 0x7926 <_bldr_reg_read+0x27e>
    7776:	df c0       	rjmp	.+446    	; 0x7936 <_bldr_reg_read+0x28e>
    7778:	89 ee       	ldi	r24, 0xE9	; 233
    777a:	90 e2       	ldi	r25, 0x20	; 32
    777c:	8a 38       	cpi	r24, 0x8A	; 138
    777e:	9e 42       	sbci	r25, 0x2E	; 46
    7780:	08 f0       	brcs	.+2      	; 0x7784 <_bldr_reg_read+0xdc>
    7782:	bd c0       	rjmp	.+378    	; 0x78fe <_bldr_reg_read+0x256>
    7784:	80 91 e9 20 	lds	r24, 0x20E9	; 0x8020e9 <__bss_end>
    7788:	81 11       	cpse	r24, r1
    778a:	bc c0       	rjmp	.+376    	; 0x7904 <_bldr_reg_read+0x25c>
    778c:	e9 ee       	ldi	r30, 0xE9	; 233
    778e:	f0 e2       	ldi	r31, 0x20	; 32
    7790:	b0 c0       	rjmp	.+352    	; 0x78f2 <_bldr_reg_read+0x24a>
    7792:	80 91 8c 2e 	lds	r24, 0x2E8C	; 0x802e8c <__bss_end+0xda3>
    7796:	90 91 8d 2e 	lds	r25, 0x2E8D	; 0x802e8d <__bss_end+0xda4>
    779a:	a0 91 8e 2e 	lds	r26, 0x2E8E	; 0x802e8e <__bss_end+0xda5>
    779e:	b0 91 8f 2e 	lds	r27, 0x2E8F	; 0x802e8f <__bss_end+0xda6>
    77a2:	fb 01       	movw	r30, r22
    77a4:	80 83       	st	Z, r24
    77a6:	91 83       	std	Z+1, r25	; 0x01
    77a8:	80 e0       	ldi	r24, 0x00	; 0
    77aa:	08 95       	ret
    77ac:	80 91 8c 2e 	lds	r24, 0x2E8C	; 0x802e8c <__bss_end+0xda3>
    77b0:	90 91 8d 2e 	lds	r25, 0x2E8D	; 0x802e8d <__bss_end+0xda4>
    77b4:	a0 91 8e 2e 	lds	r26, 0x2E8E	; 0x802e8e <__bss_end+0xda5>
    77b8:	b0 91 8f 2e 	lds	r27, 0x2E8F	; 0x802e8f <__bss_end+0xda6>
    77bc:	fb 01       	movw	r30, r22
    77be:	a0 83       	st	Z, r26
    77c0:	b1 83       	std	Z+1, r27	; 0x01
    77c2:	80 e0       	ldi	r24, 0x00	; 0
    77c4:	08 95       	ret
    77c6:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    77ca:	88 23       	and	r24, r24
    77cc:	e4 f3       	brlt	.-8      	; 0x77c6 <_bldr_reg_read+0x11e>
    77ce:	ec ec       	ldi	r30, 0xCC	; 204
    77d0:	f1 e0       	ldi	r31, 0x01	; 1
    77d2:	80 81       	ld	r24, Z
    77d4:	88 60       	ori	r24, 0x08	; 8
    77d6:	80 83       	st	Z, r24
    77d8:	80 91 05 13 	lds	r24, 0x1305	; 0x801305 <__TEXT_REGION_LENGTH__+0x7f8305>
    77dc:	90 91 06 13 	lds	r25, 0x1306	; 0x801306 <__TEXT_REGION_LENGTH__+0x7f8306>
    77e0:	db 01       	movw	r26, r22
    77e2:	8d 93       	st	X+, r24
    77e4:	9c 93       	st	X, r25
    77e6:	80 e0       	ldi	r24, 0x00	; 0
    77e8:	08 95       	ret
    77ea:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    77ee:	88 23       	and	r24, r24
    77f0:	e4 f3       	brlt	.-8      	; 0x77ea <_bldr_reg_read+0x142>
    77f2:	ec ec       	ldi	r30, 0xCC	; 204
    77f4:	f1 e0       	ldi	r31, 0x01	; 1
    77f6:	80 81       	ld	r24, Z
    77f8:	88 60       	ori	r24, 0x08	; 8
    77fa:	80 83       	st	Z, r24
    77fc:	80 91 07 13 	lds	r24, 0x1307	; 0x801307 <__TEXT_REGION_LENGTH__+0x7f8307>
    7800:	90 91 08 13 	lds	r25, 0x1308	; 0x801308 <__TEXT_REGION_LENGTH__+0x7f8308>
    7804:	fb 01       	movw	r30, r22
    7806:	80 83       	st	Z, r24
    7808:	91 83       	std	Z+1, r25	; 0x01
    780a:	80 e0       	ldi	r24, 0x00	; 0
    780c:	08 95       	ret
    780e:	84 e0       	ldi	r24, 0x04	; 4
    7810:	90 e0       	ldi	r25, 0x00	; 0
    7812:	db 01       	movw	r26, r22
    7814:	8d 93       	st	X+, r24
    7816:	9c 93       	st	X, r25
    7818:	80 e0       	ldi	r24, 0x00	; 0
    781a:	08 95       	ret
    781c:	81 e0       	ldi	r24, 0x01	; 1
    781e:	91 e0       	ldi	r25, 0x01	; 1
    7820:	fb 01       	movw	r30, r22
    7822:	80 83       	st	Z, r24
    7824:	91 83       	std	Z+1, r25	; 0x01
    7826:	80 e0       	ldi	r24, 0x00	; 0
    7828:	08 95       	ret
    782a:	80 91 8b 2e 	lds	r24, 0x2E8B	; 0x802e8b <__bss_end+0xda2>
    782e:	90 e0       	ldi	r25, 0x00	; 0
    7830:	db 01       	movw	r26, r22
    7832:	8d 93       	st	X+, r24
    7834:	9c 93       	st	X, r25
    7836:	80 e0       	ldi	r24, 0x00	; 0
    7838:	08 95       	ret
    783a:	80 b1       	in	r24, 0x00	; 0
    783c:	90 e0       	ldi	r25, 0x00	; 0
    783e:	fb 01       	movw	r30, r22
    7840:	80 83       	st	Z, r24
    7842:	91 83       	std	Z+1, r25	; 0x01
    7844:	80 e0       	ldi	r24, 0x00	; 0
    7846:	08 95       	ret
    7848:	91 b1       	in	r25, 0x01	; 1
    784a:	82 b1       	in	r24, 0x02	; 2
    784c:	89 2b       	or	r24, r25
    784e:	90 e0       	ldi	r25, 0x00	; 0
    7850:	db 01       	movw	r26, r22
    7852:	8d 93       	st	X+, r24
    7854:	9c 93       	st	X, r25
    7856:	80 e0       	ldi	r24, 0x00	; 0
    7858:	08 95       	ret
    785a:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    785e:	88 23       	and	r24, r24
    7860:	e4 f3       	brlt	.-8      	; 0x785a <_bldr_reg_read+0x1b2>
    7862:	ec ec       	ldi	r30, 0xCC	; 204
    7864:	f1 e0       	ldi	r31, 0x01	; 1
    7866:	80 81       	ld	r24, Z
    7868:	88 60       	ori	r24, 0x08	; 8
    786a:	80 83       	st	Z, r24
    786c:	80 91 00 13 	lds	r24, 0x1300	; 0x801300 <__TEXT_REGION_LENGTH__+0x7f8300>
    7870:	90 e0       	ldi	r25, 0x00	; 0
    7872:	fb 01       	movw	r30, r22
    7874:	80 83       	st	Z, r24
    7876:	91 83       	std	Z+1, r25	; 0x01
    7878:	80 e0       	ldi	r24, 0x00	; 0
    787a:	08 95       	ret
    787c:	83 e0       	ldi	r24, 0x03	; 3
    787e:	90 e0       	ldi	r25, 0x00	; 0
    7880:	db 01       	movw	r26, r22
    7882:	8d 93       	st	X+, r24
    7884:	9c 93       	st	X, r25
    7886:	80 e0       	ldi	r24, 0x00	; 0
    7888:	08 95       	ret
    788a:	8b e8       	ldi	r24, 0x8B	; 139
    788c:	9e e0       	ldi	r25, 0x0E	; 14
    788e:	fb 01       	movw	r30, r22
    7890:	80 83       	st	Z, r24
    7892:	91 83       	std	Z+1, r25	; 0x01
    7894:	80 e0       	ldi	r24, 0x00	; 0
    7896:	08 95       	ret
    7898:	db 01       	movw	r26, r22
    789a:	1d 92       	st	X+, r1
    789c:	1c 92       	st	X, r1
    789e:	80 e0       	ldi	r24, 0x00	; 0
    78a0:	08 95       	ret
    78a2:	87 ea       	ldi	r24, 0xA7	; 167
    78a4:	9e e0       	ldi	r25, 0x0E	; 14
    78a6:	fb 01       	movw	r30, r22
    78a8:	80 83       	st	Z, r24
    78aa:	91 83       	std	Z+1, r25	; 0x01
    78ac:	80 e0       	ldi	r24, 0x00	; 0
    78ae:	08 95       	ret
    78b0:	80 e0       	ldi	r24, 0x00	; 0
    78b2:	93 e0       	ldi	r25, 0x03	; 3
    78b4:	db 01       	movw	r26, r22
    78b6:	8d 93       	st	X+, r24
    78b8:	9c 93       	st	X, r25
    78ba:	80 e0       	ldi	r24, 0x00	; 0
    78bc:	08 95       	ret
    78be:	80 e0       	ldi	r24, 0x00	; 0
    78c0:	90 e1       	ldi	r25, 0x10	; 16
    78c2:	fb 01       	movw	r30, r22
    78c4:	80 83       	st	Z, r24
    78c6:	91 83       	std	Z+1, r25	; 0x01
    78c8:	80 e0       	ldi	r24, 0x00	; 0
    78ca:	08 95       	ret
    78cc:	80 e0       	ldi	r24, 0x00	; 0
    78ce:	94 e0       	ldi	r25, 0x04	; 4
    78d0:	db 01       	movw	r26, r22
    78d2:	8d 93       	st	X+, r24
    78d4:	9c 93       	st	X, r25
    78d6:	80 e0       	ldi	r24, 0x00	; 0
    78d8:	08 95       	ret
    78da:	8a e8       	ldi	r24, 0x8A	; 138
    78dc:	9e e2       	ldi	r25, 0x2E	; 46
    78de:	89 5e       	subi	r24, 0xE9	; 233
    78e0:	90 42       	sbci	r25, 0x20	; 32
    78e2:	fb 01       	movw	r30, r22
    78e4:	80 83       	st	Z, r24
    78e6:	91 83       	std	Z+1, r25	; 0x01
    78e8:	80 e0       	ldi	r24, 0x00	; 0
    78ea:	08 95       	ret
    78ec:	80 81       	ld	r24, Z
    78ee:	81 11       	cpse	r24, r1
    78f0:	0b c0       	rjmp	.+22     	; 0x7908 <_bldr_reg_read+0x260>
    78f2:	31 96       	adiw	r30, 0x01	; 1
    78f4:	ea 38       	cpi	r30, 0x8A	; 138
    78f6:	2e e2       	ldi	r18, 0x2E	; 46
    78f8:	f2 07       	cpc	r31, r18
    78fa:	c0 f3       	brcs	.-16     	; 0x78ec <_bldr_reg_read+0x244>
    78fc:	05 c0       	rjmp	.+10     	; 0x7908 <_bldr_reg_read+0x260>
    78fe:	e9 ee       	ldi	r30, 0xE9	; 233
    7900:	f0 e2       	ldi	r31, 0x20	; 32
    7902:	02 c0       	rjmp	.+4      	; 0x7908 <_bldr_reg_read+0x260>
    7904:	e9 ee       	ldi	r30, 0xE9	; 233
    7906:	f0 e2       	ldi	r31, 0x20	; 32
    7908:	e9 5e       	subi	r30, 0xE9	; 233
    790a:	f0 42       	sbci	r31, 0x20	; 32
    790c:	db 01       	movw	r26, r22
    790e:	ed 93       	st	X+, r30
    7910:	fc 93       	st	X, r31
    7912:	80 e0       	ldi	r24, 0x00	; 0
    7914:	08 95       	ret
    7916:	80 91 a7 2e 	lds	r24, 0x2EA7	; 0x802ea7 <__bss_end+0xdbe>
    791a:	90 e0       	ldi	r25, 0x00	; 0
    791c:	fb 01       	movw	r30, r22
    791e:	80 83       	st	Z, r24
    7920:	91 83       	std	Z+1, r25	; 0x01
    7922:	80 e0       	ldi	r24, 0x00	; 0
    7924:	08 95       	ret
    7926:	80 91 a8 2e 	lds	r24, 0x2EA8	; 0x802ea8 <__bss_end+0xdbf>
    792a:	90 e0       	ldi	r25, 0x00	; 0
    792c:	db 01       	movw	r26, r22
    792e:	8d 93       	st	X+, r24
    7930:	9c 93       	st	X, r25
    7932:	80 e0       	ldi	r24, 0x00	; 0
    7934:	08 95       	ret
    7936:	9c 01       	movw	r18, r24
    7938:	2a 5d       	subi	r18, 0xDA	; 218
    793a:	37 40       	sbci	r19, 0x07	; 7
    793c:	20 32       	cpi	r18, 0x20	; 32
    793e:	31 05       	cpc	r19, r1
    7940:	a0 f4       	brcc	.+40     	; 0x796a <_bldr_reg_read+0x2c2>
    7942:	23 31       	cpi	r18, 0x13	; 19
    7944:	31 05       	cpc	r19, r1
    7946:	60 f4       	brcc	.+24     	; 0x7960 <_bldr_reg_read+0x2b8>
    7948:	88 0f       	add	r24, r24
    794a:	99 1f       	adc	r25, r25
    794c:	fc 01       	movw	r30, r24
    794e:	ec 5d       	subi	r30, 0xDC	; 220
    7950:	ff 4d       	sbci	r31, 0xDF	; 223
    7952:	80 81       	ld	r24, Z
    7954:	91 81       	ldd	r25, Z+1	; 0x01
    7956:	fb 01       	movw	r30, r22
    7958:	80 83       	st	Z, r24
    795a:	91 83       	std	Z+1, r25	; 0x01
    795c:	80 e0       	ldi	r24, 0x00	; 0
    795e:	08 95       	ret
    7960:	db 01       	movw	r26, r22
    7962:	1d 92       	st	X+, r1
    7964:	1c 92       	st	X, r1
    7966:	80 e0       	ldi	r24, 0x00	; 0
    7968:	08 95       	ret
    796a:	9c 01       	movw	r18, r24
    796c:	38 50       	subi	r19, 0x08	; 8
    796e:	21 15       	cp	r18, r1
    7970:	38 40       	sbci	r19, 0x08	; 8
    7972:	c8 f4       	brcc	.+50     	; 0x79a6 <_bldr_reg_read+0x2fe>
    7974:	98 58       	subi	r25, 0x88	; 136
    7976:	88 0f       	add	r24, r24
    7978:	99 1f       	adc	r25, r25
    797a:	81 15       	cp	r24, r1
    797c:	e4 e0       	ldi	r30, 0x04	; 4
    797e:	9e 07       	cpc	r25, r30
    7980:	38 f5       	brcc	.+78     	; 0x79d0 <_bldr_reg_read+0x328>
    7982:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    7986:	22 23       	and	r18, r18
    7988:	e4 f3       	brlt	.-8      	; 0x7982 <_bldr_reg_read+0x2da>
    798a:	ec ec       	ldi	r30, 0xCC	; 204
    798c:	f1 e0       	ldi	r31, 0x01	; 1
    798e:	20 81       	ld	r18, Z
    7990:	28 60       	ori	r18, 0x08	; 8
    7992:	20 83       	st	Z, r18
    7994:	fc 01       	movw	r30, r24
    7996:	f0 5f       	subi	r31, 0xF0	; 240
    7998:	80 81       	ld	r24, Z
    799a:	91 81       	ldd	r25, Z+1	; 0x01
    799c:	db 01       	movw	r26, r22
    799e:	8d 93       	st	X+, r24
    79a0:	9c 93       	st	X, r25
    79a2:	80 e0       	ldi	r24, 0x00	; 0
    79a4:	08 95       	ret
    79a6:	9c 01       	movw	r18, r24
    79a8:	30 51       	subi	r19, 0x10	; 16
    79aa:	21 15       	cp	r18, r1
    79ac:	30 41       	sbci	r19, 0x10	; 16
    79ae:	90 f4       	brcc	.+36     	; 0x79d4 <_bldr_reg_read+0x32c>
    79b0:	90 59       	subi	r25, 0x90	; 144
    79b2:	88 0f       	add	r24, r24
    79b4:	99 1f       	adc	r25, r25
    79b6:	81 15       	cp	r24, r1
    79b8:	e0 e1       	ldi	r30, 0x10	; 16
    79ba:	9e 07       	cpc	r25, r30
    79bc:	68 f4       	brcc	.+26     	; 0x79d8 <_bldr_reg_read+0x330>
    79be:	fc 01       	movw	r30, r24
    79c0:	f0 5e       	subi	r31, 0xE0	; 224
    79c2:	80 81       	ld	r24, Z
    79c4:	91 81       	ldd	r25, Z+1	; 0x01
    79c6:	db 01       	movw	r26, r22
    79c8:	8d 93       	st	X+, r24
    79ca:	9c 93       	st	X, r25
    79cc:	80 e0       	ldi	r24, 0x00	; 0
    79ce:	08 95       	ret
    79d0:	84 e0       	ldi	r24, 0x04	; 4
    79d2:	08 95       	ret
    79d4:	84 e0       	ldi	r24, 0x04	; 4
    79d6:	08 95       	ret
    79d8:	84 e0       	ldi	r24, 0x04	; 4
    79da:	08 95       	ret

000079dc <_bldr_task>:
    79dc:	cf 92       	push	r12
    79de:	df 92       	push	r13
    79e0:	ef 92       	push	r14
    79e2:	ff 92       	push	r15
    79e4:	0f 93       	push	r16
    79e6:	1f 93       	push	r17
    79e8:	cf 93       	push	r28
    79ea:	df 93       	push	r29
    79ec:	1f 92       	push	r1
    79ee:	cd b7       	in	r28, 0x3d	; 61
    79f0:	de b7       	in	r29, 0x3e	; 62
    79f2:	8c 01       	movw	r16, r24
    79f4:	80 91 94 2e 	lds	r24, 0x2E94	; 0x802e94 <__bss_end+0xdab>
    79f8:	81 11       	cpse	r24, r1
    79fa:	23 c0       	rjmp	.+70     	; 0x7a42 <_bldr_task+0x66>
    79fc:	80 91 80 06 	lds	r24, 0x0680	; 0x800680 <__TEXT_REGION_LENGTH__+0x7f7680>
    7a00:	81 fd       	sbrc	r24, 1
    7a02:	19 c0       	rjmp	.+50     	; 0x7a36 <_bldr_task+0x5a>
    7a04:	8a e0       	ldi	r24, 0x0A	; 10
    7a06:	80 93 94 2e 	sts	0x2E94, r24	; 0x802e94 <__bss_end+0xdab>
    7a0a:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x7f7688>
    7a0e:	91 e0       	ldi	r25, 0x01	; 1
    7a10:	81 fd       	sbrc	r24, 1
    7a12:	90 e0       	ldi	r25, 0x00	; 0
    7a14:	82 e0       	ldi	r24, 0x02	; 2
    7a16:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x7f7681>
    7a1a:	e9 e9       	ldi	r30, 0x99	; 153
    7a1c:	fe e2       	ldi	r31, 0x2E	; 46
    7a1e:	80 81       	ld	r24, Z
    7a20:	89 27       	eor	r24, r25
    7a22:	a8 e9       	ldi	r26, 0x98	; 152
    7a24:	be e2       	ldi	r27, 0x2E	; 46
    7a26:	2c 91       	ld	r18, X
    7a28:	28 23       	and	r18, r24
    7a2a:	80 95       	com	r24
    7a2c:	89 23       	and	r24, r25
    7a2e:	82 2b       	or	r24, r18
    7a30:	8c 93       	st	X, r24
    7a32:	90 83       	st	Z, r25
    7a34:	06 c0       	rjmp	.+12     	; 0x7a42 <_bldr_task+0x66>
    7a36:	81 e0       	ldi	r24, 0x01	; 1
    7a38:	80 93 94 2e 	sts	0x2E94, r24	; 0x802e94 <__bss_end+0xdab>
    7a3c:	82 e0       	ldi	r24, 0x02	; 2
    7a3e:	80 93 82 06 	sts	0x0682, r24	; 0x800682 <__TEXT_REGION_LENGTH__+0x7f7682>
    7a42:	80 91 93 2e 	lds	r24, 0x2E93	; 0x802e93 <__bss_end+0xdaa>
    7a46:	81 11       	cpse	r24, r1
    7a48:	7f c0       	rjmp	.+254    	; 0x7b48 <_bldr_task+0x16c>
    7a4a:	80 e2       	ldi	r24, 0x20	; 32
    7a4c:	80 93 93 2e 	sts	0x2E93, r24	; 0x802e93 <__bss_end+0xdaa>
    7a50:	80 91 98 2e 	lds	r24, 0x2E98	; 0x802e98 <__bss_end+0xdaf>
    7a54:	80 ff       	sbrs	r24, 0
    7a56:	11 c0       	rjmp	.+34     	; 0x7a7a <_bldr_task+0x9e>
    7a58:	80 91 9a 2e 	lds	r24, 0x2E9A	; 0x802e9a <__bss_end+0xdb1>
    7a5c:	80 fd       	sbrc	r24, 0
    7a5e:	12 c0       	rjmp	.+36     	; 0x7a84 <_bldr_task+0xa8>
    7a60:	eb e8       	ldi	r30, 0x8B	; 139
    7a62:	fe e2       	ldi	r31, 0x2E	; 46
    7a64:	87 85       	ldd	r24, Z+15	; 0x0f
    7a66:	81 60       	ori	r24, 0x01	; 1
    7a68:	87 87       	std	Z+15, r24	; 0x0f
    7a6a:	9f b7       	in	r25, 0x3f	; 63
    7a6c:	f8 94       	cli
    7a6e:	20 b1       	in	r18, 0x00	; 0
    7a70:	80 e1       	ldi	r24, 0x10	; 16
    7a72:	82 27       	eor	r24, r18
    7a74:	80 b9       	out	0x00, r24	; 0
    7a76:	9f bf       	out	0x3f, r25	; 63
    7a78:	05 c0       	rjmp	.+10     	; 0x7a84 <_bldr_task+0xa8>
    7a7a:	eb e8       	ldi	r30, 0x8B	; 139
    7a7c:	fe e2       	ldi	r31, 0x2E	; 46
    7a7e:	87 85       	ldd	r24, Z+15	; 0x0f
    7a80:	8e 7f       	andi	r24, 0xFE	; 254
    7a82:	87 87       	std	Z+15, r24	; 0x0f
    7a84:	80 b1       	in	r24, 0x00	; 0
    7a86:	89 83       	std	Y+1, r24	; 0x01
    7a88:	90 91 97 2e 	lds	r25, 0x2E97	; 0x802e97 <__bss_end+0xdae>
    7a8c:	89 17       	cp	r24, r25
    7a8e:	a9 f1       	breq	.+106    	; 0x7afa <_bldr_task+0x11e>
    7a90:	80 93 97 2e 	sts	0x2E97, r24	; 0x802e97 <__bss_end+0xdae>
    7a94:	89 81       	ldd	r24, Y+1	; 0x01
    7a96:	84 ff       	sbrs	r24, 4
    7a98:	07 c0       	rjmp	.+14     	; 0x7aa8 <_bldr_task+0xcc>
    7a9a:	eb e8       	ldi	r30, 0x8B	; 139
    7a9c:	fe e2       	ldi	r31, 0x2E	; 46
    7a9e:	8a ea       	ldi	r24, 0xAA	; 170
    7aa0:	82 87       	std	Z+10, r24	; 0x0a
    7aa2:	85 e5       	ldi	r24, 0x55	; 85
    7aa4:	83 87       	std	Z+11, r24	; 0x0b
    7aa6:	20 c0       	rjmp	.+64     	; 0x7ae8 <_bldr_task+0x10c>
    7aa8:	89 81       	ldd	r24, Y+1	; 0x01
    7aaa:	83 ff       	sbrs	r24, 3
    7aac:	06 c0       	rjmp	.+12     	; 0x7aba <_bldr_task+0xde>
    7aae:	eb e8       	ldi	r30, 0x8B	; 139
    7ab0:	fe e2       	ldi	r31, 0x2E	; 46
    7ab2:	12 86       	std	Z+10, r1	; 0x0a
    7ab4:	81 e0       	ldi	r24, 0x01	; 1
    7ab6:	83 87       	std	Z+11, r24	; 0x0b
    7ab8:	17 c0       	rjmp	.+46     	; 0x7ae8 <_bldr_task+0x10c>
    7aba:	89 81       	ldd	r24, Y+1	; 0x01
    7abc:	86 ff       	sbrs	r24, 6
    7abe:	06 c0       	rjmp	.+12     	; 0x7acc <_bldr_task+0xf0>
    7ac0:	eb e8       	ldi	r30, 0x8B	; 139
    7ac2:	fe e2       	ldi	r31, 0x2E	; 46
    7ac4:	8a ea       	ldi	r24, 0xAA	; 170
    7ac6:	82 87       	std	Z+10, r24	; 0x0a
    7ac8:	13 86       	std	Z+11, r1	; 0x0b
    7aca:	0e c0       	rjmp	.+28     	; 0x7ae8 <_bldr_task+0x10c>
    7acc:	89 81       	ldd	r24, Y+1	; 0x01
    7ace:	80 ff       	sbrs	r24, 0
    7ad0:	06 c0       	rjmp	.+12     	; 0x7ade <_bldr_task+0x102>
    7ad2:	eb e8       	ldi	r30, 0x8B	; 139
    7ad4:	fe e2       	ldi	r31, 0x2E	; 46
    7ad6:	8e e3       	ldi	r24, 0x3E	; 62
    7ad8:	82 87       	std	Z+10, r24	; 0x0a
    7ada:	13 86       	std	Z+11, r1	; 0x0b
    7adc:	05 c0       	rjmp	.+10     	; 0x7ae8 <_bldr_task+0x10c>
    7ade:	eb e8       	ldi	r30, 0x8B	; 139
    7ae0:	fe e2       	ldi	r31, 0x2E	; 46
    7ae2:	88 e1       	ldi	r24, 0x18	; 24
    7ae4:	82 87       	std	Z+10, r24	; 0x0a
    7ae6:	13 86       	std	Z+11, r1	; 0x0b
    7ae8:	89 81       	ldd	r24, Y+1	; 0x01
    7aea:	85 ff       	sbrs	r24, 5
    7aec:	06 c0       	rjmp	.+12     	; 0x7afa <_bldr_task+0x11e>
    7aee:	89 81       	ldd	r24, Y+1	; 0x01
    7af0:	83 fd       	sbrc	r24, 3
    7af2:	03 c0       	rjmp	.+6      	; 0x7afa <_bldr_task+0x11e>
    7af4:	87 e0       	ldi	r24, 0x07	; 7
    7af6:	80 93 95 2e 	sts	0x2E95, r24	; 0x802e95 <__bss_end+0xdac>
    7afa:	81 b1       	in	r24, 0x01	; 1
    7afc:	81 11       	cpse	r24, r1
    7afe:	03 c0       	rjmp	.+6      	; 0x7b06 <_bldr_task+0x12a>
    7b00:	82 b1       	in	r24, 0x02	; 2
    7b02:	88 23       	and	r24, r24
    7b04:	19 f0       	breq	.+6      	; 0x7b0c <_bldr_task+0x130>
    7b06:	8f ef       	ldi	r24, 0xFF	; 255
    7b08:	80 93 96 2e 	sts	0x2E96, r24	; 0x802e96 <__bss_end+0xdad>
    7b0c:	eb e8       	ldi	r30, 0x8B	; 139
    7b0e:	fe e2       	ldi	r31, 0x2E	; 46
    7b10:	82 85       	ldd	r24, Z+10	; 0x0a
    7b12:	88 0f       	add	r24, r24
    7b14:	81 1d       	adc	r24, r1
    7b16:	82 87       	std	Z+10, r24	; 0x0a
    7b18:	88 23       	and	r24, r24
    7b1a:	24 f4       	brge	.+8      	; 0x7b24 <_bldr_task+0x148>
    7b1c:	81 e0       	ldi	r24, 0x01	; 1
    7b1e:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x7f7686>
    7b22:	03 c0       	rjmp	.+6      	; 0x7b2a <_bldr_task+0x14e>
    7b24:	81 e0       	ldi	r24, 0x01	; 1
    7b26:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x7f7685>
    7b2a:	eb e8       	ldi	r30, 0x8B	; 139
    7b2c:	fe e2       	ldi	r31, 0x2E	; 46
    7b2e:	83 85       	ldd	r24, Z+11	; 0x0b
    7b30:	88 0f       	add	r24, r24
    7b32:	81 1d       	adc	r24, r1
    7b34:	83 87       	std	Z+11, r24	; 0x0b
    7b36:	88 23       	and	r24, r24
    7b38:	24 f4       	brge	.+8      	; 0x7b42 <_bldr_task+0x166>
    7b3a:	82 e0       	ldi	r24, 0x02	; 2
    7b3c:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x7f7686>
    7b40:	03 c0       	rjmp	.+6      	; 0x7b48 <_bldr_task+0x16c>
    7b42:	82 e0       	ldi	r24, 0x02	; 2
    7b44:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x7f7685>
    7b48:	06 9b       	sbis	0x00, 6	; 0
    7b4a:	0a c0       	rjmp	.+20     	; 0x7b60 <_bldr_task+0x184>
    7b4c:	0e 94 00 38 	call	0x7000	; 0x7000 <sboxnet_all_sent>
    7b50:	88 23       	and	r24, r24
    7b52:	e1 f3       	breq	.-8      	; 0x7b4c <_bldr_task+0x170>
    7b54:	88 ed       	ldi	r24, 0xD8	; 216
    7b56:	84 bf       	out	0x34, r24	; 52
    7b58:	81 e0       	ldi	r24, 0x01	; 1
    7b5a:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f7079>
    7b5e:	ff cf       	rjmp	.-2      	; 0x7b5e <_bldr_task+0x182>
    7b60:	90 b1       	in	r25, 0x00	; 0
    7b62:	89 2f       	mov	r24, r25
    7b64:	88 70       	andi	r24, 0x08	; 8
    7b66:	93 ff       	sbrs	r25, 3
    7b68:	a0 c0       	rjmp	.+320    	; 0x7caa <_bldr_task+0x2ce>
    7b6a:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    7b6e:	88 23       	and	r24, r24
    7b70:	e4 f3       	brlt	.-8      	; 0x7b6a <_bldr_task+0x18e>
    7b72:	ec ec       	ldi	r30, 0xCC	; 204
    7b74:	f1 e0       	ldi	r31, 0x01	; 1
    7b76:	80 81       	ld	r24, Z
    7b78:	88 60       	ori	r24, 0x08	; 8
    7b7a:	80 83       	st	Z, r24
    7b7c:	c0 90 05 13 	lds	r12, 0x1305	; 0x801305 <__TEXT_REGION_LENGTH__+0x7f8305>
    7b80:	d0 90 06 13 	lds	r13, 0x1306	; 0x801306 <__TEXT_REGION_LENGTH__+0x7f8306>
    7b84:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    7b88:	88 23       	and	r24, r24
    7b8a:	e4 f3       	brlt	.-8      	; 0x7b84 <_bldr_task+0x1a8>
    7b8c:	ec ec       	ldi	r30, 0xCC	; 204
    7b8e:	f1 e0       	ldi	r31, 0x01	; 1
    7b90:	80 81       	ld	r24, Z
    7b92:	88 60       	ori	r24, 0x08	; 8
    7b94:	80 83       	st	Z, r24
    7b96:	e0 90 07 13 	lds	r14, 0x1307	; 0x801307 <__TEXT_REGION_LENGTH__+0x7f8307>
    7b9a:	f0 90 08 13 	lds	r15, 0x1308	; 0x801308 <__TEXT_REGION_LENGTH__+0x7f8308>
    7b9e:	65 e4       	ldi	r22, 0x45	; 69
    7ba0:	c8 01       	movw	r24, r16
    7ba2:	0e 94 da 44 	call	0x89b4	; 0x89b4 <sboxnet_receive_msg>
    7ba6:	18 16       	cp	r1, r24
    7ba8:	0c f0       	brlt	.+2      	; 0x7bac <_bldr_task+0x1d0>
    7baa:	4b c0       	rjmp	.+150    	; 0x7c42 <_bldr_task+0x266>
    7bac:	f8 01       	movw	r30, r16
    7bae:	81 81       	ldd	r24, Z+1	; 0x01
    7bb0:	81 11       	cpse	r24, r1
    7bb2:	47 c0       	rjmp	.+142    	; 0x7c42 <_bldr_task+0x266>
    7bb4:	80 91 92 2e 	lds	r24, 0x2E92	; 0x802e92 <__bss_end+0xda9>
    7bb8:	81 11       	cpse	r24, r1
    7bba:	06 c0       	rjmp	.+12     	; 0x7bc8 <_bldr_task+0x1ec>
    7bbc:	0e 94 9d 41 	call	0x833a	; 0x833a <bldr_random>
    7bc0:	8f 71       	andi	r24, 0x1F	; 31
    7bc2:	8f 5f       	subi	r24, 0xFF	; 255
    7bc4:	80 93 91 2e 	sts	0x2E91, r24	; 0x802e91 <__bss_end+0xda8>
    7bc8:	80 e8       	ldi	r24, 0x80	; 128
    7bca:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <__bss_end+0xda9>
    7bce:	f8 01       	movw	r30, r16
    7bd0:	81 81       	ldd	r24, Z+1	; 0x01
    7bd2:	81 11       	cpse	r24, r1
    7bd4:	36 c0       	rjmp	.+108    	; 0x7c42 <_bldr_task+0x266>
    7bd6:	80 81       	ld	r24, Z
    7bd8:	8f 3f       	cpi	r24, 0xFF	; 255
    7bda:	99 f5       	brne	.+102    	; 0x7c42 <_bldr_task+0x266>
    7bdc:	84 81       	ldd	r24, Z+4	; 0x04
    7bde:	81 31       	cpi	r24, 0x11	; 17
    7be0:	81 f5       	brne	.+96     	; 0x7c42 <_bldr_task+0x266>
    7be2:	83 81       	ldd	r24, Z+3	; 0x03
    7be4:	8f 73       	andi	r24, 0x3F	; 63
    7be6:	89 30       	cpi	r24, 0x09	; 9
    7be8:	61 f5       	brne	.+88     	; 0x7c42 <_bldr_task+0x266>
    7bea:	45 81       	ldd	r20, Z+5	; 0x05
    7bec:	56 81       	ldd	r21, Z+6	; 0x06
    7bee:	67 81       	ldd	r22, Z+7	; 0x07
    7bf0:	70 85       	ldd	r23, Z+8	; 0x08
    7bf2:	80 91 8c 2e 	lds	r24, 0x2E8C	; 0x802e8c <__bss_end+0xda3>
    7bf6:	90 91 8d 2e 	lds	r25, 0x2E8D	; 0x802e8d <__bss_end+0xda4>
    7bfa:	a0 91 8e 2e 	lds	r26, 0x2E8E	; 0x802e8e <__bss_end+0xda5>
    7bfe:	b0 91 8f 2e 	lds	r27, 0x2E8F	; 0x802e8f <__bss_end+0xda6>
    7c02:	48 17       	cp	r20, r24
    7c04:	59 07       	cpc	r21, r25
    7c06:	6a 07       	cpc	r22, r26
    7c08:	7b 07       	cpc	r23, r27
    7c0a:	d9 f4       	brne	.+54     	; 0x7c42 <_bldr_task+0x266>
    7c0c:	81 85       	ldd	r24, Z+9	; 0x09
    7c0e:	92 85       	ldd	r25, Z+10	; 0x0a
    7c10:	c8 16       	cp	r12, r24
    7c12:	d9 06       	cpc	r13, r25
    7c14:	b1 f4       	brne	.+44     	; 0x7c42 <_bldr_task+0x266>
    7c16:	83 85       	ldd	r24, Z+11	; 0x0b
    7c18:	94 85       	ldd	r25, Z+12	; 0x0c
    7c1a:	e8 16       	cp	r14, r24
    7c1c:	f9 06       	cpc	r15, r25
    7c1e:	89 f4       	brne	.+34     	; 0x7c42 <_bldr_task+0x266>
    7c20:	85 85       	ldd	r24, Z+13	; 0x0d
    7c22:	80 93 8b 2e 	sts	0x2E8B, r24	; 0x802e8b <__bss_end+0xda2>
    7c26:	10 82       	st	Z, r1
    7c28:	84 81       	ldd	r24, Z+4	; 0x04
    7c2a:	80 68       	ori	r24, 0x80	; 128
    7c2c:	84 83       	std	Z+4, r24	; 0x04
    7c2e:	12 82       	std	Z+2, r1	; 0x02
    7c30:	83 81       	ldd	r24, Z+3	; 0x03
    7c32:	80 7c       	andi	r24, 0xC0	; 192
    7c34:	83 83       	std	Z+3, r24	; 0x03
    7c36:	c8 01       	movw	r24, r16
    7c38:	0e 94 71 45 	call	0x8ae2	; 0x8ae2 <sboxnet_send_msg>
    7c3c:	03 98       	cbi	0x00, 3	; 0
    7c3e:	81 e0       	ldi	r24, 0x01	; 1
    7c40:	34 c0       	rjmp	.+104    	; 0x7caa <_bldr_task+0x2ce>
    7c42:	80 91 92 2e 	lds	r24, 0x2E92	; 0x802e92 <__bss_end+0xda9>
    7c46:	88 23       	and	r24, r24
    7c48:	59 f1       	breq	.+86     	; 0x7ca0 <_bldr_task+0x2c4>
    7c4a:	80 91 91 2e 	lds	r24, 0x2E91	; 0x802e91 <__bss_end+0xda8>
    7c4e:	81 11       	cpse	r24, r1
    7c50:	29 c0       	rjmp	.+82     	; 0x7ca4 <_bldr_task+0x2c8>
    7c52:	f8 01       	movw	r30, r16
    7c54:	10 82       	st	Z, r1
    7c56:	12 82       	std	Z+2, r1	; 0x02
    7c58:	83 81       	ldd	r24, Z+3	; 0x03
    7c5a:	80 7c       	andi	r24, 0xC0	; 192
    7c5c:	88 60       	ori	r24, 0x08	; 8
    7c5e:	83 83       	std	Z+3, r24	; 0x03
    7c60:	80 e1       	ldi	r24, 0x10	; 16
    7c62:	84 83       	std	Z+4, r24	; 0x04
    7c64:	c8 01       	movw	r24, r16
    7c66:	0e 94 e9 39 	call	0x73d2	; 0x73d2 <sboxnet_can_send_msg>
    7c6a:	88 23       	and	r24, r24
    7c6c:	e9 f0       	breq	.+58     	; 0x7ca8 <_bldr_task+0x2cc>
    7c6e:	0e 94 9d 41 	call	0x833a	; 0x833a <bldr_random>
    7c72:	8f 71       	andi	r24, 0x1F	; 31
    7c74:	86 5f       	subi	r24, 0xF6	; 246
    7c76:	eb e8       	ldi	r30, 0x8B	; 139
    7c78:	fe e2       	ldi	r31, 0x2E	; 46
    7c7a:	86 83       	std	Z+6, r24	; 0x06
    7c7c:	81 81       	ldd	r24, Z+1	; 0x01
    7c7e:	92 81       	ldd	r25, Z+2	; 0x02
    7c80:	a3 81       	ldd	r26, Z+3	; 0x03
    7c82:	b4 81       	ldd	r27, Z+4	; 0x04
    7c84:	f8 01       	movw	r30, r16
    7c86:	85 83       	std	Z+5, r24	; 0x05
    7c88:	96 83       	std	Z+6, r25	; 0x06
    7c8a:	a7 83       	std	Z+7, r26	; 0x07
    7c8c:	b0 87       	std	Z+8, r27	; 0x08
    7c8e:	c1 86       	std	Z+9, r12	; 0x09
    7c90:	d2 86       	std	Z+10, r13	; 0x0a
    7c92:	e3 86       	std	Z+11, r14	; 0x0b
    7c94:	f4 86       	std	Z+12, r15	; 0x0c
    7c96:	c8 01       	movw	r24, r16
    7c98:	0e 94 71 45 	call	0x8ae2	; 0x8ae2 <sboxnet_send_msg>
    7c9c:	81 e0       	ldi	r24, 0x01	; 1
    7c9e:	05 c0       	rjmp	.+10     	; 0x7caa <_bldr_task+0x2ce>
    7ca0:	81 e0       	ldi	r24, 0x01	; 1
    7ca2:	03 c0       	rjmp	.+6      	; 0x7caa <_bldr_task+0x2ce>
    7ca4:	81 e0       	ldi	r24, 0x01	; 1
    7ca6:	01 c0       	rjmp	.+2      	; 0x7caa <_bldr_task+0x2ce>
    7ca8:	81 e0       	ldi	r24, 0x01	; 1
    7caa:	0f 90       	pop	r0
    7cac:	df 91       	pop	r29
    7cae:	cf 91       	pop	r28
    7cb0:	1f 91       	pop	r17
    7cb2:	0f 91       	pop	r16
    7cb4:	ff 90       	pop	r15
    7cb6:	ef 90       	pop	r14
    7cb8:	df 90       	pop	r13
    7cba:	cf 90       	pop	r12
    7cbc:	08 95       	ret

00007cbe <_bldr_activate>:
    7cbe:	f8 94       	cli
    7cc0:	6f ef       	ldi	r22, 0xFF	; 255
    7cc2:	80 e0       	ldi	r24, 0x00	; 0
    7cc4:	93 e0       	ldi	r25, 0x03	; 3
    7cc6:	0e 94 fd 47 	call	0x8ffa	; 0x8ffa <sbldr_e2prom_write>
    7cca:	80 e0       	ldi	r24, 0x00	; 0
    7ccc:	0e 94 a7 39 	call	0x734e	; 0x734e <bldr_main>

Disassembly of section .bldrinit:

00008000 <bldr_boot>:

/* Bootloader Vektoren und Bootloader Startup Code
 */
BLDR_INIT_SECTION __ATTR_NAKED __ATTR_USED
static void bldr_boot(void) {    
    __asm__ __volatile__ (
    8000:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    8004:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8008:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    800c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8010:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8014:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8018:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    801c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8020:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8024:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8028:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    802c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8030:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8034:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8038:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    803c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8040:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8044:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8048:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    804c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8050:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8054:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8058:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    805c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8060:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8064:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8068:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    806c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8070:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8074:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8078:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    807c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8080:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8084:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8088:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    808c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8090:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8094:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8098:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    809c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80a0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80a4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80a8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80ac:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80b0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80b4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80b8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80bc:	0c 94 20 3a 	jmp	0x7440	; 0x7440 <__vector_47>
    80c0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80c4:	0c 94 fc 39 	jmp	0x73f8	; 0x73f8 <__vector_49>
    80c8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80cc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80d0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80d4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80d8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80dc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80e0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80e4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80e8:	0c 94 ff 43 	jmp	0x87fe	; 0x87fe <__vector_58>
    80ec:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80f0:	0c 94 23 44 	jmp	0x8846	; 0x8846 <__vector_60>
    80f4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80f8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    80fc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8100:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8104:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8108:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    810c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8110:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8114:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8118:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    811c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8120:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8124:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8128:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    812c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8130:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8134:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8138:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    813c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8140:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8144:	0c 94 ce 04 	jmp	0x99c	; 0x99c <__vector_81>
    8148:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    814c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8150:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8154:	0c 94 ad 03 	jmp	0x75a	; 0x75a <__vector_85>
    8158:	0c 94 c6 01 	jmp	0x38c	; 0x38c <__vector_86>
    815c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8160:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8164:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8168:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    816c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8170:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8174:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
    8178:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>

0000817c <__bldr_bad_interrupt>:
    817c:	18 95       	reti

0000817e <__bldr_init>:
    817e:	11 24       	eor	r1, r1
        "clr   __zero_reg__\n" // __zero_reg__ to 0
       : : : "memory"
    );

    // cli Interrupts lschen
    SREG = 0;     // cli
    8180:	1f be       	out	0x3f, r1	; 63
    // Stackpointer Initialiseren
    SP = BLDR_STACK_TOP; // INTERNAL_SRAM_END - sizeof(struct bldr_ram) - 1
    8182:	8a e8       	ldi	r24, 0x8A	; 138
    8184:	9e e2       	ldi	r25, 0x2E	; 46
    8186:	8d bf       	out	0x3d, r24	; 61
    8188:	9e bf       	out	0x3e, r25	; 62
    
    // RAM lschen (und somit Stackpointer und bldr_ram)
    uint8_t* p = (uint8_t*)INTERNAL_SRAM_START;
    818a:	e0 e0       	ldi	r30, 0x00	; 0
    818c:	f0 e2       	ldi	r31, 0x20	; 32
    do {
        *p++ = 0;
    818e:	10 82       	st	Z, r1
    8190:	31 96       	adiw	r30, 0x01	; 1
    } while (p != (uint8_t*)INTERNAL_SRAM_END);
    8192:	ef 3f       	cpi	r30, 0xFF	; 255
    8194:	8f e2       	ldi	r24, 0x2F	; 47
    8196:	f8 07       	cpc	r31, r24
    8198:	d1 f7       	brne	.-12     	; 0x818e <__bldr_init+0x10>

    // springe zu bldr_start()
    __asm__ __volatile__ (
    819a:	0c 94 10 46 	jmp	0x8c20	; 0x8c20 <bldr_start>

Disassembly of section .bldrvec:

00008200 <bldr_vector_table>:
    8200:	0c 94 5f 3e 	jmp	0x7cbe	; 0x7cbe <_bldr_activate>

00008204 <bldr_task>:
    8204:	0c 94 ee 3c 	jmp	0x79dc	; 0x79dc <_bldr_task>

00008208 <bldr_process_basic_msg>:
    8208:	0c 94 59 3a 	jmp	0x74b2	; 0x74b2 <_bldr_process_basic_msg>

0000820c <bldr_reg_read>:
    820c:	0c 94 54 3b 	jmp	0x76a8	; 0x76a8 <_bldr_reg_read>

00008210 <sbn_init>:
    8210:	0c 94 c9 41 	jmp	0x8392	; 0x8392 <sboxnet_init>

00008214 <sbn_receive_msg>:
    8214:	0c 94 da 44 	jmp	0x89b4	; 0x89b4 <sboxnet_receive_msg>

00008218 <sbn_send_msg>:
    8218:	0c 94 71 45 	jmp	0x8ae2	; 0x8ae2 <sboxnet_send_msg>

0000821c <sbn_all_sent>:
    821c:	0c 94 00 38 	jmp	0x7000	; 0x7000 <sboxnet_all_sent>
    8220:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    8224:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    8228:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    822c:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    8230:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    8234:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    8238:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>
    823c:	0c 94 bf 40 	jmp	0x817e	; 0x817e <__bldr_init>

Disassembly of section .bootloader:

00008240 <sboxnet_debug_inc_recverrors>:
    8240:	ee ee       	ldi	r30, 0xEE	; 238
    8242:	ff e2       	ldi	r31, 0x2F	; 47
    8244:	80 81       	ld	r24, Z
    8246:	91 81       	ldd	r25, Z+1	; 0x01
    8248:	01 96       	adiw	r24, 0x01	; 1
    824a:	80 83       	st	Z, r24
    824c:	91 83       	std	Z+1, r25	; 0x01
    824e:	08 95       	ret

00008250 <sboxnet_debug_inc_recverr_dor>:
    8250:	e4 ef       	ldi	r30, 0xF4	; 244
    8252:	ff e2       	ldi	r31, 0x2F	; 47
    8254:	80 81       	ld	r24, Z
    8256:	91 81       	ldd	r25, Z+1	; 0x01
    8258:	01 96       	adiw	r24, 0x01	; 1
    825a:	80 83       	st	Z, r24
    825c:	91 83       	std	Z+1, r25	; 0x01
    825e:	08 95       	ret

00008260 <sboxnet_debug_inc_recv_byte>:
    8260:	e8 ed       	ldi	r30, 0xD8	; 216
    8262:	ff e2       	ldi	r31, 0x2F	; 47
    8264:	80 81       	ld	r24, Z
    8266:	91 81       	ldd	r25, Z+1	; 0x01
    8268:	01 96       	adiw	r24, 0x01	; 1
    826a:	80 83       	st	Z, r24
    826c:	91 83       	std	Z+1, r25	; 0x01
    826e:	08 95       	ret

00008270 <sboxnet_prandom>:
    8270:	e7 ea       	ldi	r30, 0xA7	; 167
    8272:	fe e2       	ldi	r31, 0x2E	; 46
    8274:	80 85       	ldd	r24, Z+8	; 0x08
    8276:	98 2f       	mov	r25, r24
    8278:	99 0f       	add	r25, r25
    827a:	89 27       	eor	r24, r25
    827c:	98 2f       	mov	r25, r24
    827e:	96 95       	lsr	r25
    8280:	89 27       	eor	r24, r25
    8282:	98 2f       	mov	r25, r24
    8284:	99 0f       	add	r25, r25
    8286:	99 0f       	add	r25, r25
    8288:	89 27       	eor	r24, r25
    828a:	80 87       	std	Z+8, r24	; 0x08
    828c:	08 95       	ret

0000828e <sboxnet_rb_write>:
    828e:	cf 93       	push	r28
    8290:	df 93       	push	r29
    8292:	fc 01       	movw	r30, r24
    8294:	86 81       	ldd	r24, Z+6	; 0x06
    8296:	94 81       	ldd	r25, Z+4	; 0x04
    8298:	89 0f       	add	r24, r25
    829a:	27 81       	ldd	r18, Z+7	; 0x07
    829c:	82 17       	cp	r24, r18
    829e:	80 f4       	brcc	.+32     	; 0x82c0 <sboxnet_rb_write+0x32>
    82a0:	9f 5f       	subi	r25, 0xFF	; 255
    82a2:	94 83       	std	Z+4, r25	; 0x04
    82a4:	83 81       	ldd	r24, Z+3	; 0x03
    82a6:	ef 01       	movw	r28, r30
    82a8:	c8 0f       	add	r28, r24
    82aa:	d1 1d       	adc	r29, r1
    82ac:	68 87       	std	Y+8, r22	; 0x08
    82ae:	8f 5f       	subi	r24, 0xFF	; 255
    82b0:	82 17       	cp	r24, r18
    82b2:	18 f4       	brcc	.+6      	; 0x82ba <sboxnet_rb_write+0x2c>
    82b4:	83 83       	std	Z+3, r24	; 0x03
    82b6:	81 e0       	ldi	r24, 0x01	; 1
    82b8:	09 c0       	rjmp	.+18     	; 0x82cc <sboxnet_rb_write+0x3e>
    82ba:	13 82       	std	Z+3, r1	; 0x03
    82bc:	81 e0       	ldi	r24, 0x01	; 1
    82be:	06 c0       	rjmp	.+12     	; 0x82cc <sboxnet_rb_write+0x3e>
    82c0:	e7 ea       	ldi	r30, 0xA7	; 167
    82c2:	fe e2       	ldi	r31, 0x2E	; 46
    82c4:	81 81       	ldd	r24, Z+1	; 0x01
    82c6:	84 60       	ori	r24, 0x04	; 4
    82c8:	81 83       	std	Z+1, r24	; 0x01
    82ca:	80 e0       	ldi	r24, 0x00	; 0
    82cc:	df 91       	pop	r29
    82ce:	cf 91       	pop	r28
    82d0:	08 95       	ret

000082d2 <sboxnet_rb_read_commit>:
    82d2:	cf 93       	push	r28
    82d4:	df 93       	push	r29
    82d6:	fc 01       	movw	r30, r24
    82d8:	96 81       	ldd	r25, Z+6	; 0x06
    82da:	81 81       	ldd	r24, Z+1	; 0x01
    82dc:	98 17       	cp	r25, r24
    82de:	28 f4       	brcc	.+10     	; 0x82ea <sboxnet_rb_read_commit+0x18>
    82e0:	c7 ea       	ldi	r28, 0xA7	; 167
    82e2:	de e2       	ldi	r29, 0x2E	; 46
    82e4:	89 81       	ldd	r24, Y+1	; 0x01
    82e6:	82 60       	ori	r24, 0x02	; 2
    82e8:	89 83       	std	Y+1, r24	; 0x01
    82ea:	86 81       	ldd	r24, Z+6	; 0x06
    82ec:	91 81       	ldd	r25, Z+1	; 0x01
    82ee:	89 1b       	sub	r24, r25
    82f0:	86 83       	std	Z+6, r24	; 0x06
    82f2:	11 82       	std	Z+1, r1	; 0x01
    82f4:	80 81       	ld	r24, Z
    82f6:	82 83       	std	Z+2, r24	; 0x02
    82f8:	df 91       	pop	r29
    82fa:	cf 91       	pop	r28
    82fc:	08 95       	ret

000082fe <sboxnet_rb_read>:
    82fe:	cf 93       	push	r28
    8300:	df 93       	push	r29
    8302:	fc 01       	movw	r30, r24
    8304:	96 81       	ldd	r25, Z+6	; 0x06
    8306:	81 81       	ldd	r24, Z+1	; 0x01
    8308:	89 17       	cp	r24, r25
    830a:	70 f4       	brcc	.+28     	; 0x8328 <sboxnet_rb_read+0x2a>
    830c:	8f 5f       	subi	r24, 0xFF	; 255
    830e:	81 83       	std	Z+1, r24	; 0x01
    8310:	90 81       	ld	r25, Z
    8312:	ef 01       	movw	r28, r30
    8314:	c9 0f       	add	r28, r25
    8316:	d1 1d       	adc	r29, r1
    8318:	88 85       	ldd	r24, Y+8	; 0x08
    831a:	9f 5f       	subi	r25, 0xFF	; 255
    831c:	90 83       	st	Z, r25
    831e:	27 81       	ldd	r18, Z+7	; 0x07
    8320:	92 17       	cp	r25, r18
    8322:	40 f0       	brcs	.+16     	; 0x8334 <sboxnet_rb_read+0x36>
    8324:	10 82       	st	Z, r1
    8326:	06 c0       	rjmp	.+12     	; 0x8334 <sboxnet_rb_read+0x36>
    8328:	e7 ea       	ldi	r30, 0xA7	; 167
    832a:	fe e2       	ldi	r31, 0x2E	; 46
    832c:	81 81       	ldd	r24, Z+1	; 0x01
    832e:	82 60       	ori	r24, 0x02	; 2
    8330:	81 83       	std	Z+1, r24	; 0x01
    8332:	80 e0       	ldi	r24, 0x00	; 0
    8334:	df 91       	pop	r29
    8336:	cf 91       	pop	r28
    8338:	08 95       	ret

0000833a <bldr_random>:
    833a:	4f b7       	in	r20, 0x3f	; 63
    833c:	f8 94       	cli
    833e:	eb e8       	ldi	r30, 0x8B	; 139
    8340:	fe e2       	ldi	r31, 0x2E	; 46
    8342:	80 8d       	ldd	r24, Z+24	; 0x18
    8344:	91 8d       	ldd	r25, Z+25	; 0x19
    8346:	9c 01       	movw	r18, r24
    8348:	22 0f       	add	r18, r18
    834a:	33 1f       	adc	r19, r19
    834c:	82 27       	eor	r24, r18
    834e:	93 27       	eor	r25, r19
    8350:	9c 01       	movw	r18, r24
    8352:	36 95       	lsr	r19
    8354:	27 95       	ror	r18
    8356:	32 95       	swap	r19
    8358:	22 95       	swap	r18
    835a:	2f 70       	andi	r18, 0x0F	; 15
    835c:	23 27       	eor	r18, r19
    835e:	3f 70       	andi	r19, 0x0F	; 15
    8360:	23 27       	eor	r18, r19
    8362:	82 27       	eor	r24, r18
    8364:	93 27       	eor	r25, r19
    8366:	9c 01       	movw	r18, r24
    8368:	22 0f       	add	r18, r18
    836a:	33 1f       	adc	r19, r19
    836c:	22 0f       	add	r18, r18
    836e:	33 1f       	adc	r19, r19
    8370:	82 27       	eor	r24, r18
    8372:	93 27       	eor	r25, r19
    8374:	80 8f       	std	Z+24, r24	; 0x18
    8376:	91 8f       	std	Z+25, r25	; 0x19
    8378:	4f bf       	out	0x3f, r20	; 63
    837a:	08 95       	ret

0000837c <sboxnet_receiver_enable>:
    837c:	80 91 a3 08 	lds	r24, 0x08A3	; 0x8008a3 <__TEXT_REGION_LENGTH__+0x7f78a3>
    8380:	8f 7c       	andi	r24, 0xCF	; 207
    8382:	80 62       	ori	r24, 0x20	; 32
    8384:	e0 ea       	ldi	r30, 0xA0	; 160
    8386:	fa e0       	ldi	r31, 0x0A	; 10
    8388:	83 83       	std	Z+3, r24	; 0x03
    838a:	84 81       	ldd	r24, Z+4	; 0x04
    838c:	82 61       	ori	r24, 0x12	; 18
    838e:	84 83       	std	Z+4, r24	; 0x04
    8390:	08 95       	ret

00008392 <sboxnet_init>:
    8392:	cf 93       	push	r28
    8394:	df 93       	push	r29
    8396:	e7 ea       	ldi	r30, 0xA7	; 167
    8398:	fe e2       	ldi	r31, 0x2E	; 46
    839a:	87 e5       	ldi	r24, 0x57	; 87
    839c:	91 e0       	ldi	r25, 0x01	; 1
    839e:	df 01       	movw	r26, r30
    83a0:	9c 01       	movw	r18, r24
    83a2:	1d 92       	st	X+, r1
    83a4:	21 50       	subi	r18, 0x01	; 1
    83a6:	30 40       	sbci	r19, 0x00	; 0
    83a8:	e1 f7       	brne	.-8      	; 0x83a2 <sboxnet_init+0x10>
    83aa:	10 82       	st	Z, r1
    83ac:	80 91 a3 2e 	lds	r24, 0x2EA3	; 0x802ea3 <__bss_end+0xdba>
    83b0:	80 87       	std	Z+8, r24	; 0x08
    83b2:	89 e1       	ldi	r24, 0x19	; 25
    83b4:	82 83       	std	Z+2, r24	; 0x02
    83b6:	11 86       	std	Z+9, r1	; 0x09
    83b8:	12 86       	std	Z+10, r1	; 0x0a
    83ba:	13 86       	std	Z+11, r1	; 0x0b
    83bc:	14 86       	std	Z+12, r1	; 0x0c
    83be:	15 86       	std	Z+13, r1	; 0x0d
    83c0:	16 86       	std	Z+14, r1	; 0x0e
    83c2:	17 86       	std	Z+15, r1	; 0x0f
    83c4:	8c e8       	ldi	r24, 0x8C	; 140
    83c6:	80 8b       	std	Z+16, r24	; 0x10
    83c8:	e4 e4       	ldi	r30, 0x44	; 68
    83ca:	ff e2       	ldi	r31, 0x2F	; 47
    83cc:	10 82       	st	Z, r1
    83ce:	11 82       	std	Z+1, r1	; 0x01
    83d0:	12 82       	std	Z+2, r1	; 0x02
    83d2:	13 82       	std	Z+3, r1	; 0x03
    83d4:	14 82       	std	Z+4, r1	; 0x04
    83d6:	15 82       	std	Z+5, r1	; 0x05
    83d8:	16 82       	std	Z+6, r1	; 0x06
    83da:	87 83       	std	Z+7, r24	; 0x07
    83dc:	e0 e8       	ldi	r30, 0x80	; 128
    83de:	f6 e0       	ldi	r31, 0x06	; 6
    83e0:	94 e0       	ldi	r25, 0x04	; 4
    83e2:	92 83       	std	Z+2, r25	; 0x02
    83e4:	82 89       	ldd	r24, Z+18	; 0x12
    83e6:	87 7c       	andi	r24, 0xC7	; 199
    83e8:	88 61       	ori	r24, 0x18	; 24
    83ea:	82 8b       	std	Z+18, r24	; 0x12
    83ec:	88 e0       	ldi	r24, 0x08	; 8
    83ee:	85 83       	std	Z+5, r24	; 0x05
    83f0:	81 83       	std	Z+1, r24	; 0x01
    83f2:	c0 e0       	ldi	r28, 0x00	; 0
    83f4:	da e0       	ldi	r29, 0x0A	; 10
    83f6:	19 82       	std	Y+1, r1	; 0x01
    83f8:	1b 82       	std	Y+3, r1	; 0x03
    83fa:	1c 82       	std	Y+4, r1	; 0x04
    83fc:	22 e0       	ldi	r18, 0x02	; 2
    83fe:	2e 83       	std	Y+6, r18	; 0x06
    8400:	1f 82       	std	Y+7, r1	; 0x07
    8402:	8f ef       	ldi	r24, 0xFF	; 255
    8404:	8c 87       	std	Y+12, r24	; 0x0c
    8406:	4f ef       	ldi	r20, 0xFF	; 255
    8408:	5f e3       	ldi	r21, 0x3F	; 63
    840a:	4e a3       	std	Y+38, r20	; 0x26
    840c:	5f a3       	std	Y+39, r21	; 0x27
    840e:	98 83       	st	Y, r25
    8410:	81 85       	ldd	r24, Z+9	; 0x09
    8412:	8c 7f       	andi	r24, 0xFC	; 252
    8414:	81 87       	std	Z+9, r24	; 0x09
    8416:	92 87       	std	Z+10, r25	; 0x0a
    8418:	81 e0       	ldi	r24, 0x01	; 1
    841a:	84 87       	std	Z+12, r24	; 0x0c
    841c:	e0 ea       	ldi	r30, 0xA0	; 160
    841e:	fa e0       	ldi	r31, 0x0A	; 10
    8420:	17 82       	std	Z+7, r1	; 0x07
    8422:	87 e0       	ldi	r24, 0x07	; 7
    8424:	86 83       	std	Z+6, r24	; 0x06
    8426:	80 e4       	ldi	r24, 0x40	; 64
    8428:	81 83       	std	Z+1, r24	; 0x01
    842a:	13 82       	std	Z+3, r1	; 0x03
    842c:	24 83       	std	Z+4, r18	; 0x04
    842e:	87 e2       	ldi	r24, 0x27	; 39
    8430:	85 83       	std	Z+5, r24	; 0x05
    8432:	84 81       	ldd	r24, Z+4	; 0x04
    8434:	88 60       	ori	r24, 0x08	; 8
    8436:	84 83       	std	Z+4, r24	; 0x04
    8438:	0e 94 be 41 	call	0x837c	; 0x837c <sboxnet_receiver_enable>
    843c:	df 91       	pop	r29
    843e:	cf 91       	pop	r28
    8440:	08 95       	ret

00008442 <sboxnet_set_timer>:
    8442:	2f b7       	in	r18, 0x3f	; 63
    8444:	f8 94       	cli
    8446:	e0 e0       	ldi	r30, 0x00	; 0
    8448:	fa e0       	ldi	r31, 0x0A	; 10
    844a:	40 a1       	ldd	r20, Z+32	; 0x20
    844c:	51 a1       	ldd	r21, Z+33	; 0x21
    844e:	84 0f       	add	r24, r20
    8450:	95 1f       	adc	r25, r21
    8452:	9f 73       	andi	r25, 0x3F	; 63
    8454:	80 af       	std	Z+56, r24	; 0x38
    8456:	91 af       	std	Z+57, r25	; 0x39
    8458:	80 e1       	ldi	r24, 0x10	; 16
    845a:	84 87       	std	Z+12, r24	; 0x0c
    845c:	87 81       	ldd	r24, Z+7	; 0x07
    845e:	8c 7f       	andi	r24, 0xFC	; 252
    8460:	82 60       	ori	r24, 0x02	; 2
    8462:	87 83       	std	Z+7, r24	; 0x07
    8464:	2f bf       	out	0x3f, r18	; 63
    8466:	08 95       	ret

00008468 <sboxnet_set_backoff_with_offset>:
    8468:	21 e0       	ldi	r18, 0x01	; 1
    846a:	20 93 8c 06 	sts	0x068C, r18	; 0x80068c <__TEXT_REGION_LENGTH__+0x7f768c>
    846e:	20 93 a7 2e 	sts	0x2EA7, r18	; 0x802ea7 <__bss_end+0xdbe>
    8472:	80 52       	subi	r24, 0x20	; 32
    8474:	9e 4f       	sbci	r25, 0xFE	; 254
    8476:	0e 94 21 42 	call	0x8442	; 0x8442 <sboxnet_set_timer>
    847a:	08 95       	ret

0000847c <sboxnet_intr_usart_rx>:
    847c:	cf 92       	push	r12
    847e:	df 92       	push	r13
    8480:	ef 92       	push	r14
    8482:	ff 92       	push	r15
    8484:	0f 93       	push	r16
    8486:	1f 93       	push	r17
    8488:	cf 93       	push	r28
    848a:	df 93       	push	r29
    848c:	1f 92       	push	r1
    848e:	cd b7       	in	r28, 0x3d	; 61
    8490:	de b7       	in	r29, 0x3e	; 62
    8492:	07 ea       	ldi	r16, 0xA7	; 167
    8494:	1e e2       	ldi	r17, 0x2E	; 46
    8496:	e0 ea       	ldi	r30, 0xA0	; 160
    8498:	fa e0       	ldi	r31, 0x0A	; 10
    849a:	f1 80       	ldd	r15, Z+1	; 0x01
    849c:	f9 82       	std	Y+1, r15	; 0x01
    849e:	99 81       	ldd	r25, Y+1	; 0x01
    84a0:	e0 80       	ld	r14, Z
    84a2:	8f 2d       	mov	r24, r15
    84a4:	8c 71       	andi	r24, 0x1C	; 28
    84a6:	89 83       	std	Y+1, r24	; 0x01
    84a8:	88 23       	and	r24, r24
    84aa:	d1 f0       	breq	.+52     	; 0x84e0 <sboxnet_intr_usart_rx+0x64>
    84ac:	0e 94 20 41 	call	0x8240	; 0x8240 <sboxnet_debug_inc_recverrors>
    84b0:	f4 fe       	sbrs	r15, 4
    84b2:	08 c0       	rjmp	.+16     	; 0x84c4 <sboxnet_intr_usart_rx+0x48>
    84b4:	f8 01       	movw	r30, r16
    84b6:	e7 5b       	subi	r30, 0xB7	; 183
    84b8:	fe 4f       	sbci	r31, 0xFE	; 254
    84ba:	80 81       	ld	r24, Z
    84bc:	91 81       	ldd	r25, Z+1	; 0x01
    84be:	01 96       	adiw	r24, 0x01	; 1
    84c0:	80 83       	st	Z, r24
    84c2:	91 83       	std	Z+1, r25	; 0x01
    84c4:	f3 fc       	sbrc	r15, 3
    84c6:	0e 94 28 41 	call	0x8250	; 0x8250 <sboxnet_debug_inc_recverr_dor>
    84ca:	f2 fe       	sbrs	r15, 2
    84cc:	98 c0       	rjmp	.+304    	; 0x85fe <sboxnet_intr_usart_rx+0x182>
    84ce:	f8 01       	movw	r30, r16
    84d0:	e5 5b       	subi	r30, 0xB5	; 181
    84d2:	fe 4f       	sbci	r31, 0xFE	; 254
    84d4:	80 81       	ld	r24, Z
    84d6:	91 81       	ldd	r25, Z+1	; 0x01
    84d8:	01 96       	adiw	r24, 0x01	; 1
    84da:	80 83       	st	Z, r24
    84dc:	91 83       	std	Z+1, r25	; 0x01
    84de:	8f c0       	rjmp	.+286    	; 0x85fe <sboxnet_intr_usart_rx+0x182>
    84e0:	90 ff       	sbrs	r25, 0
    84e2:	36 c0       	rjmp	.+108    	; 0x8550 <sboxnet_intr_usart_rx+0xd4>
    84e4:	f8 01       	movw	r30, r16
    84e6:	85 85       	ldd	r24, Z+13	; 0x0d
    84e8:	88 23       	and	r24, r24
    84ea:	69 f0       	breq	.+26     	; 0x8506 <sboxnet_intr_usart_rx+0x8a>
    84ec:	e1 5b       	subi	r30, 0xB1	; 177
    84ee:	fe 4f       	sbci	r31, 0xFE	; 254
    84f0:	80 81       	ld	r24, Z
    84f2:	91 81       	ldd	r25, Z+1	; 0x01
    84f4:	01 96       	adiw	r24, 0x01	; 1
    84f6:	80 83       	st	Z, r24
    84f8:	91 83       	std	Z+1, r25	; 0x01
    84fa:	0e 94 20 41 	call	0x8240	; 0x8240 <sboxnet_debug_inc_recverrors>
    84fe:	f8 01       	movw	r30, r16
    8500:	15 86       	std	Z+13, r1	; 0x0d
    8502:	86 85       	ldd	r24, Z+14	; 0x0e
    8504:	84 87       	std	Z+12, r24	; 0x0c
    8506:	80 91 8b 2e 	lds	r24, 0x2E8B	; 0x802e8b <__bss_end+0xda2>
    850a:	e8 16       	cp	r14, r24
    850c:	19 f0       	breq	.+6      	; 0x8514 <sboxnet_intr_usart_rx+0x98>
    850e:	ff ef       	ldi	r31, 0xFF	; 255
    8510:	ef 12       	cpse	r14, r31
    8512:	75 c0       	rjmp	.+234    	; 0x85fe <sboxnet_intr_usart_rx+0x182>
    8514:	e0 ea       	ldi	r30, 0xA0	; 160
    8516:	fa e0       	ldi	r31, 0x0A	; 10
    8518:	84 81       	ldd	r24, Z+4	; 0x04
    851a:	8d 7f       	andi	r24, 0xFD	; 253
    851c:	84 83       	std	Z+4, r24	; 0x04
    851e:	68 01       	movw	r12, r16
    8520:	89 e0       	ldi	r24, 0x09	; 9
    8522:	c8 0e       	add	r12, r24
    8524:	d1 1c       	adc	r13, r1
    8526:	60 e0       	ldi	r22, 0x00	; 0
    8528:	c6 01       	movw	r24, r12
    852a:	0e 94 47 41 	call	0x828e	; 0x828e <sboxnet_rb_write>
    852e:	88 23       	and	r24, r24
    8530:	61 f0       	breq	.+24     	; 0x854a <sboxnet_intr_usart_rx+0xce>
    8532:	6e 2d       	mov	r22, r14
    8534:	c6 01       	movw	r24, r12
    8536:	0e 94 47 41 	call	0x828e	; 0x828e <sboxnet_rb_write>
    853a:	88 23       	and	r24, r24
    853c:	31 f0       	breq	.+12     	; 0x854a <sboxnet_intr_usart_rx+0xce>
    853e:	0e 94 30 41 	call	0x8260	; 0x8260 <sboxnet_debug_inc_recv_byte>
    8542:	86 e0       	ldi	r24, 0x06	; 6
    8544:	f8 01       	movw	r30, r16
    8546:	87 83       	std	Z+7, r24	; 0x07
    8548:	65 c0       	rjmp	.+202    	; 0x8614 <sboxnet_intr_usart_rx+0x198>
    854a:	0e 94 28 41 	call	0x8250	; 0x8250 <sboxnet_debug_inc_recverr_dor>
    854e:	55 c0       	rjmp	.+170    	; 0x85fa <sboxnet_intr_usart_rx+0x17e>
    8550:	f8 01       	movw	r30, r16
    8552:	85 85       	ldd	r24, Z+13	; 0x0d
    8554:	97 81       	ldd	r25, Z+7	; 0x07
    8556:	98 17       	cp	r25, r24
    8558:	40 f4       	brcc	.+16     	; 0x856a <sboxnet_intr_usart_rx+0xee>
    855a:	ef 5a       	subi	r30, 0xAF	; 175
    855c:	fe 4f       	sbci	r31, 0xFE	; 254
    855e:	80 81       	ld	r24, Z
    8560:	91 81       	ldd	r25, Z+1	; 0x01
    8562:	01 96       	adiw	r24, 0x01	; 1
    8564:	80 83       	st	Z, r24
    8566:	91 83       	std	Z+1, r25	; 0x01
    8568:	48 c0       	rjmp	.+144    	; 0x85fa <sboxnet_intr_usart_rx+0x17e>
    856a:	84 30       	cpi	r24, 0x04	; 4
    856c:	29 f4       	brne	.+10     	; 0x8578 <sboxnet_intr_usart_rx+0xfc>
    856e:	8e 2d       	mov	r24, r14
    8570:	8f 73       	andi	r24, 0x3F	; 63
    8572:	8a 5f       	subi	r24, 0xFA	; 250
    8574:	f8 01       	movw	r30, r16
    8576:	87 83       	std	Z+7, r24	; 0x07
    8578:	6e 2d       	mov	r22, r14
    857a:	c8 01       	movw	r24, r16
    857c:	09 96       	adiw	r24, 0x09	; 9
    857e:	0e 94 47 41 	call	0x828e	; 0x828e <sboxnet_rb_write>
    8582:	81 11       	cpse	r24, r1
    8584:	03 c0       	rjmp	.+6      	; 0x858c <sboxnet_intr_usart_rx+0x110>
    8586:	0e 94 28 41 	call	0x8250	; 0x8250 <sboxnet_debug_inc_recverr_dor>
    858a:	37 c0       	rjmp	.+110    	; 0x85fa <sboxnet_intr_usart_rx+0x17e>
    858c:	0e 94 30 41 	call	0x8260	; 0x8260 <sboxnet_debug_inc_recv_byte>
    8590:	f8 01       	movw	r30, r16
    8592:	25 85       	ldd	r18, Z+13	; 0x0d
    8594:	30 e0       	ldi	r19, 0x00	; 0
    8596:	47 81       	ldd	r20, Z+7	; 0x07
    8598:	84 2f       	mov	r24, r20
    859a:	90 e0       	ldi	r25, 0x00	; 0
    859c:	01 96       	adiw	r24, 0x01	; 1
    859e:	28 17       	cp	r18, r24
    85a0:	39 07       	cpc	r19, r25
    85a2:	c1 f5       	brne	.+112    	; 0x8614 <sboxnet_intr_usart_rx+0x198>
    85a4:	86 85       	ldd	r24, Z+14	; 0x0e
    85a6:	e8 0f       	add	r30, r24
    85a8:	f1 1d       	adc	r31, r1
    85aa:	41 8b       	std	Z+17, r20	; 0x11
    85ac:	f8 01       	movw	r30, r16
    85ae:	17 82       	std	Z+7, r1	; 0x07
    85b0:	e0 ea       	ldi	r30, 0xA0	; 160
    85b2:	fa e0       	ldi	r31, 0x0A	; 10
    85b4:	84 81       	ldd	r24, Z+4	; 0x04
    85b6:	82 60       	ori	r24, 0x02	; 2
    85b8:	84 83       	std	Z+4, r24	; 0x04
    85ba:	f8 01       	movw	r30, r16
    85bc:	27 85       	ldd	r18, Z+15	; 0x0f
    85be:	85 85       	ldd	r24, Z+13	; 0x0d
    85c0:	90 e0       	ldi	r25, 0x00	; 0
    85c2:	82 0f       	add	r24, r18
    85c4:	91 1d       	adc	r25, r1
    85c6:	20 89       	ldd	r18, Z+16	; 0x10
    85c8:	30 e0       	ldi	r19, 0x00	; 0
    85ca:	28 17       	cp	r18, r24
    85cc:	39 07       	cpc	r19, r25
    85ce:	2c f4       	brge	.+10     	; 0x85da <sboxnet_intr_usart_rx+0x15e>
    85d0:	e7 ea       	ldi	r30, 0xA7	; 167
    85d2:	fe e2       	ldi	r31, 0x2E	; 46
    85d4:	81 81       	ldd	r24, Z+1	; 0x01
    85d6:	84 60       	ori	r24, 0x04	; 4
    85d8:	81 83       	std	Z+1, r24	; 0x01
    85da:	f8 01       	movw	r30, r16
    85dc:	97 85       	ldd	r25, Z+15	; 0x0f
    85de:	85 85       	ldd	r24, Z+13	; 0x0d
    85e0:	89 0f       	add	r24, r25
    85e2:	87 87       	std	Z+15, r24	; 0x0f
    85e4:	15 86       	std	Z+13, r1	; 0x0d
    85e6:	84 85       	ldd	r24, Z+12	; 0x0c
    85e8:	86 87       	std	Z+14, r24	; 0x0e
    85ea:	ea ed       	ldi	r30, 0xDA	; 218
    85ec:	ff e2       	ldi	r31, 0x2F	; 47
    85ee:	80 81       	ld	r24, Z
    85f0:	91 81       	ldd	r25, Z+1	; 0x01
    85f2:	01 96       	adiw	r24, 0x01	; 1
    85f4:	80 83       	st	Z, r24
    85f6:	91 83       	std	Z+1, r25	; 0x01
    85f8:	0d c0       	rjmp	.+26     	; 0x8614 <sboxnet_intr_usart_rx+0x198>
    85fa:	0e 94 20 41 	call	0x8240	; 0x8240 <sboxnet_debug_inc_recverrors>
    85fe:	f8 01       	movw	r30, r16
    8600:	17 82       	std	Z+7, r1	; 0x07
    8602:	e0 ea       	ldi	r30, 0xA0	; 160
    8604:	fa e0       	ldi	r31, 0x0A	; 10
    8606:	84 81       	ldd	r24, Z+4	; 0x04
    8608:	82 60       	ori	r24, 0x02	; 2
    860a:	84 83       	std	Z+4, r24	; 0x04
    860c:	f8 01       	movw	r30, r16
    860e:	15 86       	std	Z+13, r1	; 0x0d
    8610:	86 85       	ldd	r24, Z+14	; 0x0e
    8612:	84 87       	std	Z+12, r24	; 0x0c
    8614:	0f 90       	pop	r0
    8616:	df 91       	pop	r29
    8618:	cf 91       	pop	r28
    861a:	1f 91       	pop	r17
    861c:	0f 91       	pop	r16
    861e:	ff 90       	pop	r15
    8620:	ef 90       	pop	r14
    8622:	df 90       	pop	r13
    8624:	cf 90       	pop	r12
    8626:	08 95       	ret

00008628 <sboxnet_check_try_transmit>:
    8628:	cf 93       	push	r28
    862a:	df 93       	push	r29
    862c:	c7 ea       	ldi	r28, 0xA7	; 167
    862e:	de e2       	ldi	r29, 0x2E	; 46
    8630:	8c 81       	ldd	r24, Y+4	; 0x04
    8632:	81 11       	cpse	r24, r1
    8634:	0d c0       	rjmp	.+26     	; 0x8650 <sboxnet_check_try_transmit+0x28>
    8636:	fe 01       	movw	r30, r28
    8638:	e3 56       	subi	r30, 0x63	; 99
    863a:	ff 4f       	sbci	r31, 0xFF	; 255
    863c:	86 81       	ldd	r24, Z+6	; 0x06
    863e:	87 30       	cpi	r24, 0x07	; 7
    8640:	f8 f0       	brcs	.+62     	; 0x8680 <sboxnet_check_try_transmit+0x58>
    8642:	1b 82       	std	Y+3, r1	; 0x03
    8644:	cf 01       	movw	r24, r30
    8646:	0e 94 7f 41 	call	0x82fe	; 0x82fe <sboxnet_rb_read>
    864a:	8c 83       	std	Y+4, r24	; 0x04
    864c:	88 23       	and	r24, r24
    864e:	c1 f0       	breq	.+48     	; 0x8680 <sboxnet_check_try_transmit+0x58>
    8650:	8b 81       	ldd	r24, Y+3	; 0x03
    8652:	81 11       	cpse	r24, r1
    8654:	15 c0       	rjmp	.+42     	; 0x8680 <sboxnet_check_try_transmit+0x58>
    8656:	88 81       	ld	r24, Y
    8658:	81 11       	cpse	r24, r1
    865a:	12 c0       	rjmp	.+36     	; 0x8680 <sboxnet_check_try_transmit+0x58>
    865c:	0e 94 38 41 	call	0x8270	; 0x8270 <sboxnet_prandom>
    8660:	28 2f       	mov	r18, r24
    8662:	2f 77       	andi	r18, 0x7F	; 127
    8664:	9a 81       	ldd	r25, Y+2	; 0x02
    8666:	89 2f       	mov	r24, r25
    8668:	90 e0       	ldi	r25, 0x00	; 0
    866a:	08 96       	adiw	r24, 0x08	; 8
    866c:	88 0f       	add	r24, r24
    866e:	99 1f       	adc	r25, r25
    8670:	88 0f       	add	r24, r24
    8672:	99 1f       	adc	r25, r25
    8674:	88 0f       	add	r24, r24
    8676:	99 1f       	adc	r25, r25
    8678:	82 0f       	add	r24, r18
    867a:	91 1d       	adc	r25, r1
    867c:	0e 94 34 42 	call	0x8468	; 0x8468 <sboxnet_set_backoff_with_offset>
    8680:	df 91       	pop	r29
    8682:	cf 91       	pop	r28
    8684:	08 95       	ret

00008686 <sboxnet_intr_usart_tx>:
    8686:	cf 93       	push	r28
    8688:	df 93       	push	r29
    868a:	c7 ea       	ldi	r28, 0xA7	; 167
    868c:	de e2       	ldi	r29, 0x2E	; 46
    868e:	e0 ea       	ldi	r30, 0xA0	; 160
    8690:	fa e0       	ldi	r31, 0x0A	; 10
    8692:	81 81       	ldd	r24, Z+1	; 0x01
    8694:	48 2f       	mov	r20, r24
    8696:	44 71       	andi	r20, 0x14	; 20
    8698:	30 81       	ld	r19, Z
    869a:	2d 81       	ldd	r18, Y+5	; 0x05
    869c:	88 23       	and	r24, r24
    869e:	2c f4       	brge	.+10     	; 0x86aa <sboxnet_intr_usart_tx+0x24>
    86a0:	41 11       	cpse	r20, r1
    86a2:	0d c0       	rjmp	.+26     	; 0x86be <sboxnet_intr_usart_tx+0x38>
    86a4:	32 13       	cpse	r19, r18
    86a6:	13 c0       	rjmp	.+38     	; 0x86ce <sboxnet_intr_usart_tx+0x48>
    86a8:	64 c0       	rjmp	.+200    	; 0x8772 <sboxnet_intr_usart_tx+0xec>
    86aa:	fe 01       	movw	r30, r28
    86ac:	e1 5c       	subi	r30, 0xC1	; 193
    86ae:	fe 4f       	sbci	r31, 0xFE	; 254
    86b0:	80 81       	ld	r24, Z
    86b2:	91 81       	ldd	r25, Z+1	; 0x01
    86b4:	01 96       	adiw	r24, 0x01	; 1
    86b6:	80 83       	st	Z, r24
    86b8:	91 83       	std	Z+1, r25	; 0x01
    86ba:	44 23       	and	r20, r20
    86bc:	41 f0       	breq	.+16     	; 0x86ce <sboxnet_intr_usart_tx+0x48>
    86be:	fe 01       	movw	r30, r28
    86c0:	ef 5b       	subi	r30, 0xBF	; 191
    86c2:	fe 4f       	sbci	r31, 0xFE	; 254
    86c4:	80 81       	ld	r24, Z
    86c6:	91 81       	ldd	r25, Z+1	; 0x01
    86c8:	01 96       	adiw	r24, 0x01	; 1
    86ca:	80 83       	st	Z, r24
    86cc:	91 83       	std	Z+1, r25	; 0x01
    86ce:	32 17       	cp	r19, r18
    86d0:	41 f0       	breq	.+16     	; 0x86e2 <sboxnet_intr_usart_tx+0x5c>
    86d2:	fe 01       	movw	r30, r28
    86d4:	ed 5b       	subi	r30, 0xBD	; 189
    86d6:	fe 4f       	sbci	r31, 0xFE	; 254
    86d8:	80 81       	ld	r24, Z
    86da:	91 81       	ldd	r25, Z+1	; 0x01
    86dc:	01 96       	adiw	r24, 0x01	; 1
    86de:	80 83       	st	Z, r24
    86e0:	91 83       	std	Z+1, r25	; 0x01
    86e2:	88 e0       	ldi	r24, 0x08	; 8
    86e4:	80 93 86 06 	sts	0x0686, r24	; 0x800686 <__TEXT_REGION_LENGTH__+0x7f7686>
    86e8:	82 e0       	ldi	r24, 0x02	; 2
    86ea:	88 83       	st	Y, r24
    86ec:	fe 01       	movw	r30, r28
    86ee:	e3 5c       	subi	r30, 0xC3	; 195
    86f0:	fe 4f       	sbci	r31, 0xFE	; 254
    86f2:	80 81       	ld	r24, Z
    86f4:	91 81       	ldd	r25, Z+1	; 0x01
    86f6:	01 96       	adiw	r24, 0x01	; 1
    86f8:	80 83       	st	Z, r24
    86fa:	91 83       	std	Z+1, r25	; 0x01
    86fc:	8a 81       	ldd	r24, Y+2	; 0x02
    86fe:	81 11       	cpse	r24, r1
    8700:	05 c0       	rjmp	.+10     	; 0x870c <sboxnet_intr_usart_tx+0x86>
    8702:	9b 81       	ldd	r25, Y+3	; 0x03
    8704:	8c 81       	ldd	r24, Y+4	; 0x04
    8706:	98 17       	cp	r25, r24
    8708:	88 f0       	brcs	.+34     	; 0x872c <sboxnet_intr_usart_tx+0xa6>
    870a:	1b c0       	rjmp	.+54     	; 0x8742 <sboxnet_intr_usart_tx+0xbc>
    870c:	81 50       	subi	r24, 0x01	; 1
    870e:	8a 83       	std	Y+2, r24	; 0x02
    8710:	fe 01       	movw	r30, r28
    8712:	e3 56       	subi	r30, 0x63	; 99
    8714:	ff 4f       	sbci	r31, 0xFF	; 255
    8716:	11 82       	std	Z+1, r1	; 0x01
    8718:	82 81       	ldd	r24, Z+2	; 0x02
    871a:	80 83       	st	Z, r24
    871c:	e8 55       	subi	r30, 0x58	; 88
    871e:	ff 4f       	sbci	r31, 0xFF	; 255
    8720:	80 81       	ld	r24, Z
    8722:	91 81       	ldd	r25, Z+1	; 0x01
    8724:	01 96       	adiw	r24, 0x01	; 1
    8726:	80 83       	st	Z, r24
    8728:	91 83       	std	Z+1, r25	; 0x01
    872a:	1c c0       	rjmp	.+56     	; 0x8764 <sboxnet_intr_usart_tx+0xde>
    872c:	ce 01       	movw	r24, r28
    872e:	83 56       	subi	r24, 0x63	; 99
    8730:	9f 4f       	sbci	r25, 0xFF	; 255
    8732:	0e 94 7f 41 	call	0x82fe	; 0x82fe <sboxnet_rb_read>
    8736:	8b 81       	ldd	r24, Y+3	; 0x03
    8738:	8f 5f       	subi	r24, 0xFF	; 255
    873a:	8b 83       	std	Y+3, r24	; 0x03
    873c:	9c 81       	ldd	r25, Y+4	; 0x04
    873e:	89 17       	cp	r24, r25
    8740:	a8 f3       	brcs	.-22     	; 0x872c <sboxnet_intr_usart_tx+0xa6>
    8742:	1c 82       	std	Y+4, r1	; 0x04
    8744:	1b 82       	std	Y+3, r1	; 0x03
    8746:	89 e1       	ldi	r24, 0x19	; 25
    8748:	8a 83       	std	Y+2, r24	; 0x02
    874a:	ce 01       	movw	r24, r28
    874c:	83 56       	subi	r24, 0x63	; 99
    874e:	9f 4f       	sbci	r25, 0xFF	; 255
    8750:	0e 94 69 41 	call	0x82d2	; 0x82d2 <sboxnet_rb_read_commit>
    8754:	fe 01       	movw	r30, r28
    8756:	eb 5a       	subi	r30, 0xAB	; 171
    8758:	fe 4f       	sbci	r31, 0xFE	; 254
    875a:	80 81       	ld	r24, Z
    875c:	91 81       	ldd	r25, Z+1	; 0x01
    875e:	01 96       	adiw	r24, 0x01	; 1
    8760:	80 83       	st	Z, r24
    8762:	91 83       	std	Z+1, r25	; 0x01
    8764:	1c 82       	std	Y+4, r1	; 0x04
    8766:	1b 82       	std	Y+3, r1	; 0x03
    8768:	80 e0       	ldi	r24, 0x00	; 0
    876a:	92 e0       	ldi	r25, 0x02	; 2
    876c:	0e 94 21 42 	call	0x8442	; 0x8442 <sboxnet_set_timer>
    8770:	43 c0       	rjmp	.+134    	; 0x87f8 <sboxnet_intr_usart_tx+0x172>
    8772:	e0 ea       	ldi	r30, 0xA0	; 160
    8774:	fa e0       	ldi	r31, 0x0A	; 10
    8776:	84 81       	ldd	r24, Z+4	; 0x04
    8778:	8f 7e       	andi	r24, 0xEF	; 239
    877a:	84 83       	std	Z+4, r24	; 0x04
    877c:	83 81       	ldd	r24, Z+3	; 0x03
    877e:	8f 7c       	andi	r24, 0xCF	; 207
    8780:	83 83       	std	Z+3, r24	; 0x03
    8782:	84 81       	ldd	r24, Z+4	; 0x04
    8784:	80 61       	ori	r24, 0x10	; 16
    8786:	84 83       	std	Z+4, r24	; 0x04
    8788:	9b 81       	ldd	r25, Y+3	; 0x03
    878a:	8c 81       	ldd	r24, Y+4	; 0x04
    878c:	98 17       	cp	r25, r24
    878e:	80 f4       	brcc	.+32     	; 0x87b0 <sboxnet_intr_usart_tx+0x12a>
    8790:	ce 01       	movw	r24, r28
    8792:	83 56       	subi	r24, 0x63	; 99
    8794:	9f 4f       	sbci	r25, 0xFF	; 255
    8796:	0e 94 7f 41 	call	0x82fe	; 0x82fe <sboxnet_rb_read>
    879a:	9b 81       	ldd	r25, Y+3	; 0x03
    879c:	9f 5f       	subi	r25, 0xFF	; 255
    879e:	9b 83       	std	Y+3, r25	; 0x03
    87a0:	8d 83       	std	Y+5, r24	; 0x05
    87a2:	e0 ea       	ldi	r30, 0xA0	; 160
    87a4:	fa e0       	ldi	r31, 0x0A	; 10
    87a6:	94 81       	ldd	r25, Z+4	; 0x04
    87a8:	9e 7f       	andi	r25, 0xFE	; 254
    87aa:	94 83       	std	Z+4, r25	; 0x04
    87ac:	80 83       	st	Z, r24
    87ae:	1d c0       	rjmp	.+58     	; 0x87ea <sboxnet_intr_usart_tx+0x164>
    87b0:	e0 ea       	ldi	r30, 0xA0	; 160
    87b2:	fa e0       	ldi	r31, 0x0A	; 10
    87b4:	83 81       	ldd	r24, Z+3	; 0x03
    87b6:	83 7f       	andi	r24, 0xF3	; 243
    87b8:	83 83       	std	Z+3, r24	; 0x03
    87ba:	1c 82       	std	Y+4, r1	; 0x04
    87bc:	1b 82       	std	Y+3, r1	; 0x03
    87be:	ce 01       	movw	r24, r28
    87c0:	83 56       	subi	r24, 0x63	; 99
    87c2:	9f 4f       	sbci	r25, 0xFF	; 255
    87c4:	0e 94 69 41 	call	0x82d2	; 0x82d2 <sboxnet_rb_read_commit>
    87c8:	e2 ee       	ldi	r30, 0xE2	; 226
    87ca:	ff e2       	ldi	r31, 0x2F	; 47
    87cc:	80 81       	ld	r24, Z
    87ce:	91 81       	ldd	r25, Z+1	; 0x01
    87d0:	01 96       	adiw	r24, 0x01	; 1
    87d2:	80 83       	st	Z, r24
    87d4:	91 83       	std	Z+1, r25	; 0x01
    87d6:	0e 94 be 41 	call	0x837c	; 0x837c <sboxnet_receiver_enable>
    87da:	88 81       	ld	r24, Y
    87dc:	83 30       	cpi	r24, 0x03	; 3
    87de:	09 f4       	brne	.+2      	; 0x87e2 <sboxnet_intr_usart_tx+0x15c>
    87e0:	18 82       	st	Y, r1
    87e2:	89 e1       	ldi	r24, 0x19	; 25
    87e4:	8a 83       	std	Y+2, r24	; 0x02
    87e6:	0e 94 14 43 	call	0x8628	; 0x8628 <sboxnet_check_try_transmit>
    87ea:	c9 5c       	subi	r28, 0xC9	; 201
    87ec:	de 4f       	sbci	r29, 0xFE	; 254
    87ee:	88 81       	ld	r24, Y
    87f0:	99 81       	ldd	r25, Y+1	; 0x01
    87f2:	01 96       	adiw	r24, 0x01	; 1
    87f4:	88 83       	st	Y, r24
    87f6:	99 83       	std	Y+1, r25	; 0x01
    87f8:	df 91       	pop	r29
    87fa:	cf 91       	pop	r28
    87fc:	08 95       	ret

000087fe <__vector_58>:
    87fe:	1f 92       	push	r1
    8800:	0f 92       	push	r0
    8802:	0f b6       	in	r0, 0x3f	; 63
    8804:	0f 92       	push	r0
    8806:	11 24       	eor	r1, r1
    8808:	2f 93       	push	r18
    880a:	3f 93       	push	r19
    880c:	4f 93       	push	r20
    880e:	5f 93       	push	r21
    8810:	6f 93       	push	r22
    8812:	7f 93       	push	r23
    8814:	8f 93       	push	r24
    8816:	9f 93       	push	r25
    8818:	af 93       	push	r26
    881a:	bf 93       	push	r27
    881c:	ef 93       	push	r30
    881e:	ff 93       	push	r31
    8820:	0e 94 3e 42 	call	0x847c	; 0x847c <sboxnet_intr_usart_rx>
    8824:	ff 91       	pop	r31
    8826:	ef 91       	pop	r30
    8828:	bf 91       	pop	r27
    882a:	af 91       	pop	r26
    882c:	9f 91       	pop	r25
    882e:	8f 91       	pop	r24
    8830:	7f 91       	pop	r23
    8832:	6f 91       	pop	r22
    8834:	5f 91       	pop	r21
    8836:	4f 91       	pop	r20
    8838:	3f 91       	pop	r19
    883a:	2f 91       	pop	r18
    883c:	0f 90       	pop	r0
    883e:	0f be       	out	0x3f, r0	; 63
    8840:	0f 90       	pop	r0
    8842:	1f 90       	pop	r1
    8844:	18 95       	reti

00008846 <__vector_60>:
    8846:	1f 92       	push	r1
    8848:	0f 92       	push	r0
    884a:	0f b6       	in	r0, 0x3f	; 63
    884c:	0f 92       	push	r0
    884e:	11 24       	eor	r1, r1
    8850:	2f 93       	push	r18
    8852:	3f 93       	push	r19
    8854:	4f 93       	push	r20
    8856:	5f 93       	push	r21
    8858:	6f 93       	push	r22
    885a:	7f 93       	push	r23
    885c:	8f 93       	push	r24
    885e:	9f 93       	push	r25
    8860:	af 93       	push	r26
    8862:	bf 93       	push	r27
    8864:	ef 93       	push	r30
    8866:	ff 93       	push	r31
    8868:	0e 94 43 43 	call	0x8686	; 0x8686 <sboxnet_intr_usart_tx>
    886c:	ff 91       	pop	r31
    886e:	ef 91       	pop	r30
    8870:	bf 91       	pop	r27
    8872:	af 91       	pop	r26
    8874:	9f 91       	pop	r25
    8876:	8f 91       	pop	r24
    8878:	7f 91       	pop	r23
    887a:	6f 91       	pop	r22
    887c:	5f 91       	pop	r21
    887e:	4f 91       	pop	r20
    8880:	3f 91       	pop	r19
    8882:	2f 91       	pop	r18
    8884:	0f 90       	pop	r0
    8886:	0f be       	out	0x3f, r0	; 63
    8888:	0f 90       	pop	r0
    888a:	1f 90       	pop	r1
    888c:	18 95       	reti

0000888e <sboxnet_timer_bit>:
    888e:	cf 93       	push	r28
    8890:	df 93       	push	r29
    8892:	e0 e0       	ldi	r30, 0x00	; 0
    8894:	fa e0       	ldi	r31, 0x0A	; 10
    8896:	87 81       	ldd	r24, Z+7	; 0x07
    8898:	8c 7f       	andi	r24, 0xFC	; 252
    889a:	87 83       	std	Z+7, r24	; 0x07
    889c:	80 91 a7 2e 	lds	r24, 0x2EA7	; 0x802ea7 <__bss_end+0xdbe>
    88a0:	81 30       	cpi	r24, 0x01	; 1
    88a2:	09 f0       	breq	.+2      	; 0x88a6 <sboxnet_timer_bit+0x18>
    88a4:	5c c0       	rjmp	.+184    	; 0x895e <sboxnet_timer_bit+0xd0>
    88a6:	80 91 ab 2e 	lds	r24, 0x2EAB	; 0x802eab <__bss_end+0xdc2>
    88aa:	88 23       	and	r24, r24
    88ac:	09 f4       	brne	.+2      	; 0x88b0 <sboxnet_timer_bit+0x22>
    88ae:	54 c0       	rjmp	.+168    	; 0x8958 <sboxnet_timer_bit+0xca>
    88b0:	80 91 aa 2e 	lds	r24, 0x2EAA	; 0x802eaa <__bss_end+0xdc1>
    88b4:	81 11       	cpse	r24, r1
    88b6:	50 c0       	rjmp	.+160    	; 0x8958 <sboxnet_timer_bit+0xca>
    88b8:	e4 e4       	ldi	r30, 0x44	; 68
    88ba:	ff e2       	ldi	r31, 0x2F	; 47
    88bc:	96 81       	ldd	r25, Z+6	; 0x06
    88be:	81 81       	ldd	r24, Z+1	; 0x01
    88c0:	89 17       	cp	r24, r25
    88c2:	38 f4       	brcc	.+14     	; 0x88d2 <sboxnet_timer_bit+0x44>
    88c4:	e0 91 44 2f 	lds	r30, 0x2F44	; 0x802f44 <__bss_end+0xe5b>
    88c8:	f0 e0       	ldi	r31, 0x00	; 0
    88ca:	ec 5b       	subi	r30, 0xBC	; 188
    88cc:	f0 4d       	sbci	r31, 0xD0	; 208
    88ce:	c0 85       	ldd	r28, Z+8	; 0x08
    88d0:	06 c0       	rjmp	.+12     	; 0x88de <sboxnet_timer_bit+0x50>
    88d2:	e7 ea       	ldi	r30, 0xA7	; 167
    88d4:	fe e2       	ldi	r31, 0x2E	; 46
    88d6:	81 81       	ldd	r24, Z+1	; 0x01
    88d8:	82 60       	ori	r24, 0x02	; 2
    88da:	81 83       	std	Z+1, r24	; 0x01
    88dc:	c0 e0       	ldi	r28, 0x00	; 0
    88de:	88 e0       	ldi	r24, 0x08	; 8
    88e0:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x7f7685>
    88e4:	e0 ea       	ldi	r30, 0xA0	; 160
    88e6:	fa e0       	ldi	r31, 0x0A	; 10
    88e8:	84 81       	ldd	r24, Z+4	; 0x04
    88ea:	89 60       	ori	r24, 0x09	; 9
    88ec:	84 83       	std	Z+4, r24	; 0x04
    88ee:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <__TEXT_REGION_LENGTH__+0x7f768c>
    88f2:	80 fd       	sbrc	r24, 0
    88f4:	04 c0       	rjmp	.+8      	; 0x88fe <sboxnet_timer_bit+0x70>
    88f6:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x7f7688>
    88fa:	82 fd       	sbrc	r24, 2
    88fc:	0e c0       	rjmp	.+28     	; 0x891a <sboxnet_timer_bit+0x8c>
    88fe:	0e 94 38 41 	call	0x8270	; 0x8270 <sboxnet_prandom>
    8902:	8f 77       	andi	r24, 0x7F	; 127
    8904:	20 91 a9 2e 	lds	r18, 0x2EA9	; 0x802ea9 <__bss_end+0xdc0>
    8908:	90 e0       	ldi	r25, 0x00	; 0
    890a:	38 e0       	ldi	r19, 0x08	; 8
    890c:	23 9f       	mul	r18, r19
    890e:	80 0d       	add	r24, r0
    8910:	91 1d       	adc	r25, r1
    8912:	11 24       	eor	r1, r1
    8914:	0e 94 34 42 	call	0x8468	; 0x8468 <sboxnet_set_backoff_with_offset>
    8918:	4a c0       	rjmp	.+148    	; 0x89ae <sboxnet_timer_bit+0x120>
    891a:	e0 ea       	ldi	r30, 0xA0	; 160
    891c:	fa e0       	ldi	r31, 0x0A	; 10
    891e:	84 81       	ldd	r24, Z+4	; 0x04
    8920:	8f 7e       	andi	r24, 0xEF	; 239
    8922:	84 83       	std	Z+4, r24	; 0x04
    8924:	83 81       	ldd	r24, Z+3	; 0x03
    8926:	83 7c       	andi	r24, 0xC3	; 195
    8928:	83 83       	std	Z+3, r24	; 0x03
    892a:	84 81       	ldd	r24, Z+4	; 0x04
    892c:	80 61       	ori	r24, 0x10	; 16
    892e:	84 83       	std	Z+4, r24	; 0x04
    8930:	83 81       	ldd	r24, Z+3	; 0x03
    8932:	88 60       	ori	r24, 0x08	; 8
    8934:	83 83       	std	Z+3, r24	; 0x03
    8936:	c0 83       	st	Z, r28
    8938:	84 81       	ldd	r24, Z+4	; 0x04
    893a:	8d 7f       	andi	r24, 0xFD	; 253
    893c:	84 83       	std	Z+4, r24	; 0x04
    893e:	84 e4       	ldi	r24, 0x44	; 68
    8940:	9f e2       	ldi	r25, 0x2F	; 47
    8942:	0e 94 7f 41 	call	0x82fe	; 0x82fe <sboxnet_rb_read>
    8946:	e7 ea       	ldi	r30, 0xA7	; 167
    8948:	fe e2       	ldi	r31, 0x2E	; 46
    894a:	c5 83       	std	Z+5, r28	; 0x05
    894c:	83 81       	ldd	r24, Z+3	; 0x03
    894e:	8f 5f       	subi	r24, 0xFF	; 255
    8950:	83 83       	std	Z+3, r24	; 0x03
    8952:	83 e0       	ldi	r24, 0x03	; 3
    8954:	80 83       	st	Z, r24
    8956:	2b c0       	rjmp	.+86     	; 0x89ae <sboxnet_timer_bit+0x120>
    8958:	10 92 a7 2e 	sts	0x2EA7, r1	; 0x802ea7 <__bss_end+0xdbe>
    895c:	28 c0       	rjmp	.+80     	; 0x89ae <sboxnet_timer_bit+0x120>
    895e:	82 30       	cpi	r24, 0x02	; 2
    8960:	71 f4       	brne	.+28     	; 0x897e <sboxnet_timer_bit+0xf0>
    8962:	c0 e8       	ldi	r28, 0x80	; 128
    8964:	d6 e0       	ldi	r29, 0x06	; 6
    8966:	88 e0       	ldi	r24, 0x08	; 8
    8968:	8d 83       	std	Y+5, r24	; 0x05
    896a:	84 e0       	ldi	r24, 0x04	; 4
    896c:	80 93 a7 2e 	sts	0x2EA7, r24	; 0x802ea7 <__bss_end+0xdbe>
    8970:	80 e8       	ldi	r24, 0x80	; 128
    8972:	90 e0       	ldi	r25, 0x00	; 0
    8974:	0e 94 21 42 	call	0x8442	; 0x8442 <sboxnet_set_timer>
    8978:	81 e0       	ldi	r24, 0x01	; 1
    897a:	8c 87       	std	Y+12, r24	; 0x0c
    897c:	18 c0       	rjmp	.+48     	; 0x89ae <sboxnet_timer_bit+0x120>
    897e:	84 30       	cpi	r24, 0x04	; 4
    8980:	b1 f4       	brne	.+44     	; 0x89ae <sboxnet_timer_bit+0x120>
    8982:	80 91 8c 06 	lds	r24, 0x068C	; 0x80068c <__TEXT_REGION_LENGTH__+0x7f768c>
    8986:	80 fd       	sbrc	r24, 0
    8988:	0b c0       	rjmp	.+22     	; 0x89a0 <sboxnet_timer_bit+0x112>
    898a:	80 91 88 06 	lds	r24, 0x0688	; 0x800688 <__TEXT_REGION_LENGTH__+0x7f7688>
    898e:	82 ff       	sbrs	r24, 2
    8990:	07 c0       	rjmp	.+14     	; 0x89a0 <sboxnet_timer_bit+0x112>
    8992:	0e 94 be 41 	call	0x837c	; 0x837c <sboxnet_receiver_enable>
    8996:	10 92 a7 2e 	sts	0x2EA7, r1	; 0x802ea7 <__bss_end+0xdbe>
    899a:	0e 94 14 43 	call	0x8628	; 0x8628 <sboxnet_check_try_transmit>
    899e:	07 c0       	rjmp	.+14     	; 0x89ae <sboxnet_timer_bit+0x120>
    89a0:	81 e0       	ldi	r24, 0x01	; 1
    89a2:	80 93 8c 06 	sts	0x068C, r24	; 0x80068c <__TEXT_REGION_LENGTH__+0x7f768c>
    89a6:	80 e8       	ldi	r24, 0x80	; 128
    89a8:	90 e0       	ldi	r25, 0x00	; 0
    89aa:	0e 94 21 42 	call	0x8442	; 0x8442 <sboxnet_set_timer>
    89ae:	df 91       	pop	r29
    89b0:	cf 91       	pop	r28
    89b2:	08 95       	ret

000089b4 <sboxnet_receive_msg>:
    89b4:	cf 92       	push	r12
    89b6:	df 92       	push	r13
    89b8:	ef 92       	push	r14
    89ba:	ff 92       	push	r15
    89bc:	0f 93       	push	r16
    89be:	1f 93       	push	r17
    89c0:	cf 93       	push	r28
    89c2:	df 93       	push	r29
    89c4:	8c 01       	movw	r16, r24
    89c6:	66 30       	cpi	r22, 0x06	; 6
    89c8:	08 f4       	brcc	.+2      	; 0x89cc <sboxnet_receive_msg+0x18>
    89ca:	72 c0       	rjmp	.+228    	; 0x8ab0 <sboxnet_receive_msg+0xfc>
    89cc:	8f b7       	in	r24, 0x3f	; 63
    89ce:	f8 94       	cli
    89d0:	e7 ea       	ldi	r30, 0xA7	; 167
    89d2:	fe e2       	ldi	r31, 0x2E	; 46
    89d4:	27 85       	ldd	r18, Z+15	; 0x0f
    89d6:	92 85       	ldd	r25, Z+10	; 0x0a
    89d8:	32 2f       	mov	r19, r18
    89da:	39 1b       	sub	r19, r25
    89dc:	37 30       	cpi	r19, 0x07	; 7
    89de:	08 f4       	brcc	.+2      	; 0x89e2 <sboxnet_receive_msg+0x2e>
    89e0:	71 c0       	rjmp	.+226    	; 0x8ac4 <sboxnet_receive_msg+0x110>
    89e2:	92 17       	cp	r25, r18
    89e4:	38 f4       	brcc	.+14     	; 0x89f4 <sboxnet_receive_msg+0x40>
    89e6:	e0 91 b0 2e 	lds	r30, 0x2EB0	; 0x802eb0 <__bss_end+0xdc7>
    89ea:	f0 e0       	ldi	r31, 0x00	; 0
    89ec:	e9 55       	subi	r30, 0x59	; 89
    89ee:	f1 4d       	sbci	r31, 0xD1	; 209
    89f0:	c1 89       	ldd	r28, Z+17	; 0x11
    89f2:	69 c0       	rjmp	.+210    	; 0x8ac6 <sboxnet_receive_msg+0x112>
    89f4:	e7 ea       	ldi	r30, 0xA7	; 167
    89f6:	fe e2       	ldi	r31, 0x2E	; 46
    89f8:	91 81       	ldd	r25, Z+1	; 0x01
    89fa:	92 60       	ori	r25, 0x02	; 2
    89fc:	91 83       	std	Z+1, r25	; 0x01
    89fe:	c0 e0       	ldi	r28, 0x00	; 0
    8a00:	62 c0       	rjmp	.+196    	; 0x8ac6 <sboxnet_receive_msg+0x112>
    8a02:	4c 2f       	mov	r20, r28
    8a04:	50 e0       	ldi	r21, 0x00	; 0
    8a06:	4f 5f       	subi	r20, 0xFF	; 255
    8a08:	5f 4f       	sbci	r21, 0xFF	; 255
    8a0a:	83 2f       	mov	r24, r19
    8a0c:	90 e0       	ldi	r25, 0x00	; 0
    8a0e:	84 17       	cp	r24, r20
    8a10:	95 07       	cpc	r25, r21
    8a12:	0c f4       	brge	.+2      	; 0x8a16 <sboxnet_receive_msg+0x62>
    8a14:	4f c0       	rjmp	.+158    	; 0x8ab4 <sboxnet_receive_msg+0x100>
    8a16:	6c 17       	cp	r22, r28
    8a18:	08 f4       	brcc	.+2      	; 0x8a1c <sboxnet_receive_msg+0x68>
    8a1a:	4e c0       	rjmp	.+156    	; 0x8ab8 <sboxnet_receive_msg+0x104>
    8a1c:	c6 34       	cpi	r28, 0x46	; 70
    8a1e:	08 f0       	brcs	.+2      	; 0x8a22 <sboxnet_receive_msg+0x6e>
    8a20:	4d c0       	rjmp	.+154    	; 0x8abc <sboxnet_receive_msg+0x108>
    8a22:	df b7       	in	r29, 0x3f	; 63
    8a24:	f8 94       	cli
    8a26:	0f 2e       	mov	r0, r31
    8a28:	f0 eb       	ldi	r31, 0xB0	; 176
    8a2a:	cf 2e       	mov	r12, r31
    8a2c:	fe e2       	ldi	r31, 0x2E	; 46
    8a2e:	df 2e       	mov	r13, r31
    8a30:	f0 2d       	mov	r31, r0
    8a32:	80 eb       	ldi	r24, 0xB0	; 176
    8a34:	9e e2       	ldi	r25, 0x2E	; 46
    8a36:	0e 94 7f 41 	call	0x82fe	; 0x82fe <sboxnet_rb_read>
    8a3a:	df bf       	out	0x3f, r29	; 63
    8a3c:	cc 23       	and	r28, r28
    8a3e:	d1 f0       	breq	.+52     	; 0x8a74 <sboxnet_receive_msg+0xc0>
    8a40:	f1 2c       	mov	r15, r1
    8a42:	df ef       	ldi	r29, 0xFF	; 255
    8a44:	ef b6       	in	r14, 0x3f	; 63
    8a46:	f8 94       	cli
    8a48:	c6 01       	movw	r24, r12
    8a4a:	0e 94 7f 41 	call	0x82fe	; 0x82fe <sboxnet_rb_read>
    8a4e:	ef be       	out	0x3f, r14	; 63
    8a50:	9d 2f       	mov	r25, r29
    8a52:	98 27       	eor	r25, r24
    8a54:	28 e0       	ldi	r18, 0x08	; 8
    8a56:	3c e8       	ldi	r19, 0x8C	; 140
    8a58:	96 95       	lsr	r25
    8a5a:	08 f4       	brcc	.+2      	; 0x8a5e <sboxnet_receive_msg+0xaa>
    8a5c:	93 27       	eor	r25, r19
    8a5e:	2a 95       	dec	r18
    8a60:	d9 f7       	brne	.-10     	; 0x8a58 <sboxnet_receive_msg+0xa4>
    8a62:	d9 2f       	mov	r29, r25
    8a64:	f8 01       	movw	r30, r16
    8a66:	80 83       	st	Z, r24
    8a68:	f3 94       	inc	r15
    8a6a:	0f 5f       	subi	r16, 0xFF	; 255
    8a6c:	1f 4f       	sbci	r17, 0xFF	; 255
    8a6e:	fc 16       	cp	r15, r28
    8a70:	48 f3       	brcs	.-46     	; 0x8a44 <sboxnet_receive_msg+0x90>
    8a72:	01 c0       	rjmp	.+2      	; 0x8a76 <sboxnet_receive_msg+0xc2>
    8a74:	df ef       	ldi	r29, 0xFF	; 255
    8a76:	1f b7       	in	r17, 0x3f	; 63
    8a78:	f8 94       	cli
    8a7a:	80 eb       	ldi	r24, 0xB0	; 176
    8a7c:	9e e2       	ldi	r25, 0x2E	; 46
    8a7e:	0e 94 69 41 	call	0x82d2	; 0x82d2 <sboxnet_rb_read_commit>
    8a82:	1f bf       	out	0x3f, r17	; 63
    8a84:	dd 23       	and	r29, r29
    8a86:	59 f0       	breq	.+22     	; 0x8a9e <sboxnet_receive_msg+0xea>
    8a88:	0e 94 20 41 	call	0x8240	; 0x8240 <sboxnet_debug_inc_recverrors>
    8a8c:	ea ef       	ldi	r30, 0xFA	; 250
    8a8e:	ff e2       	ldi	r31, 0x2F	; 47
    8a90:	80 81       	ld	r24, Z
    8a92:	91 81       	ldd	r25, Z+1	; 0x01
    8a94:	01 96       	adiw	r24, 0x01	; 1
    8a96:	80 83       	st	Z, r24
    8a98:	91 83       	std	Z+1, r25	; 0x01
    8a9a:	8e ef       	ldi	r24, 0xFE	; 254
    8a9c:	19 c0       	rjmp	.+50     	; 0x8ad0 <sboxnet_receive_msg+0x11c>
    8a9e:	ec ed       	ldi	r30, 0xDC	; 220
    8aa0:	ff e2       	ldi	r31, 0x2F	; 47
    8aa2:	80 81       	ld	r24, Z
    8aa4:	91 81       	ldd	r25, Z+1	; 0x01
    8aa6:	01 96       	adiw	r24, 0x01	; 1
    8aa8:	80 83       	st	Z, r24
    8aaa:	91 83       	std	Z+1, r25	; 0x01
    8aac:	8c 2f       	mov	r24, r28
    8aae:	10 c0       	rjmp	.+32     	; 0x8ad0 <sboxnet_receive_msg+0x11c>
    8ab0:	8d ef       	ldi	r24, 0xFD	; 253
    8ab2:	0e c0       	rjmp	.+28     	; 0x8ad0 <sboxnet_receive_msg+0x11c>
    8ab4:	8f ef       	ldi	r24, 0xFF	; 255
    8ab6:	0c c0       	rjmp	.+24     	; 0x8ad0 <sboxnet_receive_msg+0x11c>
    8ab8:	8d ef       	ldi	r24, 0xFD	; 253
    8aba:	0a c0       	rjmp	.+20     	; 0x8ad0 <sboxnet_receive_msg+0x11c>
    8abc:	8c ef       	ldi	r24, 0xFC	; 252
    8abe:	08 c0       	rjmp	.+16     	; 0x8ad0 <sboxnet_receive_msg+0x11c>
    8ac0:	8f ef       	ldi	r24, 0xFF	; 255
    8ac2:	06 c0       	rjmp	.+12     	; 0x8ad0 <sboxnet_receive_msg+0x11c>
    8ac4:	c0 e0       	ldi	r28, 0x00	; 0
    8ac6:	8f bf       	out	0x3f, r24	; 63
    8ac8:	c6 30       	cpi	r28, 0x06	; 6
    8aca:	08 f0       	brcs	.+2      	; 0x8ace <sboxnet_receive_msg+0x11a>
    8acc:	9a cf       	rjmp	.-204    	; 0x8a02 <sboxnet_receive_msg+0x4e>
    8ace:	f8 cf       	rjmp	.-16     	; 0x8ac0 <sboxnet_receive_msg+0x10c>
    8ad0:	df 91       	pop	r29
    8ad2:	cf 91       	pop	r28
    8ad4:	1f 91       	pop	r17
    8ad6:	0f 91       	pop	r16
    8ad8:	ff 90       	pop	r15
    8ada:	ef 90       	pop	r14
    8adc:	df 90       	pop	r13
    8ade:	cf 90       	pop	r12
    8ae0:	08 95       	ret

00008ae2 <sboxnet_send_msg>:
    8ae2:	bf 92       	push	r11
    8ae4:	cf 92       	push	r12
    8ae6:	df 92       	push	r13
    8ae8:	ef 92       	push	r14
    8aea:	ff 92       	push	r15
    8aec:	0f 93       	push	r16
    8aee:	1f 93       	push	r17
    8af0:	cf 93       	push	r28
    8af2:	df 93       	push	r29
    8af4:	6c 01       	movw	r12, r24
    8af6:	fc 01       	movw	r30, r24
    8af8:	c3 81       	ldd	r28, Z+3	; 0x03
    8afa:	cf 73       	andi	r28, 0x3F	; 63
    8afc:	ca 5f       	subi	r28, 0xFA	; 250
    8afe:	8f b7       	in	r24, 0x3f	; 63
    8b00:	f8 94       	cli
    8b02:	e4 e4       	ldi	r30, 0x44	; 68
    8b04:	ff e2       	ldi	r31, 0x2F	; 47
    8b06:	97 81       	ldd	r25, Z+7	; 0x07
    8b08:	26 81       	ldd	r18, Z+6	; 0x06
    8b0a:	92 1b       	sub	r25, r18
    8b0c:	24 81       	ldd	r18, Z+4	; 0x04
    8b0e:	92 1b       	sub	r25, r18
    8b10:	8f bf       	out	0x3f, r24	; 63
    8b12:	c9 17       	cp	r28, r25
    8b14:	18 f0       	brcs	.+6      	; 0x8b1c <sboxnet_send_msg+0x3a>
    8b16:	09 9a       	sbi	0x01, 1	; 1
    8b18:	82 e0       	ldi	r24, 0x02	; 2
    8b1a:	78 c0       	rjmp	.+240    	; 0x8c0c <sboxnet_send_msg+0x12a>
    8b1c:	df b7       	in	r29, 0x3f	; 63
    8b1e:	f8 94       	cli
    8b20:	04 e4       	ldi	r16, 0x44	; 68
    8b22:	1f e2       	ldi	r17, 0x2F	; 47
    8b24:	6c 2f       	mov	r22, r28
    8b26:	84 e4       	ldi	r24, 0x44	; 68
    8b28:	9f e2       	ldi	r25, 0x2F	; 47
    8b2a:	0e 94 47 41 	call	0x828e	; 0x828e <sboxnet_rb_write>
    8b2e:	df bf       	out	0x3f, r29	; 63
    8b30:	88 23       	and	r24, r24
    8b32:	09 f4       	brne	.+2      	; 0x8b36 <sboxnet_send_msg+0x54>
    8b34:	39 c0       	rjmp	.+114    	; 0x8ba8 <sboxnet_send_msg+0xc6>
    8b36:	ec 2e       	mov	r14, r28
    8b38:	f1 2c       	mov	r15, r1
    8b3a:	f1 e0       	ldi	r31, 0x01	; 1
    8b3c:	ef 1a       	sub	r14, r31
    8b3e:	f1 08       	sbc	r15, r1
    8b40:	1e 14       	cp	r1, r14
    8b42:	1f 04       	cpc	r1, r15
    8b44:	2c f5       	brge	.+74     	; 0x8b90 <sboxnet_send_msg+0xae>
    8b46:	b1 2c       	mov	r11, r1
    8b48:	cf ef       	ldi	r28, 0xFF	; 255
    8b4a:	81 e0       	ldi	r24, 0x01	; 1
    8b4c:	b8 12       	cpse	r11, r24
    8b4e:	03 c0       	rjmp	.+6      	; 0x8b56 <sboxnet_send_msg+0x74>
    8b50:	60 91 8b 2e 	lds	r22, 0x2E8B	; 0x802e8b <__bss_end+0xda2>
    8b54:	04 c0       	rjmp	.+8      	; 0x8b5e <sboxnet_send_msg+0x7c>
    8b56:	f6 01       	movw	r30, r12
    8b58:	eb 0d       	add	r30, r11
    8b5a:	f1 1d       	adc	r31, r1
    8b5c:	60 81       	ld	r22, Z
    8b5e:	9c 2f       	mov	r25, r28
    8b60:	96 27       	eor	r25, r22
    8b62:	88 e0       	ldi	r24, 0x08	; 8
    8b64:	2c e8       	ldi	r18, 0x8C	; 140
    8b66:	96 95       	lsr	r25
    8b68:	08 f4       	brcc	.+2      	; 0x8b6c <sboxnet_send_msg+0x8a>
    8b6a:	92 27       	eor	r25, r18
    8b6c:	8a 95       	dec	r24
    8b6e:	d9 f7       	brne	.-10     	; 0x8b66 <sboxnet_send_msg+0x84>
    8b70:	c9 2f       	mov	r28, r25
    8b72:	df b7       	in	r29, 0x3f	; 63
    8b74:	f8 94       	cli
    8b76:	c8 01       	movw	r24, r16
    8b78:	0e 94 47 41 	call	0x828e	; 0x828e <sboxnet_rb_write>
    8b7c:	df bf       	out	0x3f, r29	; 63
    8b7e:	88 23       	and	r24, r24
    8b80:	a9 f0       	breq	.+42     	; 0x8bac <sboxnet_send_msg+0xca>
    8b82:	b3 94       	inc	r11
    8b84:	8b 2d       	mov	r24, r11
    8b86:	90 e0       	ldi	r25, 0x00	; 0
    8b88:	8e 15       	cp	r24, r14
    8b8a:	9f 05       	cpc	r25, r15
    8b8c:	f4 f2       	brlt	.-68     	; 0x8b4a <sboxnet_send_msg+0x68>
    8b8e:	01 c0       	rjmp	.+2      	; 0x8b92 <sboxnet_send_msg+0xb0>
    8b90:	cf ef       	ldi	r28, 0xFF	; 255
    8b92:	df b7       	in	r29, 0x3f	; 63
    8b94:	f8 94       	cli
    8b96:	6c 2f       	mov	r22, r28
    8b98:	84 e4       	ldi	r24, 0x44	; 68
    8b9a:	9f e2       	ldi	r25, 0x2F	; 47
    8b9c:	0e 94 47 41 	call	0x828e	; 0x828e <sboxnet_rb_write>
    8ba0:	df bf       	out	0x3f, r29	; 63
    8ba2:	81 11       	cpse	r24, r1
    8ba4:	0d c0       	rjmp	.+26     	; 0x8bc0 <sboxnet_send_msg+0xde>
    8ba6:	03 c0       	rjmp	.+6      	; 0x8bae <sboxnet_send_msg+0xcc>
    8ba8:	83 e0       	ldi	r24, 0x03	; 3
    8baa:	01 c0       	rjmp	.+2      	; 0x8bae <sboxnet_send_msg+0xcc>
    8bac:	86 e0       	ldi	r24, 0x06	; 6
    8bae:	9f b7       	in	r25, 0x3f	; 63
    8bb0:	f8 94       	cli
    8bb2:	e4 e4       	ldi	r30, 0x44	; 68
    8bb4:	ff e2       	ldi	r31, 0x2F	; 47
    8bb6:	14 82       	std	Z+4, r1	; 0x04
    8bb8:	25 81       	ldd	r18, Z+5	; 0x05
    8bba:	23 83       	std	Z+3, r18	; 0x03
    8bbc:	9f bf       	out	0x3f, r25	; 63
    8bbe:	26 c0       	rjmp	.+76     	; 0x8c0c <sboxnet_send_msg+0x12a>
    8bc0:	cf b7       	in	r28, 0x3f	; 63
    8bc2:	f8 94       	cli
    8bc4:	e4 e4       	ldi	r30, 0x44	; 68
    8bc6:	ff e2       	ldi	r31, 0x2F	; 47
    8bc8:	86 81       	ldd	r24, Z+6	; 0x06
    8bca:	94 81       	ldd	r25, Z+4	; 0x04
    8bcc:	49 2f       	mov	r20, r25
    8bce:	50 e0       	ldi	r21, 0x00	; 0
    8bd0:	48 0f       	add	r20, r24
    8bd2:	51 1d       	adc	r21, r1
    8bd4:	27 81       	ldd	r18, Z+7	; 0x07
    8bd6:	30 e0       	ldi	r19, 0x00	; 0
    8bd8:	24 17       	cp	r18, r20
    8bda:	35 07       	cpc	r19, r21
    8bdc:	2c f4       	brge	.+10     	; 0x8be8 <sboxnet_send_msg+0x106>
    8bde:	e7 ea       	ldi	r30, 0xA7	; 167
    8be0:	fe e2       	ldi	r31, 0x2E	; 46
    8be2:	21 81       	ldd	r18, Z+1	; 0x01
    8be4:	24 60       	ori	r18, 0x04	; 4
    8be6:	21 83       	std	Z+1, r18	; 0x01
    8be8:	89 0f       	add	r24, r25
    8bea:	e4 e4       	ldi	r30, 0x44	; 68
    8bec:	ff e2       	ldi	r31, 0x2F	; 47
    8bee:	86 83       	std	Z+6, r24	; 0x06
    8bf0:	14 82       	std	Z+4, r1	; 0x04
    8bf2:	83 81       	ldd	r24, Z+3	; 0x03
    8bf4:	85 83       	std	Z+5, r24	; 0x05
    8bf6:	0e 94 14 43 	call	0x8628	; 0x8628 <sboxnet_check_try_transmit>
    8bfa:	cf bf       	out	0x3f, r28	; 63
    8bfc:	e0 ee       	ldi	r30, 0xE0	; 224
    8bfe:	ff e2       	ldi	r31, 0x2F	; 47
    8c00:	80 81       	ld	r24, Z
    8c02:	91 81       	ldd	r25, Z+1	; 0x01
    8c04:	01 96       	adiw	r24, 0x01	; 1
    8c06:	80 83       	st	Z, r24
    8c08:	91 83       	std	Z+1, r25	; 0x01
    8c0a:	80 e0       	ldi	r24, 0x00	; 0
    8c0c:	df 91       	pop	r29
    8c0e:	cf 91       	pop	r28
    8c10:	1f 91       	pop	r17
    8c12:	0f 91       	pop	r16
    8c14:	ff 90       	pop	r15
    8c16:	ef 90       	pop	r14
    8c18:	df 90       	pop	r13
    8c1a:	cf 90       	pop	r12
    8c1c:	bf 90       	pop	r11
    8c1e:	08 95       	ret

00008c20 <bldr_start>:
    8c20:	a8 95       	wdr
    8c22:	88 ed       	ldi	r24, 0xD8	; 216
    8c24:	84 bf       	out	0x34, r24	; 52
    8c26:	21 e0       	ldi	r18, 0x01	; 1
    8c28:	20 93 80 00 	sts	0x0080, r18	; 0x800080 <__TEXT_REGION_LENGTH__+0x7f7080>
    8c2c:	c0 e0       	ldi	r28, 0x00	; 0
    8c2e:	d6 e0       	ldi	r29, 0x06	; 6
    8c30:	18 82       	st	Y, r1
    8c32:	e0 eb       	ldi	r30, 0xB0	; 176
    8c34:	f0 e0       	ldi	r31, 0x00	; 0
    8c36:	8f ef       	ldi	r24, 0xFF	; 255
    8c38:	80 83       	st	Z, r24
    8c3a:	90 e1       	ldi	r25, 0x10	; 16
    8c3c:	98 8b       	std	Y+16, r25	; 0x10
    8c3e:	c0 e2       	ldi	r28, 0x20	; 32
    8c40:	d6 e0       	ldi	r29, 0x06	; 6
    8c42:	18 82       	st	Y, r1
    8c44:	80 83       	st	Z, r24
    8c46:	98 8b       	std	Y+16, r25	; 0x10
    8c48:	c0 e4       	ldi	r28, 0x40	; 64
    8c4a:	d6 e0       	ldi	r29, 0x06	; 6
    8c4c:	18 82       	st	Y, r1
    8c4e:	80 83       	st	Z, r24
    8c50:	98 8b       	std	Y+16, r25	; 0x10
    8c52:	c0 e6       	ldi	r28, 0x60	; 96
    8c54:	d6 e0       	ldi	r29, 0x06	; 6
    8c56:	18 82       	st	Y, r1
    8c58:	80 83       	st	Z, r24
    8c5a:	98 8b       	std	Y+16, r25	; 0x10
    8c5c:	c0 e8       	ldi	r28, 0x80	; 128
    8c5e:	d6 e0       	ldi	r29, 0x06	; 6
    8c60:	18 82       	st	Y, r1
    8c62:	80 83       	st	Z, r24
    8c64:	88 e1       	ldi	r24, 0x18	; 24
    8c66:	88 8b       	std	Y+16, r24	; 0x10
    8c68:	20 93 b2 00 	sts	0x00B2, r18	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7f70b2>
    8c6c:	83 e0       	ldi	r24, 0x03	; 3
    8c6e:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__TEXT_REGION_LENGTH__+0x7f70b3>
    8c72:	eb e8       	ldi	r30, 0x8B	; 139
    8c74:	fe e2       	ldi	r31, 0x2E	; 46
    8c76:	21 e0       	ldi	r18, 0x01	; 1
    8c78:	30 e0       	ldi	r19, 0x00	; 0
    8c7a:	22 8f       	std	Z+26, r18	; 0x1a
    8c7c:	33 8f       	std	Z+27, r19	; 0x1b
    8c7e:	89 83       	std	Y+1, r24	; 0x01
    8c80:	8e 83       	std	Y+6, r24	; 0x06
    8c82:	12 86       	std	Z+10, r1	; 0x0a
    8c84:	13 86       	std	Z+11, r1	; 0x0b
    8c86:	10 b8       	out	0x00, r1	; 0
    8c88:	11 b8       	out	0x01, r1	; 1
    8c8a:	12 b8       	out	0x02, r1	; 2
    8c8c:	e0 e5       	ldi	r30, 0x50	; 80
    8c8e:	f0 e0       	ldi	r31, 0x00	; 0
    8c90:	8b ec       	ldi	r24, 0xCB	; 203
    8c92:	82 83       	std	Z+2, r24	; 0x02
    8c94:	80 81       	ld	r24, Z
    8c96:	88 60       	ori	r24, 0x08	; 8
    8c98:	80 83       	st	Z, r24
    8c9a:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7f7051>
    8c9e:	83 fd       	sbrc	r24, 3
    8ca0:	05 c0       	rjmp	.+10     	; 0x8cac <bldr_start+0x8c>
    8ca2:	00 00       	nop
    8ca4:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7f7051>
    8ca8:	83 ff       	sbrs	r24, 3
    8caa:	fb cf       	rjmp	.-10     	; 0x8ca2 <bldr_start+0x82>
    8cac:	e0 e5       	ldi	r30, 0x50	; 80
    8cae:	f0 e0       	ldi	r31, 0x00	; 0
    8cb0:	82 ec       	ldi	r24, 0xC2	; 194
    8cb2:	85 83       	std	Z+5, r24	; 0x05
    8cb4:	80 81       	ld	r24, Z
    8cb6:	80 61       	ori	r24, 0x10	; 16
    8cb8:	80 83       	st	Z, r24
    8cba:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7f7051>
    8cbe:	84 fd       	sbrc	r24, 4
    8cc0:	05 c0       	rjmp	.+10     	; 0x8ccc <bldr_start+0xac>
    8cc2:	00 00       	nop
    8cc4:	80 91 51 00 	lds	r24, 0x0051	; 0x800051 <__TEXT_REGION_LENGTH__+0x7f7051>
    8cc8:	84 ff       	sbrs	r24, 4
    8cca:	fb cf       	rjmp	.-10     	; 0x8cc2 <bldr_start+0xa2>
    8ccc:	88 ed       	ldi	r24, 0xD8	; 216
    8cce:	84 bf       	out	0x34, r24	; 52
    8cd0:	84 e0       	ldi	r24, 0x04	; 4
    8cd2:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7f7040>
    8cd6:	e0 e5       	ldi	r30, 0x50	; 80
    8cd8:	f0 e0       	ldi	r31, 0x00	; 0
    8cda:	80 81       	ld	r24, Z
    8cdc:	8e 7f       	andi	r24, 0xFE	; 254
    8cde:	80 83       	st	Z, r24
    8ce0:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8ce4:	88 23       	and	r24, r24
    8ce6:	e4 f3       	brlt	.-8      	; 0x8ce0 <bldr_start+0xc0>
    8ce8:	ec ec       	ldi	r30, 0xCC	; 204
    8cea:	f1 e0       	ldi	r31, 0x01	; 1
    8cec:	80 81       	ld	r24, Z
    8cee:	88 60       	ori	r24, 0x08	; 8
    8cf0:	80 83       	st	Z, r24
    8cf2:	80 91 01 13 	lds	r24, 0x1301	; 0x801301 <__TEXT_REGION_LENGTH__+0x7f8301>
    8cf6:	90 91 02 13 	lds	r25, 0x1302	; 0x801302 <__TEXT_REGION_LENGTH__+0x7f8302>
    8cfa:	a0 91 03 13 	lds	r26, 0x1303	; 0x801303 <__TEXT_REGION_LENGTH__+0x7f8303>
    8cfe:	b0 91 04 13 	lds	r27, 0x1304	; 0x801304 <__TEXT_REGION_LENGTH__+0x7f8304>
    8d02:	cb e8       	ldi	r28, 0x8B	; 139
    8d04:	de e2       	ldi	r29, 0x2E	; 46
    8d06:	89 83       	std	Y+1, r24	; 0x01
    8d08:	9a 83       	std	Y+2, r25	; 0x02
    8d0a:	ab 83       	std	Y+3, r26	; 0x03
    8d0c:	bc 83       	std	Y+4, r27	; 0x04
    8d0e:	2f ef       	ldi	r18, 0xFF	; 255
    8d10:	28 83       	st	Y, r18
    8d12:	18 8a       	std	Y+16, r1	; 0x10
    8d14:	19 8a       	std	Y+17, r1	; 0x11
    8d16:	1a 8a       	std	Y+18, r1	; 0x12
    8d18:	1b 8a       	std	Y+19, r1	; 0x13
    8d1a:	1c 8a       	std	Y+20, r1	; 0x14
    8d1c:	1d 8a       	std	Y+21, r1	; 0x15
    8d1e:	88 8f       	std	Y+24, r24	; 0x18
    8d20:	99 8f       	std	Y+25, r25	; 0x19
    8d22:	0e 94 9d 41 	call	0x833a	; 0x833a <bldr_random>
    8d26:	8d 83       	std	Y+5, r24	; 0x05
    8d28:	1f 82       	std	Y+7, r1	; 0x07
    8d2a:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8d2e:	88 23       	and	r24, r24
    8d30:	e4 f3       	brlt	.-8      	; 0x8d2a <bldr_start+0x10a>
    8d32:	ec ec       	ldi	r30, 0xCC	; 204
    8d34:	f1 e0       	ldi	r31, 0x01	; 1
    8d36:	80 81       	ld	r24, Z
    8d38:	88 60       	ori	r24, 0x08	; 8
    8d3a:	80 83       	st	Z, r24
    8d3c:	80 91 00 13 	lds	r24, 0x1300	; 0x801300 <__TEXT_REGION_LENGTH__+0x7f8300>
    8d40:	81 11       	cpse	r24, r1
    8d42:	07 c0       	rjmp	.+14     	; 0x8d52 <bldr_start+0x132>
    8d44:	88 ed       	ldi	r24, 0xD8	; 216
    8d46:	84 bf       	out	0x34, r24	; 52
    8d48:	87 e0       	ldi	r24, 0x07	; 7
    8d4a:	80 93 a2 00 	sts	0x00A2, r24	; 0x8000a2 <__TEXT_REGION_LENGTH__+0x7f70a2>
    8d4e:	0c 94 00 00 	jmp	0	; 0x0 <__TEXT_REGION_ORIGIN__>
    8d52:	81 e0       	ldi	r24, 0x01	; 1
    8d54:	0e 94 a7 39 	call	0x734e	; 0x734e <bldr_main>

Disassembly of section .bldrstatic:

00008e00 <xsbldr_prog_page>:
    )
/* uint8_t xsbldr_prog_page(uint16_t pageaddr, uint8_t *srcbuf, uint8_t fromflash)
 * Flash Seite programmieren
 */
BLDR_STATIC_SECTION __ATTR_USED NOINLINE
static uint8_t xsbldr_prog_page(uint16_t pageaddr, uint8_t *srcbuf, uint8_t fromflash) {
    8e00:	cf 92       	push	r12
    8e02:	df 92       	push	r13
    8e04:	ef 92       	push	r14
    8e06:	ff 92       	push	r15
    8e08:	1f 93       	push	r17
    8e0a:	cf 93       	push	r28
    8e0c:	df 93       	push	r29
    8e0e:	7c 01       	movw	r14, r24
    8e10:	6b 01       	movw	r12, r22
    nvmc_wait_busy();
    8e12:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8e16:	99 23       	and	r25, r25
    8e18:	e4 f3       	brlt	.-8      	; 0x8e12 <xsbldr_prog_page+0x12>
    pageaddr &= ~(SPM_PAGESIZE-1);
    8e1a:	ee 24       	eor	r14, r14

    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    8e1c:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    8e1e:	f8 94       	cli
        NVM.CMD = NVM_CMD_ERASE_FLASH_BUFFER_gc;
    8e20:	c0 ec       	ldi	r28, 0xC0	; 192
    8e22:	d1 e0       	ldi	r29, 0x01	; 1
    8e24:	96 e2       	ldi	r25, 0x26	; 38
    8e26:	9a 87       	std	Y+10, r25	; 0x0a
        xsbldr_cmdex(pageaddr);
    8e28:	61 e0       	ldi	r22, 0x01	; 1
    8e2a:	70 e0       	ldi	r23, 0x00	; 0
    8e2c:	28 ed       	ldi	r18, 0xD8	; 216
    8e2e:	30 e0       	ldi	r19, 0x00	; 0
    8e30:	f7 01       	movw	r30, r14
    8e32:	24 bf       	out	0x34, r18	; 52
    8e34:	60 93 cb 01 	sts	0x01CB, r22	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7f71cb>
        NVM.CMD = NVM_CMD_NO_OPERATION_gc;
    8e38:	1a 86       	std	Y+10, r1	; 0x0a
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    8e3a:	8f bf       	out	0x3f, r24	; 63
    }
    nvmc_wait_busy();
    8e3c:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8e40:	88 23       	and	r24, r24
    8e42:	e4 f3       	brlt	.-8      	; 0x8e3c <xsbldr_prog_page+0x3c>
    8e44:	20 e0       	ldi	r18, 0x00	; 0
    8e46:	30 e0       	ldi	r19, 0x00	; 0
    
    for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
    {
        // Set up little-endian word.
        uint16_t w;
        if (fromflash) {
    8e48:	44 23       	and	r20, r20
    8e4a:	41 f0       	breq	.+16     	; 0x8e5c <xsbldr_prog_page+0x5c>
            w = pgm_read_word((uint16_t)srcbuf + i);
    8e4c:	f6 01       	movw	r30, r12
    8e4e:	e2 0f       	add	r30, r18
    8e50:	f3 1f       	adc	r31, r19
    8e52:	85 91       	lpm	r24, Z+
    8e54:	94 91       	lpm	r25, Z
    8e56:	78 2f       	mov	r23, r24
    8e58:	19 2f       	mov	r17, r25
    8e5a:	05 c0       	rjmp	.+10     	; 0x8e66 <xsbldr_prog_page+0x66>
        } else {
            w = *(uint16_t*)(srcbuf + i);
    8e5c:	f6 01       	movw	r30, r12
    8e5e:	e2 0f       	add	r30, r18
    8e60:	f3 1f       	adc	r31, r19
    8e62:	70 81       	ld	r23, Z
    8e64:	11 81       	ldd	r17, Z+1	; 0x01
        }
        
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    8e66:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    8e68:	f8 94       	cli
            NVM.CMD = NVM_CMD_LOAD_FLASH_BUFFER_gc;
    8e6a:	c0 ec       	ldi	r28, 0xC0	; 192
    8e6c:	d1 e0       	ldi	r29, 0x01	; 1
    8e6e:	53 e2       	ldi	r21, 0x23	; 35
    8e70:	5a 87       	std	Y+10, r21	; 0x0a
            xsbldr_spm_word(pageaddr + i, w);
    8e72:	f7 01       	movw	r30, r14
    8e74:	e2 0f       	add	r30, r18
    8e76:	f3 1f       	adc	r31, r19
    8e78:	ad e9       	ldi	r26, 0x9D	; 157
    8e7a:	b0 e0       	ldi	r27, 0x00	; 0
    8e7c:	07 2e       	mov	r0, r23
    8e7e:	11 2e       	mov	r1, r17
    8e80:	a4 bf       	out	0x34, r26	; 52
    8e82:	e8 95       	spm
    8e84:	11 24       	eor	r1, r1
            NVM.CMD = NVM_CMD_NO_OPERATION_gc;
    8e86:	1a 86       	std	Y+10, r1	; 0x0a
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    8e88:	9f bf       	out	0x3f, r25	; 63
        xsbldr_cmdex(pageaddr);
        NVM.CMD = NVM_CMD_NO_OPERATION_gc;
    }
    nvmc_wait_busy();
    
    for (uint16_t i = 0; i < SPM_PAGESIZE; i += 2)
    8e8a:	2e 5f       	subi	r18, 0xFE	; 254
    8e8c:	3f 4f       	sbci	r19, 0xFF	; 255
    8e8e:	2f 3f       	cpi	r18, 0xFF	; 255
    8e90:	31 05       	cpc	r19, r1
    8e92:	d1 f2       	breq	.-76     	; 0x8e48 <xsbldr_prog_page+0x48>
    8e94:	c8 f2       	brcs	.-78     	; 0x8e48 <xsbldr_prog_page+0x48>
            xsbldr_spm_word(pageaddr + i, w);
            NVM.CMD = NVM_CMD_NO_OPERATION_gc;
        }
    }
    
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    8e96:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    8e98:	f8 94       	cli
        if (pageaddr >= BOOT_SECTION_START) {
    8e9a:	ff 20       	and	r15, r15
    8e9c:	24 f4       	brge	.+8      	; 0x8ea6 <xsbldr_prog_page+0xa6>
            NVM.CMD = NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc;
    8e9e:	9d e2       	ldi	r25, 0x2D	; 45
    8ea0:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7f71ca>
    8ea4:	03 c0       	rjmp	.+6      	; 0x8eac <xsbldr_prog_page+0xac>
        } else {
            NVM.CMD = NVM_CMD_ERASE_WRITE_APP_PAGE_gc;
    8ea6:	95 e2       	ldi	r25, 0x25	; 37
    8ea8:	90 93 ca 01 	sts	0x01CA, r25	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7f71ca>
        }
        xsbldr_spm(pageaddr);
    8eac:	2d e9       	ldi	r18, 0x9D	; 157
    8eae:	30 e0       	ldi	r19, 0x00	; 0
    8eb0:	f7 01       	movw	r30, r14
    8eb2:	24 bf       	out	0x34, r18	; 52
    8eb4:	e8 95       	spm
        NVM.CMD = NVM_CMD_NO_OPERATION_gc;
    8eb6:	10 92 ca 01 	sts	0x01CA, r1	; 0x8001ca <__TEXT_REGION_LENGTH__+0x7f71ca>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    8eba:	8f bf       	out	0x3f, r24	; 63
    }
    nvmc_wait_busy();
    8ebc:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8ec0:	88 23       	and	r24, r24
    8ec2:	e4 f3       	brlt	.-8      	; 0x8ebc <xsbldr_prog_page+0xbc>
    8ec4:	80 e0       	ldi	r24, 0x00	; 0
    8ec6:	90 e0       	ldi	r25, 0x00	; 0
     
    // verify
    uint8_t ret = 0;
    for (uint16_t i = 0; i < SPM_PAGESIZE; i++, srcbuf++) {
        uint8_t v;
        if (fromflash) {
    8ec8:	44 23       	and	r20, r20
    8eca:	19 f0       	breq	.+6      	; 0x8ed2 <xsbldr_prog_page+0xd2>
            v = pgm_read_byte((uint16_t)srcbuf);
    8ecc:	f6 01       	movw	r30, r12
    8ece:	24 91       	lpm	r18, Z
    8ed0:	02 c0       	rjmp	.+4      	; 0x8ed6 <xsbldr_prog_page+0xd6>
        } else {
            v = *srcbuf;
    8ed2:	f6 01       	movw	r30, r12
    8ed4:	20 81       	ld	r18, Z
        }
        if (pgm_read_byte(pageaddr + i) != v) {
    8ed6:	f7 01       	movw	r30, r14
    8ed8:	e8 0f       	add	r30, r24
    8eda:	f9 1f       	adc	r31, r25
    8edc:	e4 91       	lpm	r30, Z
    8ede:	2e 13       	cpse	r18, r30
    8ee0:	0a c0       	rjmp	.+20     	; 0x8ef6 <xsbldr_prog_page+0xf6>
    }
    nvmc_wait_busy();
     
    // verify
    uint8_t ret = 0;
    for (uint16_t i = 0; i < SPM_PAGESIZE; i++, srcbuf++) {
    8ee2:	01 96       	adiw	r24, 0x01	; 1
    8ee4:	ff ef       	ldi	r31, 0xFF	; 255
    8ee6:	cf 1a       	sub	r12, r31
    8ee8:	df 0a       	sbc	r13, r31
    8eea:	8f 3f       	cpi	r24, 0xFF	; 255
    8eec:	91 05       	cpc	r25, r1
    8eee:	61 f3       	breq	.-40     	; 0x8ec8 <xsbldr_prog_page+0xc8>
    8ef0:	58 f3       	brcs	.-42     	; 0x8ec8 <xsbldr_prog_page+0xc8>
        NVM.CMD = NVM_CMD_NO_OPERATION_gc;
    }
    nvmc_wait_busy();
     
    // verify
    uint8_t ret = 0;
    8ef2:	80 e0       	ldi	r24, 0x00	; 0
    8ef4:	01 c0       	rjmp	.+2      	; 0x8ef8 <xsbldr_prog_page+0xf8>
            v = pgm_read_byte((uint16_t)srcbuf);
        } else {
            v = *srcbuf;
        }
        if (pgm_read_byte(pageaddr + i) != v) {
            ret = 1; // verify error
    8ef6:	81 e0       	ldi	r24, 0x01	; 1
            break;
        }
    }
    return ret;
}
    8ef8:	df 91       	pop	r29
    8efa:	cf 91       	pop	r28
    8efc:	1f 91       	pop	r17
    8efe:	ff 90       	pop	r15
    8f00:	ef 90       	pop	r14
    8f02:	df 90       	pop	r13
    8f04:	cf 90       	pop	r12
    8f06:	08 95       	ret

00008f08 <xsbldr_e2prom_write>:

/* void xsbldr_e2prom_write(uint8_t* addr, uint8_t v)
 * Ein Byte v in das EEPROM schreiben bei EEPROM Adresse addr
 */
BLDR_STATIC_SECTION __ATTR_USED NOINLINE
static void xsbldr_e2prom_write(uint8_t* addr, uint8_t v) {
    8f08:	9c 01       	movw	r18, r24
    e2prom_wait_busy();
    8f0a:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8f0e:	88 23       	and	r24, r24
    8f10:	e4 f3       	brlt	.-8      	; 0x8f0a <xsbldr_e2prom_write+0x2>
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    8f12:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    8f14:	f8 94       	cli
        if (e2prom_get_byte((uint16_t)addr) != v) {
    8f16:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8f1a:	99 23       	and	r25, r25
    8f1c:	e4 f3       	brlt	.-8      	; 0x8f16 <xsbldr_e2prom_write+0xe>
    8f1e:	ec ec       	ldi	r30, 0xCC	; 204
    8f20:	f1 e0       	ldi	r31, 0x01	; 1
    8f22:	90 81       	ld	r25, Z
    8f24:	98 60       	ori	r25, 0x08	; 8
    8f26:	90 83       	st	Z, r25
    8f28:	f9 01       	movw	r30, r18
    8f2a:	f0 5f       	subi	r31, 0xF0	; 240
    8f2c:	80 81       	ld	r24, Z
    8f2e:	86 17       	cp	r24, r22
    8f30:	01 f1       	breq	.+64     	; 0x8f72 <xsbldr_e2prom_write+0x6a>
            clrbit(NVM.CTRLB, NVM_EEMAPEN_bp);
    8f32:	e0 ec       	ldi	r30, 0xC0	; 192
    8f34:	f1 e0       	ldi	r31, 0x01	; 1
    8f36:	94 85       	ldd	r25, Z+12	; 0x0c
    8f38:	97 7f       	andi	r25, 0xF7	; 247
    8f3a:	94 87       	std	Z+12, r25	; 0x0c
            // erase eeprom page buffer
            NVM.CMD = NVM_CMD_ERASE_EEPROM_BUFFER_gc;
    8f3c:	86 e3       	ldi	r24, 0x36	; 54
    8f3e:	82 87       	std	Z+10, r24	; 0x0a
            ioreg_ccp(&NVM.CTRLA, Bit(NVM_CMDEX_bp));
    8f40:	88 ed       	ldi	r24, 0xD8	; 216
    8f42:	84 bf       	out	0x34, r24	; 52
    8f44:	81 e0       	ldi	r24, 0x01	; 1
    8f46:	80 93 cb 01 	sts	0x01CB, r24	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7f71cb>
            nvmc_wait_busy();
    8f4a:	90 91 cf 01 	lds	r25, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8f4e:	99 23       	and	r25, r25
    8f50:	e4 f3       	brlt	.-8      	; 0x8f4a <xsbldr_e2prom_write+0x42>
            // load eeprom page buffer
            NVM.CMD = NVM_CMD_LOAD_EEPROM_BUFFER_gc;
    8f52:	e0 ec       	ldi	r30, 0xC0	; 192
    8f54:	f1 e0       	ldi	r31, 0x01	; 1
    8f56:	83 e3       	ldi	r24, 0x33	; 51
    8f58:	82 87       	std	Z+10, r24	; 0x0a
            NVM.ADDR0 = lowbyte((uint16_t)addr);
    8f5a:	20 83       	st	Z, r18
            NVM.ADDR1 = highbyte((uint16_t)addr);
    8f5c:	31 83       	std	Z+1, r19	; 0x01
            NVM.ADDR2 = 0;
    8f5e:	12 82       	std	Z+2, r1	; 0x02
            NVM.DATA0 = v;
    8f60:	64 83       	std	Z+4, r22	; 0x04
            // erase and write eeprom page
            NVM.CMD = NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc;
    8f62:	85 e3       	ldi	r24, 0x35	; 53
    8f64:	82 87       	std	Z+10, r24	; 0x0a
            ioreg_ccp(&NVM.CTRLA, Bit(NVM_CMDEX_bp));
    8f66:	88 ed       	ldi	r24, 0xD8	; 216
    8f68:	84 bf       	out	0x34, r24	; 52
    8f6a:	81 e0       	ldi	r24, 0x01	; 1
    8f6c:	80 93 cb 01 	sts	0x01CB, r24	; 0x8001cb <__TEXT_REGION_LENGTH__+0x7f71cb>
            
            NVM.CMD = NVM_CMD_NO_OPERATION_gc;
    8f70:	12 86       	std	Z+10, r1	; 0x0a
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    8f72:	4f bf       	out	0x3f, r20	; 63
        }
    }
    e2prom_wait_busy();
    8f74:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    8f78:	88 23       	and	r24, r24
    8f7a:	e4 f3       	brlt	.-8      	; 0x8f74 <xsbldr_e2prom_write+0x6c>
}
    8f7c:	08 95       	ret

00008f7e <xsbldr_finish_fwup>:

/* void xsbldr_finish_fwup(uint8_t isapp)
 * Firmware Update abschliessen und Reboot.
 */
BLDR_STATIC_SECTION __ATTR_NO_RETURN __ATTR_USED NOINLINE
static void xsbldr_finish_fwup(uint8_t isapp) {
    8f7e:	08 2f       	mov	r16, r24
    cli();
    8f80:	f8 94       	cli
    
    uint8_t verifyerr = 0;
    
    if (!isapp) {
    8f82:	81 11       	cpse	r24, r1
    8f84:	13 c0       	rjmp	.+38     	; 0x8fac <xsbldr_finish_fwup+0x2e>
    8f86:	e1 2c       	mov	r14, r1
    8f88:	f1 2c       	mov	r15, r1
    8f8a:	c0 e0       	ldi	r28, 0x00	; 0
    8f8c:	d0 e7       	ldi	r29, 0x70	; 112
    8f8e:	10 e0       	ldi	r17, 0x00	; 0
        uint16_t pageaddr = BLDR_START_ADDR;
        uint16_t srcaddr  = 0;
        while (pageaddr < BLDR_START_ADDR + BLDR_SIZE) {
            verifyerr |= sbldr_prog_page(pageaddr, (uint8_t*)srcaddr, 1);
    8f90:	41 e0       	ldi	r20, 0x01	; 1
    8f92:	b7 01       	movw	r22, r14
    8f94:	ce 01       	movw	r24, r28
    8f96:	0e 94 ff 47 	call	0x8ffe	; 0x8ffe <sbldr_prog_page>
    8f9a:	18 2b       	or	r17, r24
            pageaddr += SPM_PAGESIZE;
    8f9c:	d3 95       	inc	r29
            srcaddr  += SPM_PAGESIZE;
    8f9e:	f3 94       	inc	r15
    uint8_t verifyerr = 0;
    
    if (!isapp) {
        uint16_t pageaddr = BLDR_START_ADDR;
        uint16_t srcaddr  = 0;
        while (pageaddr < BLDR_START_ADDR + BLDR_SIZE) {
    8fa0:	c1 15       	cp	r28, r1
    8fa2:	8e e8       	ldi	r24, 0x8E	; 142
    8fa4:	d8 07       	cpc	r29, r24
    8fa6:	a0 f3       	brcs	.-24     	; 0x8f90 <xsbldr_finish_fwup+0x12>
            srcaddr  += SPM_PAGESIZE;
        }
    }
    
    uint8_t upd = 0xff;
    if (verifyerr) {
    8fa8:	11 11       	cpse	r17, r1
    8faa:	05 c0       	rjmp	.+10     	; 0x8fb6 <xsbldr_finish_fwup+0x38>
        upd = 0xfe;
    } else if (isapp) {
    8fac:	61 e0       	ldi	r22, 0x01	; 1
    8fae:	01 11       	cpse	r16, r1
    8fb0:	60 e0       	ldi	r22, 0x00	; 0
    8fb2:	61 95       	neg	r22
    8fb4:	01 c0       	rjmp	.+2      	; 0x8fb8 <xsbldr_finish_fwup+0x3a>
        }
    }
    
    uint8_t upd = 0xff;
    if (verifyerr) {
        upd = 0xfe;
    8fb6:	6e ef       	ldi	r22, 0xFE	; 254
    } else if (isapp) {
        upd = 0;
    }
    sbldr_e2prom_write(&bldr_eeprom.firmware_update, upd);
    8fb8:	80 e0       	ldi	r24, 0x00	; 0
    8fba:	93 e0       	ldi	r25, 0x03	; 3
    8fbc:	0e 94 fd 47 	call	0x8ffa	; 0x8ffa <sbldr_e2prom_write>
    
    // all done, reboot
    ioreg_ccp(&RST.CTRL, Bit(RST_SWRST_bp));
    8fc0:	88 ed       	ldi	r24, 0xD8	; 216
    8fc2:	84 bf       	out	0x34, r24	; 52
    8fc4:	81 e0       	ldi	r24, 0x01	; 1
    8fc6:	80 93 79 00 	sts	0x0079, r24	; 0x800079 <__TEXT_REGION_LENGTH__+0x7f7079>
    8fca:	ff cf       	rjmp	.-2      	; 0x8fca <xsbldr_finish_fwup+0x4c>

Disassembly of section .bldrstatvec:

00008ff8 <sbldr_static_vectors>:
 * - sbldr_finish_fwup -> xsbldr_finish_fwup
 * - sbldr_prog_page -> xsbldr_prog_page
 */
BLDR_STATVEC_SECTION __ATTR_NAKED __ATTR_USED
static void sbldr_static_vectors(void) {
    __asm__ __volatile__ (
    8ff8:	ff cf       	rjmp	.-2      	; 0x8ff8 <sbldr_static_vectors>

00008ffa <sbldr_e2prom_write>:
    8ffa:	86 cf       	rjmp	.-244    	; 0x8f08 <xsbldr_e2prom_write>

00008ffc <sbldr_finish_fwup>:
    8ffc:	c0 cf       	rjmp	.-128    	; 0x8f7e <xsbldr_finish_fwup>

00008ffe <sbldr_prog_page>:
    8ffe:	00 cf       	rjmp	.-512    	; 0x8e00 <xsbldr_prog_page>

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 03 01 	jmp	0x206	; 0x206 <__ctors_end>
       4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
       8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
       c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      10:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      14:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      18:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      1c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      20:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      24:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      28:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      2c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      30:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      34:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      38:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      3c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      40:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      44:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      48:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      4c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      50:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      54:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      58:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      5c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      60:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      64:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      68:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      6c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      70:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      74:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      78:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      7c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      80:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      84:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      88:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      8c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      90:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      94:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      98:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      9c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      a0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      a4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      a8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      ac:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      b0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      b4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      b8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      bc:	0c 94 20 3a 	jmp	0x7440	; 0x7440 <__vector_47>
      c0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      c4:	0c 94 fc 39 	jmp	0x73f8	; 0x73f8 <__vector_49>
      c8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      cc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      d0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      d4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      d8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      dc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      e0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      e4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      e8:	0c 94 ff 43 	jmp	0x87fe	; 0x87fe <__vector_58>
      ec:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      f0:	0c 94 23 44 	jmp	0x8846	; 0x8846 <__vector_60>
      f4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      f8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
      fc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     100:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     104:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     108:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     10c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     110:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     114:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     118:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     11c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     120:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     124:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     128:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     12c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     130:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     134:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     138:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     13c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     140:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     144:	0c 94 ce 04 	jmp	0x99c	; 0x99c <__vector_81>
     148:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     14c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     150:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     154:	0c 94 ad 03 	jmp	0x75a	; 0x75a <__vector_85>
     158:	0c 94 c6 01 	jmp	0x38c	; 0x38c <__vector_86>
     15c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     160:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     164:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     168:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     16c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     170:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     174:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     178:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     17c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     180:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     184:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     188:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     18c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     190:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     194:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     198:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     19c:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1a0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1a4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1a8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1ac:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1b0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1b4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1b8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1bc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1c0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1c4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1c8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1cc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1d0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1d4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1d8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1dc:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1e0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1e4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1e8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1ec:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1f0:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1f4:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>
     1f8:	0c 94 19 01 	jmp	0x232	; 0x232 <__bad_interrupt>

000001fc <__trampolines_end>:
     1fc:	67 62       	ori	r22, 0x27	; 39
     1fe:	6d 65       	ori	r22, 0x5D	; 93
     200:	6c 64       	ori	r22, 0x4C	; 76
     202:	65 72       	andi	r22, 0x25	; 37
     204:	32 00       	.word	0x0032	; ????

00000206 <__ctors_end>:
     206:	11 24       	eor	r1, r1
     208:	1f be       	out	0x3f, r1	; 63
     20a:	cf ef       	ldi	r28, 0xFF	; 255
     20c:	cd bf       	out	0x3d, r28	; 61
     20e:	df e2       	ldi	r29, 0x2F	; 47
     210:	de bf       	out	0x3e, r29	; 62

00000212 <com_init2>:
}

/* do_before_bldr_activate: Statements die vor der Aktivierung des Bootloaders ausgefhrt werden sollen
 * weak bound: Statements die vor der Aktivierung des Bootloaders ausgefhrt werden sollen
 */
__ATTR_WEAK void do_before_bldr_activate(void) {
     212:	8a e8       	ldi	r24, 0x8A	; 138
     214:	9e e2       	ldi	r25, 0x2E	; 46
     216:	8d bf       	out	0x3d, r24	; 61
     218:	9e bf       	out	0x3e, r25	; 62

0000021a <__do_clear_bss>:
     21a:	20 e2       	ldi	r18, 0x20	; 32
     21c:	a0 e0       	ldi	r26, 0x00	; 0
     21e:	b0 e2       	ldi	r27, 0x20	; 32
     220:	01 c0       	rjmp	.+2      	; 0x224 <.do_clear_bss_start>

00000222 <.do_clear_bss_loop>:
     222:	1d 92       	st	X+, r1

00000224 <.do_clear_bss_start>:
     224:	a9 3e       	cpi	r26, 0xE9	; 233
     226:	b2 07       	cpc	r27, r18
     228:	e1 f7       	brne	.-8      	; 0x222 <.do_clear_bss_loop>
     22a:	0e 94 0c 02 	call	0x418	; 0x418 <main>
     22e:	0c 94 ab 0a 	jmp	0x1556	; 0x1556 <_exit>

00000232 <__bad_interrupt>:
     232:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000236 <com_process_cmd_reset>:
     236:	8f b7       	in	r24, 0x3f	; 63
     238:	f8 94       	cli
     23a:	9f ef       	ldi	r25, 0xFF	; 255
     23c:	90 93 8b 2e 	sts	0x2E8B, r25	; 0x802e8b <__bss_end+0xda2>
     240:	03 9a       	sbi	0x00, 3	; 0
     242:	8f bf       	out	0x3f, r24	; 63
     244:	8f ef       	ldi	r24, 0xFF	; 255
     246:	08 95       	ret

00000248 <ringbuf_init>:
     248:	fc 01       	movw	r30, r24
     24a:	10 82       	st	Z, r1
     24c:	11 82       	std	Z+1, r1	; 0x01
     24e:	62 83       	std	Z+2, r22	; 0x02
     250:	13 82       	std	Z+3, r1	; 0x03
     252:	08 95       	ret

00000254 <ringbuf_read>:
     254:	cf 93       	push	r28
     256:	df 93       	push	r29
     258:	fc 01       	movw	r30, r24
     25a:	83 81       	ldd	r24, Z+3	; 0x03
     25c:	88 23       	and	r24, r24
     25e:	89 f0       	breq	.+34     	; 0x282 <ringbuf_read+0x2e>
     260:	9f ef       	ldi	r25, 0xFF	; 255
     262:	98 0f       	add	r25, r24
     264:	93 83       	std	Z+3, r25	; 0x03
     266:	80 81       	ld	r24, Z
     268:	ef 01       	movw	r28, r30
     26a:	c8 0f       	add	r28, r24
     26c:	d1 1d       	adc	r29, r1
     26e:	9c 81       	ldd	r25, Y+4	; 0x04
     270:	8f 5f       	subi	r24, 0xFF	; 255
     272:	80 83       	st	Z, r24
     274:	22 81       	ldd	r18, Z+2	; 0x02
     276:	82 17       	cp	r24, r18
     278:	18 f0       	brcs	.+6      	; 0x280 <ringbuf_read+0x2c>
     27a:	10 82       	st	Z, r1
     27c:	89 2f       	mov	r24, r25
     27e:	01 c0       	rjmp	.+2      	; 0x282 <ringbuf_read+0x2e>
     280:	89 2f       	mov	r24, r25
     282:	df 91       	pop	r29
     284:	cf 91       	pop	r28
     286:	08 95       	ret

00000288 <ringbuf_write>:
     288:	cf 93       	push	r28
     28a:	df 93       	push	r29
     28c:	fc 01       	movw	r30, r24
     28e:	83 81       	ldd	r24, Z+3	; 0x03
     290:	92 81       	ldd	r25, Z+2	; 0x02
     292:	89 17       	cp	r24, r25
     294:	68 f4       	brcc	.+26     	; 0x2b0 <ringbuf_write+0x28>
     296:	8f 5f       	subi	r24, 0xFF	; 255
     298:	83 83       	std	Z+3, r24	; 0x03
     29a:	81 81       	ldd	r24, Z+1	; 0x01
     29c:	ef 01       	movw	r28, r30
     29e:	c8 0f       	add	r28, r24
     2a0:	d1 1d       	adc	r29, r1
     2a2:	6c 83       	std	Y+4, r22	; 0x04
     2a4:	8f 5f       	subi	r24, 0xFF	; 255
     2a6:	89 17       	cp	r24, r25
     2a8:	10 f4       	brcc	.+4      	; 0x2ae <ringbuf_write+0x26>
     2aa:	81 83       	std	Z+1, r24	; 0x01
     2ac:	01 c0       	rjmp	.+2      	; 0x2b0 <ringbuf_write+0x28>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	df 91       	pop	r29
     2b2:	cf 91       	pop	r28
     2b4:	08 95       	ret

000002b6 <com_reg_read>:
     2b6:	0f 93       	push	r16
     2b8:	1f 93       	push	r17
     2ba:	cf 93       	push	r28
     2bc:	df 93       	push	r29
     2be:	86 3d       	cpi	r24, 0xD6	; 214
     2c0:	27 e0       	ldi	r18, 0x07	; 7
     2c2:	92 07       	cpc	r25, r18
     2c4:	81 f0       	breq	.+32     	; 0x2e6 <com_reg_read+0x30>
     2c6:	87 3d       	cpi	r24, 0xD7	; 215
     2c8:	a7 e0       	ldi	r26, 0x07	; 7
     2ca:	9a 07       	cpc	r25, r26
     2cc:	51 f5       	brne	.+84     	; 0x322 <com_reg_read+0x6c>
     2ce:	89 ee       	ldi	r24, 0xE9	; 233
     2d0:	90 e2       	ldi	r25, 0x20	; 32
     2d2:	8a 38       	cpi	r24, 0x8A	; 138
     2d4:	9e 42       	sbci	r25, 0x2E	; 46
     2d6:	c8 f4       	brcc	.+50     	; 0x30a <com_reg_read+0x54>
     2d8:	80 91 e9 20 	lds	r24, 0x20E9	; 0x8020e9 <__bss_end>
     2dc:	81 11       	cpse	r24, r1
     2de:	18 c0       	rjmp	.+48     	; 0x310 <com_reg_read+0x5a>
     2e0:	e9 ee       	ldi	r30, 0xE9	; 233
     2e2:	f0 e2       	ldi	r31, 0x20	; 32
     2e4:	0c c0       	rjmp	.+24     	; 0x2fe <com_reg_read+0x48>
     2e6:	8a e8       	ldi	r24, 0x8A	; 138
     2e8:	9e e2       	ldi	r25, 0x2E	; 46
     2ea:	89 5e       	subi	r24, 0xE9	; 233
     2ec:	90 42       	sbci	r25, 0x20	; 32
     2ee:	fb 01       	movw	r30, r22
     2f0:	80 83       	st	Z, r24
     2f2:	91 83       	std	Z+1, r25	; 0x01
     2f4:	80 e0       	ldi	r24, 0x00	; 0
     2f6:	45 c0       	rjmp	.+138    	; 0x382 <com_reg_read+0xcc>
     2f8:	80 81       	ld	r24, Z
     2fa:	81 11       	cpse	r24, r1
     2fc:	0b c0       	rjmp	.+22     	; 0x314 <com_reg_read+0x5e>
     2fe:	31 96       	adiw	r30, 0x01	; 1
     300:	ea 38       	cpi	r30, 0x8A	; 138
     302:	2e e2       	ldi	r18, 0x2E	; 46
     304:	f2 07       	cpc	r31, r18
     306:	c0 f3       	brcs	.-16     	; 0x2f8 <com_reg_read+0x42>
     308:	05 c0       	rjmp	.+10     	; 0x314 <com_reg_read+0x5e>
     30a:	e9 ee       	ldi	r30, 0xE9	; 233
     30c:	f0 e2       	ldi	r31, 0x20	; 32
     30e:	02 c0       	rjmp	.+4      	; 0x314 <com_reg_read+0x5e>
     310:	e9 ee       	ldi	r30, 0xE9	; 233
     312:	f0 e2       	ldi	r31, 0x20	; 32
     314:	e9 5e       	subi	r30, 0xE9	; 233
     316:	f0 42       	sbci	r31, 0x20	; 32
     318:	db 01       	movw	r26, r22
     31a:	ed 93       	st	X+, r30
     31c:	fc 93       	st	X, r31
     31e:	80 e0       	ldi	r24, 0x00	; 0
     320:	30 c0       	rjmp	.+96     	; 0x382 <com_reg_read+0xcc>
     322:	8b 01       	movw	r16, r22
     324:	ec 01       	movw	r28, r24
     326:	0e 94 06 41 	call	0x820c	; 0x820c <bldr_reg_read>
     32a:	88 23       	and	r24, r24
     32c:	49 f1       	breq	.+82     	; 0x380 <com_reg_read+0xca>
     32e:	cc 30       	cpi	r28, 0x0C	; 12
     330:	d1 05       	cpc	r29, r1
     332:	79 f0       	breq	.+30     	; 0x352 <com_reg_read+0x9c>
     334:	cd 30       	cpi	r28, 0x0D	; 13
     336:	d1 05       	cpc	r29, r1
     338:	a9 f0       	breq	.+42     	; 0x364 <com_reg_read+0xae>
     33a:	cb 30       	cpi	r28, 0x0B	; 11
     33c:	d1 05       	cpc	r29, r1
     33e:	d9 f4       	brne	.+54     	; 0x376 <com_reg_read+0xc0>
     340:	80 91 04 20 	lds	r24, 0x2004	; 0x802004 <__DATA_REGION_ORIGIN__+0x4>
     344:	90 91 05 20 	lds	r25, 0x2005	; 0x802005 <__DATA_REGION_ORIGIN__+0x5>
     348:	f8 01       	movw	r30, r16
     34a:	80 83       	st	Z, r24
     34c:	91 83       	std	Z+1, r25	; 0x01
     34e:	80 e0       	ldi	r24, 0x00	; 0
     350:	18 c0       	rjmp	.+48     	; 0x382 <com_reg_read+0xcc>
     352:	80 91 06 20 	lds	r24, 0x2006	; 0x802006 <__DATA_REGION_ORIGIN__+0x6>
     356:	90 91 07 20 	lds	r25, 0x2007	; 0x802007 <__DATA_REGION_ORIGIN__+0x7>
     35a:	d8 01       	movw	r26, r16
     35c:	8d 93       	st	X+, r24
     35e:	9c 93       	st	X, r25
     360:	80 e0       	ldi	r24, 0x00	; 0
     362:	0f c0       	rjmp	.+30     	; 0x382 <com_reg_read+0xcc>
     364:	80 91 08 20 	lds	r24, 0x2008	; 0x802008 <__DATA_REGION_ORIGIN__+0x8>
     368:	90 91 09 20 	lds	r25, 0x2009	; 0x802009 <__DATA_REGION_ORIGIN__+0x9>
     36c:	f8 01       	movw	r30, r16
     36e:	80 83       	st	Z, r24
     370:	91 83       	std	Z+1, r25	; 0x01
     372:	80 e0       	ldi	r24, 0x00	; 0
     374:	06 c0       	rjmp	.+12     	; 0x382 <com_reg_read+0xcc>
     376:	b8 01       	movw	r22, r16
     378:	ce 01       	movw	r24, r28
     37a:	0e 94 48 07 	call	0xe90	; 0xe90 <do_reg_read>
     37e:	01 c0       	rjmp	.+2      	; 0x382 <com_reg_read+0xcc>
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	df 91       	pop	r29
     384:	cf 91       	pop	r28
     386:	1f 91       	pop	r17
     388:	0f 91       	pop	r16
     38a:	08 95       	ret

0000038c <__vector_86>:
}

/* Timer D1 CCB Interrupt vector
 * every 1ms
 */
ISR(TCD1_CCB_vect) {
     38c:	1f 92       	push	r1
     38e:	0f 92       	push	r0
     390:	0f b6       	in	r0, 0x3f	; 63
     392:	0f 92       	push	r0
     394:	11 24       	eor	r1, r1
     396:	2f 93       	push	r18
     398:	8f 93       	push	r24
     39a:	9f 93       	push	r25
     39c:	ef 93       	push	r30
     39e:	ff 93       	push	r31
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     3a0:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     3a2:	f8 94       	cli
        // CCB neu setzen. addieren TIMER_PERIOD
        TCD1.CCBBUF = TCD1.CNT + TIMER_PERIOD;
     3a4:	e0 e4       	ldi	r30, 0x40	; 64
     3a6:	f9 e0       	ldi	r31, 0x09	; 9
     3a8:	80 a1       	ldd	r24, Z+32	; 0x20
     3aa:	91 a1       	ldd	r25, Z+33	; 0x21
     3ac:	8c 50       	subi	r24, 0x0C	; 12
     3ae:	9e 4f       	sbci	r25, 0xFE	; 254
     3b0:	82 af       	std	Z+58, r24	; 0x3a
     3b2:	93 af       	std	Z+59, r25	; 0x3b
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     3b4:	2f bf       	out	0x3f, r18	; 63
    }
    
    // common timer erhhen
    g_com.timer++;
     3b6:	e0 e0       	ldi	r30, 0x00	; 0
     3b8:	f0 e2       	ldi	r31, 0x20	; 32
     3ba:	84 85       	ldd	r24, Z+12	; 0x0c
     3bc:	8f 5f       	subi	r24, 0xFF	; 255
     3be:	84 87       	std	Z+12, r24	; 0x0c
     3c0:	8f 70       	andi	r24, 0x0F	; 15
    
    struct timer *t;
    // verkettete Timer 
    // Ist der common timer & 0xf == 0, dann auf 16ms timmer setzen
    if ((g_com.timer & 0x0f) == 0) {
     3c2:	81 f4       	brne	.+32     	; 0x3e4 <__vector_86+0x58>
        t = g_com.timer_16ms;
     3c4:	e0 91 0f 20 	lds	r30, 0x200F	; 0x80200f <__DATA_REGION_ORIGIN__+0xf>
     3c8:	f0 91 10 20 	lds	r31, 0x2010	; 0x802010 <__DATA_REGION_ORIGIN__+0x10>
        while (t) {
     3cc:	30 97       	sbiw	r30, 0x00	; 0
     3ce:	51 f0       	breq	.+20     	; 0x3e4 <__vector_86+0x58>
            if (t->value > 0) {
     3d0:	82 81       	ldd	r24, Z+2	; 0x02
     3d2:	18 16       	cp	r1, r24
     3d4:	14 f4       	brge	.+4      	; 0x3da <__vector_86+0x4e>
                t->value--;
     3d6:	81 50       	subi	r24, 0x01	; 1
     3d8:	82 83       	std	Z+2, r24	; 0x02
            }
            t = t->next;
     3da:	01 90       	ld	r0, Z+
     3dc:	f0 81       	ld	r31, Z
     3de:	e0 2d       	mov	r30, r0
    struct timer *t;
    // verkettete Timer 
    // Ist der common timer & 0xf == 0, dann auf 16ms timmer setzen
    if ((g_com.timer & 0x0f) == 0) {
        t = g_com.timer_16ms;
        while (t) {
     3e0:	30 97       	sbiw	r30, 0x00	; 0
     3e2:	b1 f7       	brne	.-20     	; 0x3d0 <__vector_86+0x44>
            }
            t = t->next;
        }
    }
    // 1ms timer
    t = g_com.timer_1ms;
     3e4:	e0 91 0d 20 	lds	r30, 0x200D	; 0x80200d <__DATA_REGION_ORIGIN__+0xd>
     3e8:	f0 91 0e 20 	lds	r31, 0x200E	; 0x80200e <__DATA_REGION_ORIGIN__+0xe>
    while (t) {
     3ec:	30 97       	sbiw	r30, 0x00	; 0
     3ee:	51 f0       	breq	.+20     	; 0x404 <__EEPROM_REGION_LENGTH__+0x4>
        if (t->value > 0) {
     3f0:	82 81       	ldd	r24, Z+2	; 0x02
     3f2:	18 16       	cp	r1, r24
     3f4:	14 f4       	brge	.+4      	; 0x3fa <__vector_86+0x6e>
            t->value--;
     3f6:	81 50       	subi	r24, 0x01	; 1
     3f8:	82 83       	std	Z+2, r24	; 0x02
        }
        t = t->next;
     3fa:	01 90       	ld	r0, Z+
     3fc:	f0 81       	ld	r31, Z
     3fe:	e0 2d       	mov	r30, r0
            t = t->next;
        }
    }
    // 1ms timer
    t = g_com.timer_1ms;
    while (t) {
     400:	30 97       	sbiw	r30, 0x00	; 0
     402:	b1 f7       	brne	.-20     	; 0x3f0 <__vector_86+0x64>
        if (t->value > 0) {
            t->value--;
        }
        t = t->next;
    }
}
     404:	ff 91       	pop	r31
     406:	ef 91       	pop	r30
     408:	9f 91       	pop	r25
     40a:	8f 91       	pop	r24
     40c:	2f 91       	pop	r18
     40e:	0f 90       	pop	r0
     410:	0f be       	out	0x3f, r0	; 63
     412:	0f 90       	pop	r0
     414:	1f 90       	pop	r1
     416:	18 95       	reti

00000418 <main>:

/* main: Gerte Hauptroutine
 * int main(void)
 * 
 */
__ATTR_OS_MAIN int main(void) {
     418:	cd b7       	in	r28, 0x3d	; 61
     41a:	de b7       	in	r29, 0x3e	; 62
     41c:	c5 54       	subi	r28, 0x45	; 69
     41e:	d1 09       	sbc	r29, r1
     420:	cd bf       	out	0x3d, r28	; 61
     422:	de bf       	out	0x3e, r29	; 62
    // erst mal interupts aus
    cli();
     424:	f8 94       	cli

/* Standard Gerte Initialiserung
 */
static void com_init_system(void) {
    // zuerst die User Gerte Initialiserung
    do_init_system();
     426:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <do_init_system>
    
    // standard timer
    // timer D1
    TCD1.CTRLB = TC_WGMODE_NORMAL_gc; // Normal Mode
     42a:	e0 e4       	ldi	r30, 0x40	; 64
     42c:	f9 e0       	ldi	r31, 0x09	; 9
     42e:	11 82       	std	Z+1, r1	; 0x01
    TCD1.CTRLD = 0; // Event Action off
     430:	13 82       	std	Z+3, r1	; 0x03
    TCD1.CTRLE = 0; // normal mode
     432:	14 82       	std	Z+4, r1	; 0x04
    TCD1.INTCTRLA = 0;  // err and ov disabled
     434:	16 82       	std	Z+6, r1	; 0x06
    TCD1.INTCTRLB = TC_CCBINTLVL_LO_gc; // CCD interupt level auf LOW
     436:	84 e0       	ldi	r24, 0x04	; 4
     438:	87 83       	std	Z+7, r24	; 0x07
    TCD1.INTFLAGS = 0xff; // clear interupt TCD0 flags
     43a:	8f ef       	ldi	r24, 0xFF	; 255
     43c:	84 87       	std	Z+12, r24	; 0x0c
    TCD1.PER = 0xffff; // D1 periode
     43e:	8f ef       	ldi	r24, 0xFF	; 255
     440:	9f ef       	ldi	r25, 0xFF	; 255
     442:	86 a3       	std	Z+38, r24	; 0x26
     444:	97 a3       	std	Z+39, r25	; 0x27
    //TCD1.CCB = TCD1.CNT + TIMER_PERIOD;
    TCD1.CTRLA = TC_CLKSEL_DIV64_gc; // TCD0 clock divider /64
     446:	85 e0       	ldi	r24, 0x05	; 5
     448:	80 83       	st	Z, r24

    // schreibe Product und Vendor ID in das EEPROM
    eeprom_update_word(&bldr_eeprom.productid, g_com.productid);
     44a:	00 e0       	ldi	r16, 0x00	; 0
     44c:	10 e2       	ldi	r17, 0x20	; 32
     44e:	f8 01       	movw	r30, r16
     450:	60 81       	ld	r22, Z
     452:	71 81       	ldd	r23, Z+1	; 0x01
     454:	85 e0       	ldi	r24, 0x05	; 5
     456:	93 e0       	ldi	r25, 0x03	; 3
     458:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <eeprom_update_word>
    eeprom_update_word(&bldr_eeprom.vendorid, g_com.vendorid);
     45c:	f8 01       	movw	r30, r16
     45e:	62 81       	ldd	r22, Z+2	; 0x02
     460:	73 81       	ldd	r23, Z+3	; 0x03
     462:	87 e0       	ldi	r24, 0x07	; 7
     464:	93 e0       	ldi	r25, 0x03	; 3
     466:	0e 94 72 0a 	call	0x14e4	; 0x14e4 <eeprom_update_word>
    
    // schreibe Gertebeschreibung in das EEPROM
    if (g_com.dev_desc_P) {
     46a:	f8 01       	movw	r30, r16
     46c:	22 85       	ldd	r18, Z+10	; 0x0a
     46e:	33 85       	ldd	r19, Z+11	; 0x0b
     470:	21 15       	cp	r18, r1
     472:	31 05       	cpc	r19, r1
     474:	a1 f0       	breq	.+40     	; 0x49e <main+0x86>
     476:	00 e0       	ldi	r16, 0x00	; 0
        PGM_P p = g_com.dev_desc_P;
        for (uint8_t n = 0; n < DEV_DESC_MAX_SIZE; n++) {
            uint8_t c = pgm_read_byte(p++);
     478:	79 01       	movw	r14, r18
     47a:	ff ef       	ldi	r31, 0xFF	; 255
     47c:	ef 1a       	sub	r14, r31
     47e:	ff 0a       	sbc	r15, r31
     480:	f9 01       	movw	r30, r18
     482:	14 91       	lpm	r17, Z
            eeprom_update_byte(&bldr_eeprom.dev_desc[0][n], c);
     484:	80 2f       	mov	r24, r16
     486:	90 e0       	ldi	r25, 0x00	; 0
     488:	61 2f       	mov	r22, r17
     48a:	80 5c       	subi	r24, 0xC0	; 192
     48c:	9c 4f       	sbci	r25, 0xFC	; 252
     48e:	0e 94 67 0a 	call	0x14ce	; 0x14ce <eeprom_update_byte>
            if (c == 0) {
     492:	11 23       	and	r17, r17
     494:	21 f0       	breq	.+8      	; 0x49e <main+0x86>
    eeprom_update_word(&bldr_eeprom.vendorid, g_com.vendorid);
    
    // schreibe Gertebeschreibung in das EEPROM
    if (g_com.dev_desc_P) {
        PGM_P p = g_com.dev_desc_P;
        for (uint8_t n = 0; n < DEV_DESC_MAX_SIZE; n++) {
     496:	0f 5f       	subi	r16, 0xFF	; 255
            uint8_t c = pgm_read_byte(p++);
     498:	97 01       	movw	r18, r14
    eeprom_update_word(&bldr_eeprom.vendorid, g_com.vendorid);
    
    // schreibe Gertebeschreibung in das EEPROM
    if (g_com.dev_desc_P) {
        PGM_P p = g_com.dev_desc_P;
        for (uint8_t n = 0; n < DEV_DESC_MAX_SIZE; n++) {
     49a:	00 32       	cpi	r16, 0x20	; 32
     49c:	68 f3       	brcs	.-38     	; 0x478 <main+0x60>
    cli();
    // System Initiatliserung
    com_init_system();
    
    // Kommando reset verarbeiten
    com_process_cmd_reset();
     49e:	0e 94 1b 01 	call	0x236	; 0x236 <com_process_cmd_reset>
#ifndef BOOTLOADER
extern void sbn_init(void);
extern uint8_t sbn_all_sent(void);
extern uint8_t sbn_send_msg(struct sboxnet_msg_header* pmsg);
extern int8_t sbn_receive_msg(struct sboxnet_msg_header* pmsg, uint8_t maxmsglen);
static INLINE void sboxnet_init(void) { sbn_init(); }
     4a2:	0e 94 08 41 	call	0x8210	; 0x8210 <sbn_init>
    // Kommunikation Sboxnet Initialiseren
    sboxnet_init();
   
    // Standard sleep Mode IDLE
    set_sleep_mode(SLEEP_SMODE_IDLE_gc);
     4a6:	e8 e4       	ldi	r30, 0x48	; 72
     4a8:	f0 e0       	ldi	r31, 0x00	; 0
     4aa:	80 81       	ld	r24, Z
     4ac:	81 7f       	andi	r24, 0xF1	; 241
     4ae:	80 83       	st	Z, r24
    // Interrupts ein
    sei();
     4b0:	78 94       	sei
    
    // Gert Setup
    do_setup();
     4b2:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <do_setup>
    while(1) {
        // Buffer fr Nachrichten
        struct sboxnet_msg_max msg;
        
        // wird keine Adresse angefordert? 0==keine Addresse angefordert
        if (bldr_task(&msg) == 0) {
     4b6:	ce 01       	movw	r24, r28
     4b8:	01 96       	adiw	r24, 0x01	; 1
     4ba:	0e 94 02 41 	call	0x8204	; 0x8204 <bldr_task>
     4be:	81 11       	cpse	r24, r1
     4c0:	3e c1       	rjmp	.+636    	; 0x73e <main+0x326>
static INLINE uint8_t sboxnet_all_sent(void) { return sbn_all_sent(); }
extern uint8_t sboxnet_send_msg(struct sboxnet_msg_header* pmsg);
static INLINE int8_t sboxnet_receive_msg(struct sboxnet_msg_header* pmsg, uint8_t maxmsglen) { return sbn_receive_msg(pmsg, maxmsglen); }
     4c2:	65 e4       	ldi	r22, 0x45	; 69
     4c4:	ce 01       	movw	r24, r28
     4c6:	01 96       	adiw	r24, 0x01	; 1
     4c8:	0e 94 0a 41 	call	0x8214	; 0x8214 <sbn_receive_msg>
 * void com_receive_and_process_msg(struct sboxnet_msg_max* pmsg)
 *   - pmsg  Nachrichtenbuffer
 */
static void com_receive_and_process_msg(struct sboxnet_msg_max* pmsg) {    
    int8_t rc = sboxnet_receive_msg(&pmsg->msgh, sizeof(*pmsg));
    if (rc > 0) {
     4cc:	18 16       	cp	r1, r24
     4ce:	0c f0       	brlt	.+2      	; 0x4d2 <main+0xba>
     4d0:	0a c1       	rjmp	.+532    	; 0x6e6 <main+0x2ce>
static void com_process_msg(struct sboxnet_msg_header *pmsg) {
    char rc = 0;
    // ist die Quelladresse 0, dann watch dog timer setzen
    
    // ist Quelladresse 0 -> Watchdog Ping
    if (pmsg->srcaddr == 0) {
     4d2:	8a 81       	ldd	r24, Y+2	; 0x02
     4d4:	81 11       	cpse	r24, r1
     4d6:	03 c0       	rjmp	.+6      	; 0x4de <main+0xc6>
        g_v.timer_watchdog = WATCHDOG_VAL;
     4d8:	80 e8       	ldi	r24, 0x80	; 128
     4da:	80 93 92 2e 	sts	0x2E92, r24	; 0x802e92 <__bss_end+0xda9>
    }
    
    // Usereinsprung
    rc = do_msg(pmsg);
     4de:	ce 01       	movw	r24, r28
     4e0:	01 96       	adiw	r24, 0x01	; 1
     4e2:	0e 94 ec 06 	call	0xdd8	; 0xdd8 <do_msg>
     if (rc == SBOXNET_ACKRC_OK) {
     4e6:	88 23       	and	r24, r24
     4e8:	09 f4       	brne	.+2      	; 0x4ec <main+0xd4>
     4ea:	f3 c0       	rjmp	.+486    	; 0x6d2 <main+0x2ba>
        goto send_ok;
    } else if (rc == SBOXNET_ACKRC_SEND_NO_ANSWER) {
     4ec:	8f 3f       	cpi	r24, 0xFF	; 255
     4ee:	09 f4       	brne	.+2      	; 0x4f2 <main+0xda>
     4f0:	fd c0       	rjmp	.+506    	; 0x6ec <main+0x2d4>
        return;
    } else if (rc != SBOXNET_ACKRC_CMD_UNKNOWN) {
     4f2:	82 30       	cpi	r24, 0x02	; 2
     4f4:	09 f0       	breq	.+2      	; 0x4f8 <main+0xe0>
     4f6:	e4 c0       	rjmp	.+456    	; 0x6c0 <main+0x2a8>
        goto send_error;
    }
    // ist Bit 7 des Kommandos gestetzt, dann keine Antwort
    if (pmsg->cmd & 0x80) {
     4f8:	8d 81       	ldd	r24, Y+5	; 0x05
     4fa:	88 23       	and	r24, r24
     4fc:	0c f4       	brge	.+2      	; 0x500 <main+0xe8>
     4fe:	f6 c0       	rjmp	.+492    	; 0x6ec <main+0x2d4>
 *  SBOXNET_CMD_DEV_SET_DESC Gertebeschreibung setzen
 *  alle anderen werden weitergeleitet zu bldr_process_basic_msg
 */
static uint8_t com_process_std_msg(struct sboxnet_msg_header *pmsg) {
    // Nachrichten behandeln
    switch (pmsg->cmd) {
     500:	82 30       	cpi	r24, 0x02	; 2
     502:	09 f4       	brne	.+2      	; 0x506 <main+0xee>
     504:	ca c0       	rjmp	.+404    	; 0x69a <main+0x282>
     506:	85 31       	cpi	r24, 0x15	; 21
     508:	41 f0       	breq	.+16     	; 0x51a <main+0x102>
     50a:	81 30       	cpi	r24, 0x01	; 1
     50c:	79 f4       	brne	.+30     	; 0x52c <main+0x114>
        // SBOXNET_CMD_NET_RESET
        case SBOXNET_CMD_NET_RESET: {
            if (pmsg->srcaddr == 0) {
     50e:	8a 81       	ldd	r24, Y+2	; 0x02
     510:	81 11       	cpse	r24, r1
     512:	ec c0       	rjmp	.+472    	; 0x6ec <main+0x2d4>
                // neue Adresse anfordern
                return com_process_cmd_reset();
     514:	0e 94 1b 01 	call	0x236	; 0x236 <com_process_cmd_reset>
     518:	c1 c0       	rjmp	.+386    	; 0x69c <main+0x284>
        }
        
        // SBOXNET_CMD_DEV_RESET
        case SBOXNET_CMD_DEV_RESET: {
            // Gerte Reset
            setbit_atomic(g_dev_state, DEV_STATE_FLG_RESET_b);
     51a:	06 9a       	sbi	0x00, 6	; 0
            
            if (pmsg->dstaddr == SBOXNET_ADDR_BROADCAST) {
     51c:	89 81       	ldd	r24, Y+1	; 0x01
     51e:	8f 3f       	cpi	r24, 0xFF	; 255
     520:	09 f4       	brne	.+2      	; 0x524 <main+0x10c>
     522:	e4 c0       	rjmp	.+456    	; 0x6ec <main+0x2d4>
                return SBOXNET_ACKRC_SEND_NO_ANSWER;
            } else {
                pmsg->opt.len = 0;
     524:	8c 81       	ldd	r24, Y+4	; 0x04
     526:	80 7c       	andi	r24, 0xC0	; 192
     528:	8c 83       	std	Y+4, r24	; 0x04
     52a:	d3 c0       	rjmp	.+422    	; 0x6d2 <main+0x2ba>
            }
        }
    }
    
    // falls Ziel Broadcat Adresse ist, keine Antwort
    if (pmsg->dstaddr == SBOXNET_ADDR_BROADCAST) {
     52c:	99 81       	ldd	r25, Y+1	; 0x01
     52e:	9f 3f       	cpi	r25, 0xFF	; 255
     530:	09 f4       	brne	.+2      	; 0x534 <main+0x11c>
     532:	dc c0       	rjmp	.+440    	; 0x6ec <main+0x2d4>
        return SBOXNET_ACKRC_SEND_NO_ANSWER;
    }
    
    switch (pmsg->cmd) {
     534:	81 32       	cpi	r24, 0x21	; 33
     536:	c1 f1       	breq	.+112    	; 0x5a8 <main+0x190>
     538:	30 f4       	brcc	.+12     	; 0x546 <main+0x12e>
     53a:	83 31       	cpi	r24, 0x13	; 19
     53c:	09 f4       	brne	.+2      	; 0x540 <main+0x128>
     53e:	8a c0       	rjmp	.+276    	; 0x654 <main+0x23c>
     540:	80 32       	cpi	r24, 0x20	; 32
     542:	41 f0       	breq	.+16     	; 0x554 <main+0x13c>
     544:	a5 c0       	rjmp	.+330    	; 0x690 <main+0x278>
     546:	82 32       	cpi	r24, 0x22	; 34
     548:	09 f4       	brne	.+2      	; 0x54c <main+0x134>
     54a:	4c c0       	rjmp	.+152    	; 0x5e4 <main+0x1cc>
     54c:	83 32       	cpi	r24, 0x23	; 35
     54e:	09 f4       	brne	.+2      	; 0x552 <main+0x13a>
     550:	62 c0       	rjmp	.+196    	; 0x616 <main+0x1fe>
     552:	9e c0       	rjmp	.+316    	; 0x690 <main+0x278>
    // Register, index 0
    uint16_t regaddr = *pdata;
    // Anzahl der Register
    uint8_t num = pmsg->data[2];
    // ist die Anzahl der Register gltig?
    if (pmsg->opt.len != 3 || num > SBOXNET_MSG_DATA_LEN/2 ) {
     554:	8c 81       	ldd	r24, Y+4	; 0x04
     556:	8f 73       	andi	r24, 0x3F	; 63
     558:	83 30       	cpi	r24, 0x03	; 3
     55a:	09 f0       	breq	.+2      	; 0x55e <main+0x146>
     55c:	a4 c0       	rjmp	.+328    	; 0x6a6 <main+0x28e>
    // Zeiger auf Nachricht Daten
    uint16_t *pdata = (uint16_t*)pmsg->data;
    // Register, index 0
    uint16_t regaddr = *pdata;
    // Anzahl der Register
    uint8_t num = pmsg->data[2];
     55e:	18 85       	ldd	r17, Y+8	; 0x08
    // ist die Anzahl der Register gltig?
    if (pmsg->opt.len != 3 || num > SBOXNET_MSG_DATA_LEN/2 ) {
     560:	10 32       	cpi	r17, 0x20	; 32
     562:	08 f0       	brcs	.+2      	; 0x566 <main+0x14e>
     564:	a2 c0       	rjmp	.+324    	; 0x6aa <main+0x292>
 */
static uint8_t com_cmd_reg_read(struct sboxnet_msg_header *pmsg) {
    // Zeiger auf Nachricht Daten
    uint16_t *pdata = (uint16_t*)pmsg->data;
    // Register, index 0
    uint16_t regaddr = *pdata;
     566:	2e 81       	ldd	r18, Y+6	; 0x06
     568:	3f 81       	ldd	r19, Y+7	; 0x07
    // ist die Anzahl der Register gltig?
    if (pmsg->opt.len != 3 || num > SBOXNET_MSG_DATA_LEN/2 ) {
        return SBOXNET_ACKRC_INVALID_ARG;
    }
    // Antwort vorbereiten
    pmsg->opt.len = 2*num;
     56a:	91 2f       	mov	r25, r17
     56c:	99 0f       	add	r25, r25
     56e:	9e 73       	andi	r25, 0x3E	; 62
     570:	8c 81       	ldd	r24, Y+4	; 0x04
     572:	80 7c       	andi	r24, 0xC0	; 192
     574:	98 2b       	or	r25, r24
     576:	9c 83       	std	Y+4, r25	; 0x04
    while (num) {
     578:	11 23       	and	r17, r17
     57a:	09 f4       	brne	.+2      	; 0x57e <main+0x166>
     57c:	aa c0       	rjmp	.+340    	; 0x6d2 <main+0x2ba>
     57e:	be 01       	movw	r22, r28
     580:	6a 5f       	subi	r22, 0xFA	; 250
     582:	7f 4f       	sbci	r23, 0xFF	; 255
        uint8_t rc = com_reg_read(regaddr++, pdata++);
     584:	6b 01       	movw	r12, r22
     586:	f2 e0       	ldi	r31, 0x02	; 2
     588:	cf 0e       	add	r12, r31
     58a:	d1 1c       	adc	r13, r1
     58c:	79 01       	movw	r14, r18
     58e:	8f ef       	ldi	r24, 0xFF	; 255
     590:	e8 1a       	sub	r14, r24
     592:	f8 0a       	sbc	r15, r24
     594:	c9 01       	movw	r24, r18
     596:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <com_reg_read>
        if (rc != 0) {
     59a:	81 11       	cpse	r24, r1
     59c:	da c0       	rjmp	.+436    	; 0x752 <main+0x33a>
            return rc;
        }
        num--;
     59e:	11 50       	subi	r17, 0x01	; 1
        return SBOXNET_ACKRC_INVALID_ARG;
    }
    // Antwort vorbereiten
    pmsg->opt.len = 2*num;
    while (num) {
        uint8_t rc = com_reg_read(regaddr++, pdata++);
     5a0:	b6 01       	movw	r22, r12
     5a2:	97 01       	movw	r18, r14
    if (pmsg->opt.len != 3 || num > SBOXNET_MSG_DATA_LEN/2 ) {
        return SBOXNET_ACKRC_INVALID_ARG;
    }
    // Antwort vorbereiten
    pmsg->opt.len = 2*num;
    while (num) {
     5a4:	79 f7       	brne	.-34     	; 0x584 <main+0x16c>
     5a6:	95 c0       	rjmp	.+298    	; 0x6d2 <main+0x2ba>
 */
static uint8_t com_cmd_reg_read_multi(struct sboxnet_msg_header *pmsg) {
    // Zeiger auf Daten
    uint16_t *pdata = (uint16_t*)pmsg->data;
    // ist die Lnge der Nachricht OK?
    if (pmsg->opt.len > SBOXNET_MSG_DATA_LEN || (pmsg->opt.len & 0x01)) {
     5a8:	2c 81       	ldd	r18, Y+4	; 0x04
     5aa:	2f 73       	andi	r18, 0x3F	; 63
     5ac:	82 2f       	mov	r24, r18
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	20 fd       	sbrc	r18, 0
     5b2:	7d c0       	rjmp	.+250    	; 0x6ae <main+0x296>
        return SBOXNET_ACKRC_INVALID_ARG;
    }
    // Lnge der Nachricht
    uint8_t n = pmsg->opt.len / 2;
     5b4:	95 95       	asr	r25
     5b6:	87 95       	ror	r24
     5b8:	18 2f       	mov	r17, r24
    // Pro Register, lesen
    while (n > 0) {
     5ba:	88 23       	and	r24, r24
     5bc:	09 f4       	brne	.+2      	; 0x5c0 <main+0x1a8>
     5be:	89 c0       	rjmp	.+274    	; 0x6d2 <main+0x2ba>
     5c0:	7e 01       	movw	r14, r28
     5c2:	e6 e0       	ldi	r30, 0x06	; 6
     5c4:	ee 0e       	add	r14, r30
     5c6:	f1 1c       	adc	r15, r1
        uint8_t rc = com_reg_read(*pdata, pdata);
     5c8:	b7 01       	movw	r22, r14
     5ca:	f7 01       	movw	r30, r14
     5cc:	80 81       	ld	r24, Z
     5ce:	91 81       	ldd	r25, Z+1	; 0x01
     5d0:	0e 94 5b 01 	call	0x2b6	; 0x2b6 <com_reg_read>
        if (rc != 0) {
     5d4:	81 11       	cpse	r24, r1
     5d6:	bd c0       	rjmp	.+378    	; 0x752 <main+0x33a>
            return rc;
        }
        pdata++;
     5d8:	f2 e0       	ldi	r31, 0x02	; 2
     5da:	ef 0e       	add	r14, r31
     5dc:	f1 1c       	adc	r15, r1
        n--;
     5de:	11 50       	subi	r17, 0x01	; 1
        return SBOXNET_ACKRC_INVALID_ARG;
    }
    // Lnge der Nachricht
    uint8_t n = pmsg->opt.len / 2;
    // Pro Register, lesen
    while (n > 0) {
     5e0:	99 f7       	brne	.-26     	; 0x5c8 <main+0x1b0>
     5e2:	77 c0       	rjmp	.+238    	; 0x6d2 <main+0x2ba>
            // Register
            uint16_t regaddr = pdata[0];
            // und die Daten / Wert
            uint16_t regval  = pdata[1];
            // maske
            uint16_t mask    = (pmsg->opt.len == 6 ? pdata[2] : 0xffff);
     5e4:	8c 81       	ldd	r24, Y+4	; 0x04
     5e6:	98 2f       	mov	r25, r24
     5e8:	9f 73       	andi	r25, 0x3F	; 63
     5ea:	96 30       	cpi	r25, 0x06	; 6
     5ec:	19 f4       	brne	.+6      	; 0x5f4 <main+0x1dc>
     5ee:	4a 85       	ldd	r20, Y+10	; 0x0a
     5f0:	5b 85       	ldd	r21, Y+11	; 0x0b
     5f2:	06 c0       	rjmp	.+12     	; 0x600 <main+0x1e8>
            if (pmsg->opt.len != 4 && pmsg->opt.len != 6) {
     5f4:	8d 73       	andi	r24, 0x3D	; 61
     5f6:	84 30       	cpi	r24, 0x04	; 4
     5f8:	09 f0       	breq	.+2      	; 0x5fc <main+0x1e4>
     5fa:	5b c0       	rjmp	.+182    	; 0x6b2 <main+0x29a>
            // Register
            uint16_t regaddr = pdata[0];
            // und die Daten / Wert
            uint16_t regval  = pdata[1];
            // maske
            uint16_t mask    = (pmsg->opt.len == 6 ? pdata[2] : 0xffff);
     5fc:	4f ef       	ldi	r20, 0xFF	; 255
     5fe:	5f ef       	ldi	r21, 0xFF	; 255
            // Register schreiben

            // Zeiger auf Daten
            uint16_t *pdata = (uint16_t*)pmsg->data;
            // Register
            uint16_t regaddr = pdata[0];
     600:	2e 81       	ldd	r18, Y+6	; 0x06
     602:	3f 81       	ldd	r19, Y+7	; 0x07
            // und die Daten / Wert
            uint16_t regval  = pdata[1];
     604:	68 85       	ldd	r22, Y+8	; 0x08
     606:	79 85       	ldd	r23, Y+9	; 0x09
            // maske
            uint16_t mask    = (pmsg->opt.len == 6 ? pdata[2] : 0xffff);
            if (pmsg->opt.len != 4 && pmsg->opt.len != 6) {
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            pmsg->opt.len = 0;
     608:	9c 81       	ldd	r25, Y+4	; 0x04
     60a:	90 7c       	andi	r25, 0xC0	; 192
     60c:	9c 83       	std	Y+4, r25	; 0x04
 *     - data  16 Bit Daten
 *     - mask  16 Bit Maske: beschrieben wird (data & mask)
 */
static uint8_t com_reg_write(uint16_t reg, uint16_t data, uint16_t mask) {
    // ruft nur Gerte do_reg_write auf
    return do_reg_write(reg, data, mask);
     60e:	c9 01       	movw	r24, r18
     610:	0e 94 ab 07 	call	0xf56	; 0xf56 <do_reg_write>
     614:	43 c0       	rjmp	.+134    	; 0x69c <main+0x284>
            uint16_t* pdata = (uint16_t*)pmsg->data;
            // Register
            uint16_t regaddr = pdata[0];
            // Bit
            uint8_t val = pmsg->data[2];// value (0x80) und bit (0x0f) nummer
            if (pmsg->opt.len != 3) {
     616:	8c 81       	ldd	r24, Y+4	; 0x04
     618:	8f 73       	andi	r24, 0x3F	; 63
     61a:	83 30       	cpi	r24, 0x03	; 3
     61c:	09 f0       	breq	.+2      	; 0x620 <main+0x208>
     61e:	4b c0       	rjmp	.+150    	; 0x6b6 <main+0x29e>
            // Zeiger auf Daten
            uint16_t* pdata = (uint16_t*)pmsg->data;
            // Register
            uint16_t regaddr = pdata[0];
            // Bit
            uint8_t val = pmsg->data[2];// value (0x80) und bit (0x0f) nummer
     620:	88 85       	ldd	r24, Y+8	; 0x08
     622:	98 2f       	mov	r25, r24
     624:	9f 70       	andi	r25, 0x0F	; 15
            if (pmsg->opt.len != 3) {
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            uint16_t data = 0;
            uint16_t mask = 0x01;
            mask <<= (val & 0x0f);
     626:	41 e0       	ldi	r20, 0x01	; 1
     628:	50 e0       	ldi	r21, 0x00	; 0
     62a:	02 c0       	rjmp	.+4      	; 0x630 <main+0x218>
     62c:	44 0f       	add	r20, r20
     62e:	55 1f       	adc	r21, r21
     630:	9a 95       	dec	r25
     632:	e2 f7       	brpl	.-8      	; 0x62c <main+0x214>
            // ist Bit 7 im Wert gesetzt -> data = mask entspricht bitval = 1
            if (val & 0x80) {
     634:	88 23       	and	r24, r24
     636:	1c f4       	brge	.+6      	; 0x63e <main+0x226>
                data = mask;
     638:	64 2f       	mov	r22, r20
     63a:	75 2f       	mov	r23, r21
     63c:	02 c0       	rjmp	.+4      	; 0x642 <main+0x22a>
            // Bit
            uint8_t val = pmsg->data[2];// value (0x80) und bit (0x0f) nummer
            if (pmsg->opt.len != 3) {
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            uint16_t data = 0;
     63e:	60 e0       	ldi	r22, 0x00	; 0
     640:	70 e0       	ldi	r23, 0x00	; 0
            // Bit in einem Register schreiben
            
            // Zeiger auf Daten
            uint16_t* pdata = (uint16_t*)pmsg->data;
            // Register
            uint16_t regaddr = pdata[0];
     642:	2e 81       	ldd	r18, Y+6	; 0x06
     644:	3f 81       	ldd	r19, Y+7	; 0x07
            mask <<= (val & 0x0f);
            // ist Bit 7 im Wert gesetzt -> data = mask entspricht bitval = 1
            if (val & 0x80) {
                data = mask;
            }
            pmsg->opt.len = 0;
     646:	9c 81       	ldd	r25, Y+4	; 0x04
     648:	90 7c       	andi	r25, 0xC0	; 192
     64a:	9c 83       	std	Y+4, r25	; 0x04
 *     - data  16 Bit Daten
 *     - mask  16 Bit Maske: beschrieben wird (data & mask)
 */
static uint8_t com_reg_write(uint16_t reg, uint16_t data, uint16_t mask) {
    // ruft nur Gerte do_reg_write auf
    return do_reg_write(reg, data, mask);
     64c:	c9 01       	movw	r24, r18
     64e:	0e 94 ab 07 	call	0xf56	; 0xf56 <do_reg_write>
     652:	24 c0       	rjmp	.+72     	; 0x69c <main+0x284>
        // SBOXNET_CMD_DEV_SET_DESC
        case SBOXNET_CMD_DEV_SET_DESC: {
            // Gertebeshcribung setzen
            
            // Lnge der Beschreibung
            uint8_t n = pmsg->opt.len;
     654:	4c 81       	ldd	r20, Y+4	; 0x04
     656:	4f 73       	andi	r20, 0x3F	; 63
            // Lnge Muss sein [1..(DEV_DESC_MAX_SIZE]
            if (n == 0 || n > DEV_DESC_MAX_SIZE) {
     658:	8f ef       	ldi	r24, 0xFF	; 255
     65a:	84 0f       	add	r24, r20
     65c:	80 32       	cpi	r24, 0x20	; 32
     65e:	68 f5       	brcc	.+90     	; 0x6ba <main+0x2a2>
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            // ID der Beschreibung
            uint8_t id = pmsg->data[0];
     660:	6e 81       	ldd	r22, Y+6	; 0x06
            //ist ID gltig?
            if (id == 0 || id >= DEV_NUM_DESCS) {
     662:	9f ef       	ldi	r25, 0xFF	; 255
     664:	96 0f       	add	r25, r22
     666:	92 30       	cpi	r25, 0x02	; 2
     668:	50 f5       	brcc	.+84     	; 0x6be <main+0x2a6>
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            n--;
            if (n < DEV_DESC_MAX_SIZE) {
                pmsg->data[1+n] = 0;
     66a:	fe 01       	movw	r30, r28
     66c:	e8 0f       	add	r30, r24
     66e:	f1 1d       	adc	r31, r1
     670:	17 82       	std	Z+7, r1	; 0x07
                n++;
            }
            // schreiben ins EEPROM
            eeprom_update_block(&pmsg->data[1], bldr_eeprom.dev_desc[id], n);
     672:	50 e0       	ldi	r21, 0x00	; 0
     674:	80 e2       	ldi	r24, 0x20	; 32
     676:	68 9f       	mul	r22, r24
     678:	b0 01       	movw	r22, r0
     67a:	11 24       	eor	r1, r1
     67c:	60 5c       	subi	r22, 0xC0	; 192
     67e:	7c 4f       	sbci	r23, 0xFC	; 252
     680:	ce 01       	movw	r24, r28
     682:	07 96       	adiw	r24, 0x07	; 7
     684:	0e 94 57 0a 	call	0x14ae	; 0x14ae <eeprom_update_block>
            pmsg->opt.len = 0;
     688:	8c 81       	ldd	r24, Y+4	; 0x04
     68a:	80 7c       	andi	r24, 0xC0	; 192
     68c:	8c 83       	std	Y+4, r24	; 0x04
     68e:	21 c0       	rjmp	.+66     	; 0x6d2 <main+0x2ba>
            return SBOXNET_ACKRC_OK;
        }
        default:
            // sonst bldr_process_basic_msg
            return bldr_process_basic_msg(pmsg);        
     690:	ce 01       	movw	r24, r28
     692:	01 96       	adiw	r24, 0x01	; 1
     694:	0e 94 04 41 	call	0x8208	; 0x8208 <bldr_process_basic_msg>
     698:	01 c0       	rjmp	.+2      	; 0x69c <main+0x284>
            return SBOXNET_ACKRC_SEND_NO_ANSWER;
        }
        
        // SBOXNET_CMD_NET_WATCHDOG
        case SBOXNET_CMD_NET_WATCHDOG: {
            return SBOXNET_ACKRC_SEND_NO_ANSWER;
     69a:	8f ef       	ldi	r24, 0xFF	; 255
        return;  // discard Ack Answers
    }
    
    // Standard Nachricht
    rc = com_process_std_msg(pmsg);
    if (rc == SBOXNET_ACKRC_SEND_NO_ANSWER) {
     69c:	8f 3f       	cpi	r24, 0xFF	; 255
     69e:	31 f1       	breq	.+76     	; 0x6ec <main+0x2d4>
        return;
    }
    if (rc == SBOXNET_ACKRC_OK) {
     6a0:	81 11       	cpse	r24, r1
     6a2:	0e c0       	rjmp	.+28     	; 0x6c0 <main+0x2a8>
     6a4:	16 c0       	rjmp	.+44     	; 0x6d2 <main+0x2ba>
    // Register, index 0
    uint16_t regaddr = *pdata;
    // Anzahl der Register
    uint8_t num = pmsg->data[2];
    // ist die Anzahl der Register gltig?
    if (pmsg->opt.len != 3 || num > SBOXNET_MSG_DATA_LEN/2 ) {
     6a6:	83 e0       	ldi	r24, 0x03	; 3
     6a8:	0b c0       	rjmp	.+22     	; 0x6c0 <main+0x2a8>
     6aa:	83 e0       	ldi	r24, 0x03	; 3
     6ac:	09 c0       	rjmp	.+18     	; 0x6c0 <main+0x2a8>
 */
static uint8_t com_cmd_reg_read_multi(struct sboxnet_msg_header *pmsg) {
    // Zeiger auf Daten
    uint16_t *pdata = (uint16_t*)pmsg->data;
    // ist die Lnge der Nachricht OK?
    if (pmsg->opt.len > SBOXNET_MSG_DATA_LEN || (pmsg->opt.len & 0x01)) {
     6ae:	83 e0       	ldi	r24, 0x03	; 3
     6b0:	07 c0       	rjmp	.+14     	; 0x6c0 <main+0x2a8>
            uint16_t regaddr = pdata[0];
            // und die Daten / Wert
            uint16_t regval  = pdata[1];
            // maske
            uint16_t mask    = (pmsg->opt.len == 6 ? pdata[2] : 0xffff);
            if (pmsg->opt.len != 4 && pmsg->opt.len != 6) {
     6b2:	83 e0       	ldi	r24, 0x03	; 3
     6b4:	05 c0       	rjmp	.+10     	; 0x6c0 <main+0x2a8>
            uint16_t* pdata = (uint16_t*)pmsg->data;
            // Register
            uint16_t regaddr = pdata[0];
            // Bit
            uint8_t val = pmsg->data[2];// value (0x80) und bit (0x0f) nummer
            if (pmsg->opt.len != 3) {
     6b6:	83 e0       	ldi	r24, 0x03	; 3
     6b8:	03 c0       	rjmp	.+6      	; 0x6c0 <main+0x2a8>
            // Gertebeshcribung setzen
            
            // Lnge der Beschreibung
            uint8_t n = pmsg->opt.len;
            // Lnge Muss sein [1..(DEV_DESC_MAX_SIZE]
            if (n == 0 || n > DEV_DESC_MAX_SIZE) {
     6ba:	83 e0       	ldi	r24, 0x03	; 3
     6bc:	01 c0       	rjmp	.+2      	; 0x6c0 <main+0x2a8>
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            // ID der Beschreibung
            uint8_t id = pmsg->data[0];
            //ist ID gltig?
            if (id == 0 || id >= DEV_NUM_DESCS) {
     6be:	83 e0       	ldi	r24, 0x03	; 3
    }
    if (rc == SBOXNET_ACKRC_OK) {
		goto send_ok;
    }
send_error:
    pmsg->opt.len = 2;
     6c0:	9c 81       	ldd	r25, Y+4	; 0x04
     6c2:	90 7c       	andi	r25, 0xC0	; 192
     6c4:	92 60       	ori	r25, 0x02	; 2
     6c6:	9c 83       	std	Y+4, r25	; 0x04
    pmsg->data[0] = pmsg->cmd; // ursprngliches Kommando
     6c8:	9d 81       	ldd	r25, Y+5	; 0x05
     6ca:	9e 83       	std	Y+6, r25	; 0x06
    pmsg->data[1] = rc; // Rckgabewert
     6cc:	8f 83       	std	Y+7, r24	; 0x07
    pmsg->cmd = 0x80; // mark Kommando als Antwort
     6ce:	80 e8       	ldi	r24, 0x80	; 128
     6d0:	8d 83       	std	Y+5, r24	; 0x05
send_ok:
    // Antwort senden an Absender
    pmsg->dstaddr = pmsg->srcaddr;
     6d2:	8a 81       	ldd	r24, Y+2	; 0x02
     6d4:	89 83       	std	Y+1, r24	; 0x01
    pmsg->cmd |= 0x80; // als Antwort auf Kommando markieren
     6d6:	8d 81       	ldd	r24, Y+5	; 0x05
     6d8:	80 68       	ori	r24, 0x80	; 128
     6da:	8d 83       	std	Y+5, r24	; 0x05
    sboxnet_send_msg(pmsg);
     6dc:	ce 01       	movw	r24, r28
     6de:	01 96       	adiw	r24, 0x01	; 1
     6e0:	0e 94 71 45 	call	0x8ae2	; 0x8ae2 <sboxnet_send_msg>
     6e4:	03 c0       	rjmp	.+6      	; 0x6ec <main+0x2d4>
    if (rc > 0) {
        // Kommando war erfolgreich
        com_process_msg(&pmsg->msgh);
    
        // ansonsten war das Ergebnis ein CRC Fehler?
    } else if (rc == SBOXNET_ERR_RECVMSG_CRC) {
     6e6:	8e 3f       	cpi	r24, 0xFE	; 254
     6e8:	09 f4       	brne	.+2      	; 0x6ec <main+0x2d4>
        // wenn ja, das Errorflag setzen CRC Fehler
        setbit(g_dev_errflags, DEV_ERR_FLG_SBOXNETCRC_b); // crc error
     6ea:	09 9a       	sbi	0x01, 1	; 1
        // wird keine Adresse angefordert? 0==keine Addresse angefordert
        if (bldr_task(&msg) == 0) {
            // dann verarbeiten
            com_receive_and_process_msg(&msg);
            // ist das Gert im FW Update Modus?
            if (g_dev_state & DEV_STATE_FLG_FWUP_MASK) {
     6ec:	80 b1       	in	r24, 0x00	; 0
     6ee:	86 70       	andi	r24, 0x06	; 6
     6f0:	19 f1       	breq	.+70     	; 0x738 <main+0x320>
extern void sbn_init(void);
extern uint8_t sbn_all_sent(void);
extern uint8_t sbn_send_msg(struct sboxnet_msg_header* pmsg);
extern int8_t sbn_receive_msg(struct sboxnet_msg_header* pmsg, uint8_t maxmsglen);
static INLINE void sboxnet_init(void) { sbn_init(); }
static INLINE uint8_t sboxnet_all_sent(void) { return sbn_all_sent(); }
     6f2:	0e 94 0e 41 	call	0x821c	; 0x821c <sbn_all_sent>
                
                while (!sboxnet_all_sent()); // wait until sboxnet transmitter is empty
     6f6:	88 23       	and	r24, r24
     6f8:	e1 f3       	breq	.-8      	; 0x6f2 <main+0x2da>
                
                // Interupts sperren
                cli();
     6fa:	f8 94       	cli
                // Aktion vor Bootloaderaktiverung
                do_before_bldr_activate();
     6fc:	0e 94 4e 0a 	call	0x149c	; 0x149c <do_before_bldr_activate>
                
                // alle Timer Interrups stoppen
                // C0 und C1
                TCC0.INTCTRLA = 0;
     700:	e0 e0       	ldi	r30, 0x00	; 0
     702:	f8 e0       	ldi	r31, 0x08	; 8
     704:	16 82       	std	Z+6, r1	; 0x06
                TCC0.INTCTRLB = 0;
     706:	17 82       	std	Z+7, r1	; 0x07
                TCC0.CTRLA = 0; // stop timer
     708:	10 82       	st	Z, r1
                TCC0.INTFLAGS = 0xff; // clear interrupt flags
     70a:	8f ef       	ldi	r24, 0xFF	; 255
     70c:	84 87       	std	Z+12, r24	; 0x0c
                TCC1.INTCTRLA = 0;
     70e:	e0 e4       	ldi	r30, 0x40	; 64
     710:	f8 e0       	ldi	r31, 0x08	; 8
     712:	16 82       	std	Z+6, r1	; 0x06
                TCC1.INTCTRLB = 0;
     714:	17 82       	std	Z+7, r1	; 0x07
                TCC1.CTRLA = 0; // stop timer
     716:	10 82       	st	Z, r1
                TCC1.INTFLAGS = 0xff; // clear interrupt flags
     718:	84 87       	std	Z+12, r24	; 0x0c
                // D0 und D1
                TCD0.INTCTRLA = 0;
     71a:	e0 e0       	ldi	r30, 0x00	; 0
     71c:	f9 e0       	ldi	r31, 0x09	; 9
     71e:	16 82       	std	Z+6, r1	; 0x06
                TCD0.INTCTRLB = 0;
     720:	17 82       	std	Z+7, r1	; 0x07
                TCD0.CTRLA = 0; // stop timer
     722:	10 82       	st	Z, r1
                TCD0.INTFLAGS = 0xff; // clear interrupt flags
     724:	84 87       	std	Z+12, r24	; 0x0c
                TCD1.INTCTRLA = 0;
     726:	e0 e4       	ldi	r30, 0x40	; 64
     728:	f9 e0       	ldi	r31, 0x09	; 9
     72a:	16 82       	std	Z+6, r1	; 0x06
                TCD1.INTCTRLB = 0;
     72c:	17 82       	std	Z+7, r1	; 0x07
                TCD1.CTRLA = 0; // stop timer
     72e:	10 82       	st	Z, r1
                TCD1.INTFLAGS = 0xff; // clear interrupt flags
     730:	84 87       	std	Z+12, r24	; 0x0c
                
                // start firmware update
                bldr_activate();
     732:	0e 94 00 41 	call	0x8200	; 0x8200 <bldr_vector_table>
     736:	bf ce       	rjmp	.-642    	; 0x4b6 <main+0x9e>
                // never reached
            } else {
                // ansonsten User Main ausfhren
                do_main();
     738:	0e 94 f9 07 	call	0xff2	; 0xff2 <do_main>
     73c:	bc ce       	rjmp	.-648    	; 0x4b6 <main+0x9e>
            }
        } else {
            // ansonsten schlafen legen
            sleep_mode();
     73e:	e8 e4       	ldi	r30, 0x48	; 72
     740:	f0 e0       	ldi	r31, 0x00	; 0
     742:	80 81       	ld	r24, Z
     744:	81 60       	ori	r24, 0x01	; 1
     746:	80 83       	st	Z, r24
     748:	88 95       	sleep
     74a:	80 81       	ld	r24, Z
     74c:	8e 7f       	andi	r24, 0xFE	; 254
     74e:	80 83       	st	Z, r24
        }
    }
     750:	b2 ce       	rjmp	.-668    	; 0x4b6 <main+0x9e>
        return;  // discard Ack Answers
    }
    
    // Standard Nachricht
    rc = com_process_std_msg(pmsg);
    if (rc == SBOXNET_ACKRC_SEND_NO_ANSWER) {
     752:	8f 3f       	cpi	r24, 0xFF	; 255
     754:	09 f0       	breq	.+2      	; 0x758 <main+0x340>
     756:	b4 cf       	rjmp	.-152    	; 0x6c0 <main+0x2a8>
     758:	c9 cf       	rjmp	.-110    	; 0x6ec <main+0x2d4>

0000075a <__vector_85>:
    g_dccdec.preamble = 0;
    g_dccdec.bufsize = 0;
    g_dccdec.xor = 0;
}

ISR(TCD1_CCA_vect) {
     75a:	1f 92       	push	r1
     75c:	0f 92       	push	r0
     75e:	0f b6       	in	r0, 0x3f	; 63
     760:	0f 92       	push	r0
     762:	11 24       	eor	r1, r1
     764:	2f 93       	push	r18
     766:	3f 93       	push	r19
     768:	4f 93       	push	r20
     76a:	8f 93       	push	r24
     76c:	9f 93       	push	r25
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
     772:	ef 93       	push	r30
     774:	ff 93       	push	r31
    if (g_dccdec.state == DEC_STATE_OFF) {
     776:	80 91 63 20 	lds	r24, 0x2063	; 0x802063 <g_dccdec>
     77a:	88 23       	and	r24, r24
     77c:	09 f4       	brne	.+2      	; 0x780 <__vector_85+0x26>
     77e:	00 c1       	rjmp	.+512    	; 0x980 <__vector_85+0x226>
        return;
    }
    TCD1.CTRLFSET = TC_CMD_RESTART_gc;
     780:	98 e0       	ldi	r25, 0x08	; 8
     782:	90 93 49 09 	sts	0x0949, r25	; 0x800949 <__TEXT_REGION_LENGTH__+0x7f7949>
    if (g_dccdec.state == DEC_STATE_FIRST) {
     786:	81 30       	cpi	r24, 0x01	; 1
     788:	49 f4       	brne	.+18     	; 0x79c <__vector_85+0x42>
        g_dccdec.state = DEC_STATE_PREAMBLE;
     78a:	e3 e6       	ldi	r30, 0x63	; 99
     78c:	f0 e2       	ldi	r31, 0x20	; 32
     78e:	82 e0       	ldi	r24, 0x02	; 2
     790:	80 83       	st	Z, r24
        g_dccdec.preamble = 0;
     792:	11 82       	std	Z+1, r1	; 0x01
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
     794:	81 e0       	ldi	r24, 0x01	; 1
     796:	80 93 4c 09 	sts	0x094C, r24	; 0x80094c <__TEXT_REGION_LENGTH__+0x7f794c>
     79a:	f2 c0       	rjmp	.+484    	; 0x980 <__vector_85+0x226>
    } else {
        uint8_t hb = 0;
        if (bit_is_clear(TCD1.INTFLAGS, TC1_OVFIF_bp) && TCD1.CCA < (87/2) ) {
     79c:	90 91 4c 09 	lds	r25, 0x094C	; 0x80094c <__TEXT_REGION_LENGTH__+0x7f794c>
     7a0:	90 fd       	sbrc	r25, 0
     7a2:	da c0       	rjmp	.+436    	; 0x958 <__vector_85+0x1fe>
     7a4:	20 91 68 09 	lds	r18, 0x0968	; 0x800968 <__TEXT_REGION_LENGTH__+0x7f7968>
     7a8:	30 91 69 09 	lds	r19, 0x0969	; 0x800969 <__TEXT_REGION_LENGTH__+0x7f7969>
     7ac:	91 e0       	ldi	r25, 0x01	; 1
     7ae:	2b 32       	cpi	r18, 0x2B	; 43
     7b0:	31 05       	cpc	r19, r1
     7b2:	08 f0       	brcs	.+2      	; 0x7b6 <__vector_85+0x5c>
     7b4:	90 e0       	ldi	r25, 0x00	; 0
            hb = 1;
        }
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
     7b6:	41 e0       	ldi	r20, 0x01	; 1
     7b8:	40 93 4c 09 	sts	0x094C, r20	; 0x80094c <__TEXT_REGION_LENGTH__+0x7f794c>
/*  void dec_halfbit(uint8_t hb)
 *   hb Wert des Half bits (0|1)
 * Ein halbes Bit dem Decoder zufhren.
 */
static void dec_halfbit(uint8_t hb) {
    switch(g_dccdec.state) {
     7bc:	84 30       	cpi	r24, 0x04	; 4
     7be:	81 f1       	breq	.+96     	; 0x820 <__vector_85+0xc6>
     7c0:	28 f4       	brcc	.+10     	; 0x7cc <__vector_85+0x72>
     7c2:	82 30       	cpi	r24, 0x02	; 2
     7c4:	51 f0       	breq	.+20     	; 0x7da <__vector_85+0x80>
     7c6:	83 30       	cpi	r24, 0x03	; 3
     7c8:	01 f1       	breq	.+64     	; 0x80a <__vector_85+0xb0>
     7ca:	da c0       	rjmp	.+436    	; 0x980 <__vector_85+0x226>
     7cc:	85 30       	cpi	r24, 0x05	; 5
     7ce:	09 f4       	brne	.+2      	; 0x7d2 <__vector_85+0x78>
     7d0:	49 c0       	rjmp	.+146    	; 0x864 <__vector_85+0x10a>
     7d2:	86 30       	cpi	r24, 0x06	; 6
     7d4:	09 f4       	brne	.+2      	; 0x7d8 <__vector_85+0x7e>
     7d6:	5e c0       	rjmp	.+188    	; 0x894 <__vector_85+0x13a>
     7d8:	d3 c0       	rjmp	.+422    	; 0x980 <__vector_85+0x226>
		// sind wir in der preamble?
        case DEC_STATE_PREAMBLE: {
			// Halfbit 1?
            if (hb) {
     7da:	2b 32       	cpi	r18, 0x2B	; 43
     7dc:	31 05       	cpc	r19, r1
     7de:	48 f4       	brcc	.+18     	; 0x7f2 <__vector_85+0x98>
				// ist Preamble < 100 halfbits
                if (g_dccdec.preamble < 100) {
     7e0:	80 91 64 20 	lds	r24, 0x2064	; 0x802064 <g_dccdec+0x1>
     7e4:	84 36       	cpi	r24, 0x64	; 100
     7e6:	08 f0       	brcs	.+2      	; 0x7ea <__vector_85+0x90>
     7e8:	cb c0       	rjmp	.+406    	; 0x980 <__vector_85+0x226>
					// dann Zhler erhhen
                    g_dccdec.preamble++;
     7ea:	8f 5f       	subi	r24, 0xFF	; 255
     7ec:	80 93 64 20 	sts	0x2064, r24	; 0x802064 <g_dccdec+0x1>
     7f0:	c7 c0       	rjmp	.+398    	; 0x980 <__vector_85+0x226>
                }
            } else {
				// mind 10 Bits volle Bits fr die Preamble
                if (g_dccdec.preamble >= 20) {
     7f2:	80 91 64 20 	lds	r24, 0x2064	; 0x802064 <g_dccdec+0x1>
     7f6:	84 31       	cpi	r24, 0x14	; 20
     7f8:	20 f0       	brcs	.+8      	; 0x802 <__vector_85+0xa8>
					// dann ist es ein Start Bit
                    g_dccdec.state = DEC_STATE_STARTBIT;
     7fa:	83 e0       	ldi	r24, 0x03	; 3
     7fc:	80 93 63 20 	sts	0x2063, r24	; 0x802063 <g_dccdec>
     800:	bf c0       	rjmp	.+382    	; 0x980 <__vector_85+0x226>
                } else {
					// ansonsten zurcksetzen
                    g_dccdec.preamble = 0;
     802:	10 92 64 20 	sts	0x2064, r1	; 0x802064 <g_dccdec+0x1>
     806:	bc c0       	rjmp	.+376    	; 0x980 <__vector_85+0x226>
    if (g_dccdec.state == DEC_STATE_FIRST) {
        g_dccdec.state = DEC_STATE_PREAMBLE;
        g_dccdec.preamble = 0;
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
    } else {
        uint8_t hb = 0;
     808:	90 e0       	ldi	r25, 0x00	; 0
            }
            break;
        }
		// sind wir im Start Bit?
        case DEC_STATE_STARTBIT: {
            if (hb) {
     80a:	91 11       	cpse	r25, r1
     80c:	9d c0       	rjmp	.+314    	; 0x948 <__vector_85+0x1ee>
                goto dec_reset;
            }
            g_dccdec.state = DEC_STATE_BIT_H1;
     80e:	e3 e6       	ldi	r30, 0x63	; 99
     810:	f0 e2       	ldi	r31, 0x20	; 32
     812:	84 e0       	ldi	r24, 0x04	; 4
     814:	80 83       	st	Z, r24
            g_dccdec.bufsize = 0;
     816:	14 86       	std	Z+12, r1	; 0x0c
            g_dccdec.bits = 0;
     818:	15 86       	std	Z+13, r1	; 0x0d
            g_dccdec.xor = 0;
     81a:	10 8a       	std	Z+16, r1	; 0x10
     81c:	b1 c0       	rjmp	.+354    	; 0x980 <__vector_85+0x226>
    if (g_dccdec.state == DEC_STATE_FIRST) {
        g_dccdec.state = DEC_STATE_PREAMBLE;
        g_dccdec.preamble = 0;
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
    } else {
        uint8_t hb = 0;
     81e:	90 e0       	ldi	r25, 0x00	; 0
            g_dccdec.bits = 0;
            g_dccdec.xor = 0;
            break;
        }
        case DEC_STATE_BIT_H1: {
            g_dccdec.lasthbit = hb;
     820:	e3 e6       	ldi	r30, 0x63	; 99
     822:	f0 e2       	ldi	r31, 0x20	; 32
     824:	97 87       	std	Z+15, r25	; 0x0f
            if (g_dccdec.bits < 8) {
     826:	85 85       	ldd	r24, Z+13	; 0x0d
     828:	88 30       	cpi	r24, 0x08	; 8
     82a:	20 f4       	brcc	.+8      	; 0x834 <__vector_85+0xda>
                g_dccdec.state = DEC_STATE_BIT_H2;
     82c:	85 e0       	ldi	r24, 0x05	; 5
     82e:	80 93 63 20 	sts	0x2063, r24	; 0x802063 <g_dccdec>
     832:	a6 c0       	rjmp	.+332    	; 0x980 <__vector_85+0x226>
            } else {
                if (g_dccdec.bufsize < sizeof(g_dccdec.buf)) {
     834:	e0 91 6f 20 	lds	r30, 0x206F	; 0x80206f <g_dccdec+0xc>
     838:	ea 30       	cpi	r30, 0x0A	; 10
     83a:	50 f4       	brcc	.+20     	; 0x850 <__vector_85+0xf6>
                    g_dccdec.buf[g_dccdec.bufsize++] = g_dccdec.bitbuf;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	8e 0f       	add	r24, r30
     840:	c3 e6       	ldi	r28, 0x63	; 99
     842:	d0 e2       	ldi	r29, 0x20	; 32
     844:	8c 87       	std	Y+12, r24	; 0x0c
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	8e 85       	ldd	r24, Y+14	; 0x0e
     84a:	ed 59       	subi	r30, 0x9D	; 157
     84c:	ff 4d       	sbci	r31, 0xDF	; 223
     84e:	82 83       	std	Z+2, r24	; 0x02
                }
                g_dccdec.xor ^= g_dccdec.bitbuf;
     850:	e3 e6       	ldi	r30, 0x63	; 99
     852:	f0 e2       	ldi	r31, 0x20	; 32
     854:	90 89       	ldd	r25, Z+16	; 0x10
     856:	86 85       	ldd	r24, Z+14	; 0x0e
     858:	89 27       	eor	r24, r25
     85a:	80 8b       	std	Z+16, r24	; 0x10
                g_dccdec.state = DEC_STATE_STARTSTOPBIT;
     85c:	86 e0       	ldi	r24, 0x06	; 6
     85e:	80 83       	st	Z, r24
     860:	8f c0       	rjmp	.+286    	; 0x980 <__vector_85+0x226>
    if (g_dccdec.state == DEC_STATE_FIRST) {
        g_dccdec.state = DEC_STATE_PREAMBLE;
        g_dccdec.preamble = 0;
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
    } else {
        uint8_t hb = 0;
     862:	90 e0       	ldi	r25, 0x00	; 0
                g_dccdec.state = DEC_STATE_STARTSTOPBIT;
            }
            break;
        }
        case DEC_STATE_BIT_H2: {
            if (hb != g_dccdec.lasthbit) {
     864:	80 91 72 20 	lds	r24, 0x2072	; 0x802072 <g_dccdec+0xf>
     868:	89 13       	cpse	r24, r25
     86a:	6e c0       	rjmp	.+220    	; 0x948 <__vector_85+0x1ee>
                goto dec_reset;
            }
            g_dccdec.bitbuf <<= 1;
     86c:	90 91 71 20 	lds	r25, 0x2071	; 0x802071 <g_dccdec+0xe>
     870:	99 0f       	add	r25, r25
            if (hb) {
     872:	81 11       	cpse	r24, r1
     874:	03 c0       	rjmp	.+6      	; 0x87c <__vector_85+0x122>
        }
        case DEC_STATE_BIT_H2: {
            if (hb != g_dccdec.lasthbit) {
                goto dec_reset;
            }
            g_dccdec.bitbuf <<= 1;
     876:	90 93 71 20 	sts	0x2071, r25	; 0x802071 <g_dccdec+0xe>
     87a:	03 c0       	rjmp	.+6      	; 0x882 <__vector_85+0x128>
            if (hb) {
                g_dccdec.bitbuf |= 0x01;
     87c:	91 60       	ori	r25, 0x01	; 1
     87e:	90 93 71 20 	sts	0x2071, r25	; 0x802071 <g_dccdec+0xe>
            }
            g_dccdec.bits++;
     882:	e3 e6       	ldi	r30, 0x63	; 99
     884:	f0 e2       	ldi	r31, 0x20	; 32
     886:	85 85       	ldd	r24, Z+13	; 0x0d
     888:	8f 5f       	subi	r24, 0xFF	; 255
     88a:	85 87       	std	Z+13, r24	; 0x0d
            g_dccdec.state = DEC_STATE_BIT_H1;
     88c:	84 e0       	ldi	r24, 0x04	; 4
     88e:	80 83       	st	Z, r24
     890:	77 c0       	rjmp	.+238    	; 0x980 <__vector_85+0x226>
    if (g_dccdec.state == DEC_STATE_FIRST) {
        g_dccdec.state = DEC_STATE_PREAMBLE;
        g_dccdec.preamble = 0;
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
    } else {
        uint8_t hb = 0;
     892:	90 e0       	ldi	r25, 0x00	; 0
            g_dccdec.bits++;
            g_dccdec.state = DEC_STATE_BIT_H1;
            break;
        }
        case DEC_STATE_STARTSTOPBIT: {
            if (hb != g_dccdec.lasthbit) {
     894:	80 91 72 20 	lds	r24, 0x2072	; 0x802072 <g_dccdec+0xf>
     898:	89 13       	cpse	r24, r25
     89a:	56 c0       	rjmp	.+172    	; 0x948 <__vector_85+0x1ee>
                goto dec_reset;
            }
            if (hb) { // end of packet bit ?
     89c:	88 23       	and	r24, r24
     89e:	09 f4       	brne	.+2      	; 0x8a2 <__vector_85+0x148>
     8a0:	4d c0       	rjmp	.+154    	; 0x93c <__vector_85+0x1e2>
/* void dec_parse_packet(void)
 * Ein DCC Packet parsen im User Code.
 */ 
static void dec_parse_packet(void) {
	// wenn mehr als 3 Bits im Buffer sind und der XOR Wert 0 ist
    if (g_dccdec.bufsize >= 3 && g_dccdec.xor == 0) {
     8a2:	80 91 6f 20 	lds	r24, 0x206F	; 0x80206f <g_dccdec+0xc>
     8a6:	83 30       	cpi	r24, 0x03	; 3
     8a8:	08 f4       	brcc	.+2      	; 0x8ac <__vector_85+0x152>
     8aa:	4e c0       	rjmp	.+156    	; 0x948 <__vector_85+0x1ee>
     8ac:	80 91 73 20 	lds	r24, 0x2073	; 0x802073 <g_dccdec+0x10>
     8b0:	81 11       	cpse	r24, r1
     8b2:	4a c0       	rjmp	.+148    	; 0x948 <__vector_85+0x1ee>
};
struct Eeprom g_eeprom EEMEM;


static void do_dec_parse_packet(void) {
    if (!g_power_on || !timer_timedout(&g_power_on_timer)) {
     8b4:	80 91 5e 20 	lds	r24, 0x205E	; 0x80205e <g_power_on>
     8b8:	88 23       	and	r24, r24
     8ba:	09 f4       	brne	.+2      	; 0x8be <__vector_85+0x164>
     8bc:	45 c0       	rjmp	.+138    	; 0x948 <__vector_85+0x1ee>
    }
    t->value = 0;
}

static INLINE uint8_t timer_timedout(struct timer* t) {
    return t->value == 0;
     8be:	80 91 62 20 	lds	r24, 0x2062	; 0x802062 <g_power_on_timer+0x2>
     8c2:	81 11       	cpse	r24, r1
     8c4:	41 c0       	rjmp	.+130    	; 0x948 <__vector_85+0x1ee>
        return;
    }
    
    if (g_dccdec.buf[0] != 0 // broadcast or reset
     8c6:	80 91 65 20 	lds	r24, 0x2065	; 0x802065 <g_dccdec+0x2>
           && g_dccdec.buf[0] != 0xff) { // idle
     8ca:	9f ef       	ldi	r25, 0xFF	; 255
     8cc:	98 0f       	add	r25, r24
static void do_dec_parse_packet(void) {
    if (!g_power_on || !timer_timedout(&g_power_on_timer)) {
        return;
    }
    
    if (g_dccdec.buf[0] != 0 // broadcast or reset
     8ce:	9e 3f       	cpi	r25, 0xFE	; 254
     8d0:	d8 f5       	brcc	.+118    	; 0x948 <__vector_85+0x1ee>
           && g_dccdec.buf[0] != 0xff) { // idle
        
        g_dec_lastaddr = 0;
     8d2:	10 92 11 20 	sts	0x2011, r1	; 0x802011 <g_dec_lastaddr>
     8d6:	10 92 12 20 	sts	0x2012, r1	; 0x802012 <g_dec_lastaddr+0x1>
        if (g_dccdec.buf[0] <= 0x7f) {
     8da:	88 23       	and	r24, r24
     8dc:	34 f0       	brlt	.+12     	; 0x8ea <__vector_85+0x190>
            g_dec_lastaddr = g_dccdec.buf[0];
     8de:	90 e0       	ldi	r25, 0x00	; 0
     8e0:	80 93 11 20 	sts	0x2011, r24	; 0x802011 <g_dec_lastaddr>
     8e4:	90 93 12 20 	sts	0x2012, r25	; 0x802012 <g_dec_lastaddr+0x1>
     8e8:	0e c0       	rjmp	.+28     	; 0x906 <__vector_85+0x1ac>
        } else if (g_dccdec.buf[0] >= 192 && g_dccdec.buf[0] <= 231) {
     8ea:	90 e4       	ldi	r25, 0x40	; 64
     8ec:	98 0f       	add	r25, r24
     8ee:	98 32       	cpi	r25, 0x28	; 40
     8f0:	58 f5       	brcc	.+86     	; 0x948 <__vector_85+0x1ee>
            g_dec_lastaddr = ((uint16_t)g_dccdec.buf[0] << 8) | g_dccdec.buf[1];
     8f2:	90 e0       	ldi	r25, 0x00	; 0
     8f4:	98 2f       	mov	r25, r24
     8f6:	88 27       	eor	r24, r24
     8f8:	20 91 66 20 	lds	r18, 0x2066	; 0x802066 <g_dccdec+0x3>
     8fc:	82 2b       	or	r24, r18
     8fe:	80 93 11 20 	sts	0x2011, r24	; 0x802011 <g_dec_lastaddr>
     902:	90 93 12 20 	sts	0x2012, r25	; 0x802012 <g_dec_lastaddr+0x1>
        }
        if (g_dec_lastaddr) {
     906:	80 91 11 20 	lds	r24, 0x2011	; 0x802011 <g_dec_lastaddr>
     90a:	90 91 12 20 	lds	r25, 0x2012	; 0x802012 <g_dec_lastaddr+0x1>
     90e:	89 2b       	or	r24, r25
     910:	d9 f0       	breq	.+54     	; 0x948 <__vector_85+0x1ee>
            ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
     912:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
     914:	f8 94       	cli
                TCD0.CCC = TCD0.CNT + (290/2);
     916:	e0 e0       	ldi	r30, 0x00	; 0
     918:	f9 e0       	ldi	r31, 0x09	; 9
     91a:	80 a1       	ldd	r24, Z+32	; 0x20
     91c:	91 a1       	ldd	r25, Z+33	; 0x21
     91e:	8f 56       	subi	r24, 0x6F	; 111
     920:	9f 4f       	sbci	r25, 0xFF	; 255
     922:	84 a7       	std	Z+44, r24	; 0x2c
     924:	95 a7       	std	Z+45, r25	; 0x2d
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
     926:	2f bf       	out	0x3f, r18	; 63
            }
            TCD0.INTFLAGS = Bit(TC0_CCCIF_bp);
     928:	80 e4       	ldi	r24, 0x40	; 64
     92a:	84 87       	std	Z+12, r24	; 0x0c
            TCD0.INTCTRLB = (TCD0.INTCTRLB & ~TC0_CCCINTLVL_gm)|TC_CCCINTLVL_LO_gc;
     92c:	87 81       	ldd	r24, Z+7	; 0x07
     92e:	8f 7c       	andi	r24, 0xCF	; 207
     930:	80 61       	ori	r24, 0x10	; 16
     932:	87 83       	std	Z+7, r24	; 0x07
    
            port_clrbit(PORTB, 2);
     934:	84 e0       	ldi	r24, 0x04	; 4
     936:	80 93 26 06 	sts	0x0626, r24	; 0x800626 <__TEXT_REGION_LENGTH__+0x7f7626>
     93a:	06 c0       	rjmp	.+12     	; 0x948 <__vector_85+0x1ee>
            if (hb) { // end of packet bit ?
                dec_parse_packet();
                goto dec_reset;
                
            } else { // stop bit
                g_dccdec.state = DEC_STATE_BIT_H1;
     93c:	e3 e6       	ldi	r30, 0x63	; 99
     93e:	f0 e2       	ldi	r31, 0x20	; 32
     940:	84 e0       	ldi	r24, 0x04	; 4
     942:	80 83       	st	Z, r24
                g_dccdec.bits = 0;
     944:	15 86       	std	Z+13, r1	; 0x0d
     946:	1c c0       	rjmp	.+56     	; 0x980 <__vector_85+0x226>
        }
    }
    return;
    
dec_reset:
    g_dccdec.state = DEC_STATE_PREAMBLE;
     948:	e3 e6       	ldi	r30, 0x63	; 99
     94a:	f0 e2       	ldi	r31, 0x20	; 32
     94c:	82 e0       	ldi	r24, 0x02	; 2
     94e:	80 83       	st	Z, r24
    g_dccdec.preamble = 0;
     950:	11 82       	std	Z+1, r1	; 0x01
    g_dccdec.bufsize = 0;
     952:	14 86       	std	Z+12, r1	; 0x0c
    g_dccdec.xor = 0;
     954:	10 8a       	std	Z+16, r1	; 0x10
     956:	14 c0       	rjmp	.+40     	; 0x980 <__vector_85+0x226>
    } else {
        uint8_t hb = 0;
        if (bit_is_clear(TCD1.INTFLAGS, TC1_OVFIF_bp) && TCD1.CCA < (87/2) ) {
            hb = 1;
        }
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
     958:	91 e0       	ldi	r25, 0x01	; 1
     95a:	90 93 4c 09 	sts	0x094C, r25	; 0x80094c <__TEXT_REGION_LENGTH__+0x7f794c>
/*  void dec_halfbit(uint8_t hb)
 *   hb Wert des Half bits (0|1)
 * Ein halbes Bit dem Decoder zufhren.
 */
static void dec_halfbit(uint8_t hb) {
    switch(g_dccdec.state) {
     95e:	84 30       	cpi	r24, 0x04	; 4
     960:	09 f4       	brne	.+2      	; 0x964 <__vector_85+0x20a>
     962:	5d cf       	rjmp	.-326    	; 0x81e <__vector_85+0xc4>
     964:	38 f4       	brcc	.+14     	; 0x974 <__vector_85+0x21a>
     966:	82 30       	cpi	r24, 0x02	; 2
     968:	09 f4       	brne	.+2      	; 0x96c <__vector_85+0x212>
     96a:	43 cf       	rjmp	.-378    	; 0x7f2 <__vector_85+0x98>
     96c:	83 30       	cpi	r24, 0x03	; 3
     96e:	09 f4       	brne	.+2      	; 0x972 <__vector_85+0x218>
     970:	4b cf       	rjmp	.-362    	; 0x808 <__vector_85+0xae>
     972:	06 c0       	rjmp	.+12     	; 0x980 <__vector_85+0x226>
     974:	85 30       	cpi	r24, 0x05	; 5
     976:	09 f4       	brne	.+2      	; 0x97a <__vector_85+0x220>
     978:	74 cf       	rjmp	.-280    	; 0x862 <__vector_85+0x108>
     97a:	86 30       	cpi	r24, 0x06	; 6
     97c:	09 f4       	brne	.+2      	; 0x980 <__vector_85+0x226>
     97e:	89 cf       	rjmp	.-238    	; 0x892 <__vector_85+0x138>
            hb = 1;
        }
        TCD1.INTFLAGS = Bit(TC1_OVFIF_bp);
        dec_halfbit(hb);
    }
}
     980:	ff 91       	pop	r31
     982:	ef 91       	pop	r30
     984:	df 91       	pop	r29
     986:	cf 91       	pop	r28
     988:	9f 91       	pop	r25
     98a:	8f 91       	pop	r24
     98c:	4f 91       	pop	r20
     98e:	3f 91       	pop	r19
     990:	2f 91       	pop	r18
     992:	0f 90       	pop	r0
     994:	0f be       	out	0x3f, r0	; 63
     996:	0f 90       	pop	r0
     998:	1f 90       	pop	r1
     99a:	18 95       	reti

0000099c <__vector_81>:
        }
    }
}

ISR(TCD0_CCC_vect) {
     99c:	1f 92       	push	r1
     99e:	0f 92       	push	r0
     9a0:	0f b6       	in	r0, 0x3f	; 63
     9a2:	0f 92       	push	r0
     9a4:	11 24       	eor	r1, r1
     9a6:	2f 93       	push	r18
     9a8:	3f 93       	push	r19
     9aa:	4f 93       	push	r20
     9ac:	5f 93       	push	r21
     9ae:	6f 93       	push	r22
     9b0:	7f 93       	push	r23
     9b2:	8f 93       	push	r24
     9b4:	9f 93       	push	r25
     9b6:	af 93       	push	r26
     9b8:	bf 93       	push	r27
     9ba:	cf 93       	push	r28
     9bc:	df 93       	push	r29
     9be:	ef 93       	push	r30
     9c0:	ff 93       	push	r31
    TCD0.INTCTRLB = (TCD0.INTCTRLB & ~TC0_CCCINTLVL_gm)|TC_CCCINTLVL_OFF_gc;
     9c2:	e0 e0       	ldi	r30, 0x00	; 0
     9c4:	f9 e0       	ldi	r31, 0x09	; 9
     9c6:	87 81       	ldd	r24, Z+7	; 0x07
     9c8:	8f 7c       	andi	r24, 0xCF	; 207
     9ca:	87 83       	std	Z+7, r24	; 0x07
    
    //port_setbit(PORTB, 2);
    uint8_t sens1 = ~port_in(PORTA);
     9cc:	90 91 08 06 	lds	r25, 0x0608	; 0x800608 <__TEXT_REGION_LENGTH__+0x7f7608>
    uint8_t sens2 = ~port_in(PORTC);
     9d0:	20 91 48 06 	lds	r18, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x7f7648>
static inline uint8_t ringbuf_isfull(struct ring_buffer* a_rb) {
    return a_rb->count == a_rb->size;
}

static inline uint8_t ringbuf_getfree(struct ring_buffer* a_rb) {
    return a_rb->size - a_rb->count;
     9d4:	ea e1       	ldi	r30, 0x1A	; 26
     9d6:	f0 e2       	ldi	r31, 0x20	; 32
     9d8:	82 81       	ldd	r24, Z+2	; 0x02
     9da:	33 81       	ldd	r19, Z+3	; 0x03
     9dc:	83 1b       	sub	r24, r19
    // sensoren lesen
    uint16_t sens = ((uint16_t)sens2 << 8 | sens1) & g_sensor_bits;
    if (pipe_getfree(&g_locoaddr_pipe.pipe) >= 4) {
     9de:	84 30       	cpi	r24, 0x04	; 4
     9e0:	00 f1       	brcs	.+64     	; 0xa22 <__vector_81+0x86>
    
    //port_setbit(PORTB, 2);
    uint8_t sens1 = ~port_in(PORTA);
    uint8_t sens2 = ~port_in(PORTC);
    // sensoren lesen
    uint16_t sens = ((uint16_t)sens2 << 8 | sens1) & g_sensor_bits;
     9e2:	c0 91 17 20 	lds	r28, 0x2017	; 0x802017 <g_sensor_bits>
     9e6:	d0 91 18 20 	lds	r29, 0x2018	; 0x802018 <g_sensor_bits+0x1>

ISR(TCD0_CCC_vect) {
    TCD0.INTCTRLB = (TCD0.INTCTRLB & ~TC0_CCCINTLVL_gm)|TC_CCCINTLVL_OFF_gc;
    
    //port_setbit(PORTB, 2);
    uint8_t sens1 = ~port_in(PORTA);
     9ea:	90 95       	com	r25
    uint8_t sens2 = ~port_in(PORTC);
     9ec:	20 95       	com	r18
    // sensoren lesen
    uint16_t sens = ((uint16_t)sens2 << 8 | sens1) & g_sensor_bits;
     9ee:	89 2f       	mov	r24, r25
     9f0:	90 e0       	ldi	r25, 0x00	; 0
     9f2:	92 2b       	or	r25, r18
     9f4:	c8 23       	and	r28, r24
     9f6:	d9 23       	and	r29, r25
    if (pipe_getfree(&g_locoaddr_pipe.pipe) >= 4) {
        pipe_write(&g_locoaddr_pipe.pipe, lowbyte(g_dec_lastaddr));
     9f8:	60 91 11 20 	lds	r22, 0x2011	; 0x802011 <g_dec_lastaddr>
static INLINE uint8_t pipe_getfree(pipe_t* p) {
    return ringbuf_getfree(&p->rb);
}

static INLINE void pipe_write(pipe_t* p, uint8_t v) {
    ringbuf_write(&p->rb, v);
     9fc:	cf 01       	movw	r24, r30
     9fe:	0e 94 44 01 	call	0x288	; 0x288 <ringbuf_write>
        pipe_write(&g_locoaddr_pipe.pipe, highbyte(g_dec_lastaddr));
     a02:	60 91 12 20 	lds	r22, 0x2012	; 0x802012 <g_dec_lastaddr+0x1>
     a06:	8a e1       	ldi	r24, 0x1A	; 26
     a08:	90 e2       	ldi	r25, 0x20	; 32
     a0a:	0e 94 44 01 	call	0x288	; 0x288 <ringbuf_write>
     a0e:	6c 2f       	mov	r22, r28
     a10:	8a e1       	ldi	r24, 0x1A	; 26
     a12:	90 e2       	ldi	r25, 0x20	; 32
     a14:	0e 94 44 01 	call	0x288	; 0x288 <ringbuf_write>
     a18:	6d 2f       	mov	r22, r29
     a1a:	8a e1       	ldi	r24, 0x1A	; 26
     a1c:	90 e2       	ldi	r25, 0x20	; 32
     a1e:	0e 94 44 01 	call	0x288	; 0x288 <ringbuf_write>
        pipe_write(&g_locoaddr_pipe.pipe, lowbyte(sens));
        pipe_write(&g_locoaddr_pipe.pipe, highbyte(sens));
    }
    g_dec_lastaddr = 0;
     a22:	10 92 11 20 	sts	0x2011, r1	; 0x802011 <g_dec_lastaddr>
     a26:	10 92 12 20 	sts	0x2012, r1	; 0x802012 <g_dec_lastaddr+0x1>
}
     a2a:	ff 91       	pop	r31
     a2c:	ef 91       	pop	r30
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	bf 91       	pop	r27
     a34:	af 91       	pop	r26
     a36:	9f 91       	pop	r25
     a38:	8f 91       	pop	r24
     a3a:	7f 91       	pop	r23
     a3c:	6f 91       	pop	r22
     a3e:	5f 91       	pop	r21
     a40:	4f 91       	pop	r20
     a42:	3f 91       	pop	r19
     a44:	2f 91       	pop	r18
     a46:	0f 90       	pop	r0
     a48:	0f be       	out	0x3f, r0	; 63
     a4a:	0f 90       	pop	r0
     a4c:	1f 90       	pop	r1
     a4e:	18 95       	reti

00000a50 <show_besetzt_leds>:
// fr neue Hardware!
void show_besetzt_leds(void) {
	// PC6 (Bit 0) und PC7 (Bit 1)
	// PD0..PD7(Bit 2 .. 9)
	// zuerst mal alles aus
	port_clr(PORTC, Bit(0)|Bit(1));
     a50:	83 e0       	ldi	r24, 0x03	; 3
     a52:	80 93 46 06 	sts	0x0646, r24	; 0x800646 <__TEXT_REGION_LENGTH__+0x7f7646>
	port_out(PORTD) = 0;
     a56:	10 92 64 06 	sts	0x0664, r1	; 0x800664 <__TEXT_REGION_LENGTH__+0x7f7664>
	uint16_t inp = g_sensor_bits;
     a5a:	60 91 17 20 	lds	r22, 0x2017	; 0x802017 <g_sensor_bits>
     a5e:	70 91 18 20 	lds	r23, 0x2018	; 0x802018 <g_sensor_bits+0x1>
	for (uint8_t i = 0; i < NUM_SENSORS; i++) {
     a62:	20 e0       	ldi	r18, 0x00	; 0
     a64:	47 c0       	rjmp	.+142    	; 0xaf4 <show_besetzt_leds+0xa4>
		// if sensor is on -> led ON
		uint16_t mask = 1 << i;
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	90 e0       	ldi	r25, 0x00	; 0
     a6a:	02 c0       	rjmp	.+4      	; 0xa70 <show_besetzt_leds+0x20>
     a6c:	88 0f       	add	r24, r24
     a6e:	99 1f       	adc	r25, r25
     a70:	4a 95       	dec	r20
     a72:	e2 f7       	brpl	.-8      	; 0xa6c <show_besetzt_leds+0x1c>
		if (inp & mask) {
     a74:	86 23       	and	r24, r22
     a76:	97 23       	and	r25, r23
     a78:	89 2b       	or	r24, r25
     a7a:	d9 f1       	breq	.+118    	; 0xaf2 <show_besetzt_leds+0xa2>
			if (i == 0) {
     a7c:	21 11       	cpse	r18, r1
     a7e:	04 c0       	rjmp	.+8      	; 0xa88 <show_besetzt_leds+0x38>
				port_set(PORTC, Bit(6));
     a80:	80 e4       	ldi	r24, 0x40	; 64
     a82:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x7f7645>
     a86:	35 c0       	rjmp	.+106    	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 1 ) {
     a88:	21 30       	cpi	r18, 0x01	; 1
     a8a:	21 f4       	brne	.+8      	; 0xa94 <show_besetzt_leds+0x44>
				port_set(PORTC, Bit(7));
     a8c:	80 e8       	ldi	r24, 0x80	; 128
     a8e:	80 93 45 06 	sts	0x0645, r24	; 0x800645 <__TEXT_REGION_LENGTH__+0x7f7645>
     a92:	2f c0       	rjmp	.+94     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 2) {
     a94:	22 30       	cpi	r18, 0x02	; 2
     a96:	21 f4       	brne	.+8      	; 0xaa0 <show_besetzt_leds+0x50>
				port_set(PORTD, Bit(0));
     a98:	81 e0       	ldi	r24, 0x01	; 1
     a9a:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
     a9e:	29 c0       	rjmp	.+82     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 3) {
     aa0:	23 30       	cpi	r18, 0x03	; 3
     aa2:	21 f4       	brne	.+8      	; 0xaac <show_besetzt_leds+0x5c>
				port_set(PORTD, Bit(1));
     aa4:	82 e0       	ldi	r24, 0x02	; 2
     aa6:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
     aaa:	23 c0       	rjmp	.+70     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 4) {
     aac:	24 30       	cpi	r18, 0x04	; 4
     aae:	21 f4       	brne	.+8      	; 0xab8 <show_besetzt_leds+0x68>
				port_set(PORTD, Bit(2));
     ab0:	84 e0       	ldi	r24, 0x04	; 4
     ab2:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
     ab6:	1d c0       	rjmp	.+58     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 5) {
     ab8:	25 30       	cpi	r18, 0x05	; 5
     aba:	21 f4       	brne	.+8      	; 0xac4 <show_besetzt_leds+0x74>
				port_set(PORTD, Bit(3));
     abc:	88 e0       	ldi	r24, 0x08	; 8
     abe:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
     ac2:	17 c0       	rjmp	.+46     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 6) {
     ac4:	26 30       	cpi	r18, 0x06	; 6
     ac6:	21 f4       	brne	.+8      	; 0xad0 <show_besetzt_leds+0x80>
				port_set(PORTD, Bit(4));
     ac8:	80 e1       	ldi	r24, 0x10	; 16
     aca:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
     ace:	11 c0       	rjmp	.+34     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 7) {
     ad0:	27 30       	cpi	r18, 0x07	; 7
     ad2:	21 f4       	brne	.+8      	; 0xadc <show_besetzt_leds+0x8c>
				port_set(PORTD, Bit(5));
     ad4:	80 e2       	ldi	r24, 0x20	; 32
     ad6:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
     ada:	0b c0       	rjmp	.+22     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 8) {
     adc:	28 30       	cpi	r18, 0x08	; 8
     ade:	21 f4       	brne	.+8      	; 0xae8 <show_besetzt_leds+0x98>
				port_set(PORTD, Bit(6));
     ae0:	80 e4       	ldi	r24, 0x40	; 64
     ae2:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
     ae6:	05 c0       	rjmp	.+10     	; 0xaf2 <show_besetzt_leds+0xa2>
				} else if (i == 9) {
     ae8:	29 30       	cpi	r18, 0x09	; 9
     aea:	19 f4       	brne	.+6      	; 0xaf2 <show_besetzt_leds+0xa2>
				port_set(PORTD, Bit(7));
     aec:	80 e8       	ldi	r24, 0x80	; 128
     aee:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x7f7665>
	// PD0..PD7(Bit 2 .. 9)
	// zuerst mal alles aus
	port_clr(PORTC, Bit(0)|Bit(1));
	port_out(PORTD) = 0;
	uint16_t inp = g_sensor_bits;
	for (uint8_t i = 0; i < NUM_SENSORS; i++) {
     af2:	2f 5f       	subi	r18, 0xFF	; 255
     af4:	42 2f       	mov	r20, r18
     af6:	50 e0       	ldi	r21, 0x00	; 0
     af8:	80 91 19 20 	lds	r24, 0x2019	; 0x802019 <hardwaretyp>
     afc:	81 30       	cpi	r24, 0x01	; 1
     afe:	19 f0       	breq	.+6      	; 0xb06 <show_besetzt_leds+0xb6>
     b00:	80 e1       	ldi	r24, 0x10	; 16
     b02:	90 e0       	ldi	r25, 0x00	; 0
     b04:	02 c0       	rjmp	.+4      	; 0xb0a <show_besetzt_leds+0xba>
     b06:	8a e0       	ldi	r24, 0x0A	; 10
     b08:	90 e0       	ldi	r25, 0x00	; 0
     b0a:	48 17       	cp	r20, r24
     b0c:	59 07       	cpc	r21, r25
     b0e:	0c f4       	brge	.+2      	; 0xb12 <show_besetzt_leds+0xc2>
     b10:	aa cf       	rjmp	.-172    	; 0xa66 <show_besetzt_leds+0x16>
				} else if (i == 9) {
				port_set(PORTD, Bit(7));
			}
		}
	}
}
     b12:	08 95       	ret

00000b14 <multiplex_leds>:

// only for old hardware
void multiplex_leds(void) {
    uint8_t ledrow = (g_led_counter++) & 0x03;
     b14:	20 91 14 20 	lds	r18, 0x2014	; 0x802014 <g_led_counter>
     b18:	81 e0       	ldi	r24, 0x01	; 1
     b1a:	82 0f       	add	r24, r18
     b1c:	80 93 14 20 	sts	0x2014, r24	; 0x802014 <g_led_counter>
     b20:	23 70       	andi	r18, 0x03	; 3
    uint16_t inp = g_sensor_bits;
     b22:	80 91 17 20 	lds	r24, 0x2017	; 0x802017 <g_sensor_bits>
     b26:	90 91 18 20 	lds	r25, 0x2018	; 0x802018 <g_sensor_bits+0x1>
    uint8_t b;
    switch (ledrow) {
     b2a:	21 30       	cpi	r18, 0x01	; 1
     b2c:	31 f0       	breq	.+12     	; 0xb3a <multiplex_leds+0x26>
     b2e:	18 f0       	brcs	.+6      	; 0xb36 <multiplex_leds+0x22>
     b30:	22 30       	cpi	r18, 0x02	; 2
     b32:	59 f0       	breq	.+22     	; 0xb4a <multiplex_leds+0x36>
     b34:	0d c0       	rjmp	.+26     	; 0xb50 <multiplex_leds+0x3c>
        case 0: ledrow = ~Bit(4) & 0xf0; b = inp; break;
     b36:	90 ee       	ldi	r25, 0xE0	; 224
     b38:	0f c0       	rjmp	.+30     	; 0xb58 <multiplex_leds+0x44>
        case 1: ledrow = ~Bit(5) & 0xf0; b = (inp >> 4); break;
     b3a:	92 95       	swap	r25
     b3c:	82 95       	swap	r24
     b3e:	8f 70       	andi	r24, 0x0F	; 15
     b40:	89 27       	eor	r24, r25
     b42:	9f 70       	andi	r25, 0x0F	; 15
     b44:	89 27       	eor	r24, r25
     b46:	90 ed       	ldi	r25, 0xD0	; 208
     b48:	07 c0       	rjmp	.+14     	; 0xb58 <multiplex_leds+0x44>
        case 2: ledrow = ~Bit(6) & 0xf0; b = (inp >> 8); break;
     b4a:	89 2f       	mov	r24, r25
     b4c:	90 eb       	ldi	r25, 0xB0	; 176
     b4e:	04 c0       	rjmp	.+8      	; 0xb58 <multiplex_leds+0x44>
        default: ledrow = ~Bit(7) & 0xf0; b = (inp >> 12); break;
     b50:	89 2f       	mov	r24, r25
     b52:	82 95       	swap	r24
     b54:	8f 70       	andi	r24, 0x0F	; 15
     b56:	90 e7       	ldi	r25, 0x70	; 112
    }
    // all leds off
    port_out(PORTD) = ledrow | (b & 0x0f);
     b58:	8f 70       	andi	r24, 0x0F	; 15
     b5a:	89 2b       	or	r24, r25
     b5c:	80 93 64 06 	sts	0x0664, r24	; 0x800664 <__TEXT_REGION_LENGTH__+0x7f7664>
     b60:	08 95       	ret

00000b62 <get_next_transmit_seq>:
}

uint8_t get_next_transmit_seq(void) {
    uint8_t seq = g_transmit_seq + 1;
     b62:	80 91 13 20 	lds	r24, 0x2013	; 0x802013 <g_transmit_seq>
     b66:	8f 5f       	subi	r24, 0xFF	; 255
    if (seq < 10) {
     b68:	8a 30       	cpi	r24, 0x0A	; 10
     b6a:	08 f4       	brcc	.+2      	; 0xb6e <get_next_transmit_seq+0xc>
        seq = 10;
     b6c:	8a e0       	ldi	r24, 0x0A	; 10
    }
    
    for (uint8_t i = 0; i < NUM_SENSORS; i++) {
        if (g_sensors[i].flags.notack && seq == g_sensors[i].last_seq) {
            seq++;
            i = 0; // retry
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	1f c0       	rjmp	.+62     	; 0xbb0 <get_next_transmit_seq+0x4e>
    if (seq < 10) {
        seq = 10;
    }
    
    for (uint8_t i = 0; i < NUM_SENSORS; i++) {
        if (g_sensors[i].flags.notack && seq == g_sensors[i].last_seq) {
     b72:	f9 01       	movw	r30, r18
     b74:	ee 0f       	add	r30, r30
     b76:	ff 1f       	adc	r31, r31
     b78:	ee 0f       	add	r30, r30
     b7a:	ff 1f       	adc	r31, r31
     b7c:	ee 0f       	add	r30, r30
     b7e:	ff 1f       	adc	r31, r31
     b80:	e2 1b       	sub	r30, r18
     b82:	f3 0b       	sbc	r31, r19
     b84:	e5 58       	subi	r30, 0x85	; 133
     b86:	ff 4d       	sbci	r31, 0xDF	; 223
     b88:	40 81       	ld	r20, Z
     b8a:	40 ff       	sbrs	r20, 0
     b8c:	10 c0       	rjmp	.+32     	; 0xbae <get_next_transmit_seq+0x4c>
     b8e:	f9 01       	movw	r30, r18
     b90:	ee 0f       	add	r30, r30
     b92:	ff 1f       	adc	r31, r31
     b94:	ee 0f       	add	r30, r30
     b96:	ff 1f       	adc	r31, r31
     b98:	ee 0f       	add	r30, r30
     b9a:	ff 1f       	adc	r31, r31
     b9c:	e2 1b       	sub	r30, r18
     b9e:	f3 0b       	sbc	r31, r19
     ba0:	ea 58       	subi	r30, 0x8A	; 138
     ba2:	ff 4d       	sbci	r31, 0xDF	; 223
     ba4:	23 81       	ldd	r18, Z+3	; 0x03
     ba6:	82 13       	cpse	r24, r18
     ba8:	02 c0       	rjmp	.+4      	; 0xbae <get_next_transmit_seq+0x4c>
            seq++;
     baa:	8f 5f       	subi	r24, 0xFF	; 255
            i = 0; // retry
     bac:	90 e0       	ldi	r25, 0x00	; 0
    uint8_t seq = g_transmit_seq + 1;
    if (seq < 10) {
        seq = 10;
    }
    
    for (uint8_t i = 0; i < NUM_SENSORS; i++) {
     bae:	9f 5f       	subi	r25, 0xFF	; 255
     bb0:	29 2f       	mov	r18, r25
     bb2:	30 e0       	ldi	r19, 0x00	; 0
     bb4:	40 91 19 20 	lds	r20, 0x2019	; 0x802019 <hardwaretyp>
     bb8:	41 30       	cpi	r20, 0x01	; 1
     bba:	19 f0       	breq	.+6      	; 0xbc2 <get_next_transmit_seq+0x60>
     bbc:	40 e1       	ldi	r20, 0x10	; 16
     bbe:	50 e0       	ldi	r21, 0x00	; 0
     bc0:	02 c0       	rjmp	.+4      	; 0xbc6 <get_next_transmit_seq+0x64>
     bc2:	4a e0       	ldi	r20, 0x0A	; 10
     bc4:	50 e0       	ldi	r21, 0x00	; 0
     bc6:	24 17       	cp	r18, r20
     bc8:	35 07       	cpc	r19, r21
     bca:	9c f2       	brlt	.-90     	; 0xb72 <get_next_transmit_seq+0x10>
            seq++;
            i = 0; // retry
        }   
    }

    g_transmit_seq = seq;
     bcc:	80 93 13 20 	sts	0x2013, r24	; 0x802013 <g_transmit_seq>
    return seq;
}
     bd0:	08 95       	ret

00000bd2 <do_init_system>:

void do_init_system(void) {
     bd2:	ff 92       	push	r15
     bd4:	0f 93       	push	r16
     bd6:	1f 93       	push	r17
     bd8:	cf 93       	push	r28
     bda:	df 93       	push	r29
     bdc:	1f 92       	push	r1
     bde:	cd b7       	in	r28, 0x3d	; 61
     be0:	de b7       	in	r29, 0x3e	; 62
	// Erst Hardware prfen
	// PORTB auf Input: PB0..PB3
	port_dirin(PORTB, 0x0f);
     be2:	e0 e2       	ldi	r30, 0x20	; 32
     be4:	f6 e0       	ldi	r31, 0x06	; 6
     be6:	8f e0       	ldi	r24, 0x0F	; 15
     be8:	82 83       	std	Z+2, r24	; 0x02
	// und Eingabe berprfen
	uint8_t pbin = port_in(PORTB);
     bea:	80 85       	ldd	r24, Z+8	; 0x08
     bec:	89 83       	std	Y+1, r24	; 0x01
	// ist PB0 und PB2 auf Low, PB1 und PB3 auf High ==> neue Hardware
	if (bit_is_set(pbin, 2) && bit_is_clear(pbin, 1) && bit_is_clear(pbin, 3)) {
     bee:	89 81       	ldd	r24, Y+1	; 0x01
     bf0:	82 ff       	sbrs	r24, 2
     bf2:	1d c0       	rjmp	.+58     	; 0xc2e <do_init_system+0x5c>
     bf4:	89 81       	ldd	r24, Y+1	; 0x01
     bf6:	81 fd       	sbrc	r24, 1
     bf8:	1a c0       	rjmp	.+52     	; 0xc2e <do_init_system+0x5c>
     bfa:	89 81       	ldd	r24, Y+1	; 0x01
     bfc:	83 fd       	sbrc	r24, 3
     bfe:	17 c0       	rjmp	.+46     	; 0xc2e <do_init_system+0x5c>
		// neue Hardware
		hardwaretyp = 1;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	80 93 19 20 	sts	0x2019, r24	; 0x802019 <hardwaretyp>
	}
	switch(hardwaretyp) {
		case 1: {
            // Port fr LEDs: im Gegensatz zur alten Hardware wird hier nicht multiplexed, sondern direkt LEDs angesteuert
            // PD0..PD7(Bit 2 .. 9)
			port_out(PORTD) = 0; // PORTD = 0
     c06:	e0 e6       	ldi	r30, 0x60	; 96
     c08:	f6 e0       	ldi	r31, 0x06	; 6
     c0a:	14 82       	std	Z+4, r1	; 0x04
			port_dirout(PORTD, 0); // PORTD as output
     c0c:	11 82       	std	Z+1, r1	; 0x01
			PORTCFG_MPCMASK = 0xff; // Alle Pins
     c0e:	a0 eb       	ldi	r26, 0xB0	; 176
     c10:	b0 e0       	ldi	r27, 0x00	; 0
     c12:	8f ef       	ldi	r24, 0xFF	; 255
     c14:	8c 93       	st	X, r24
			PORTD.PIN0CTRL = PORT_OPC_TOTEM_gc; // Alle PORTD Pins auf TOTEM Pole
     c16:	10 8a       	std	Z+16, r1	; 0x10
			// PC6 (Bit 0) und PC7 (Bit 1)
			port_dirout(PORTC, Bit(6) | Bit(7)); // PC6 and PC7 as output
     c18:	e0 e4       	ldi	r30, 0x40	; 64
     c1a:	f6 e0       	ldi	r31, 0x06	; 6
     c1c:	90 ec       	ldi	r25, 0xC0	; 192
     c1e:	91 83       	std	Z+1, r25	; 0x01
            PORTCFG_MPCMASK = 0xc0;
     c20:	9c 93       	st	X, r25
            PORTC.PIN0CTRL = PORT_OPC_TOTEM_gc;
     c22:	10 8a       	std	Z+16, r1	; 0x10

            // PORTA als Input (PA0..PA7) (Bit 0 .. 7)
            port_dirin(PORTA, 0xff);
     c24:	80 93 02 06 	sts	0x0602, r24	; 0x800602 <__TEXT_REGION_LENGTH__+0x7f7602>
            // PC0 (Bit 8), PC1 (Bit 9) als Eingabe
            port_dirin(PORTC, 0x3);
     c28:	83 e0       	ldi	r24, 0x03	; 3
     c2a:	82 83       	std	Z+2, r24	; 0x02

			break;
     c2c:	20 c0       	rjmp	.+64     	; 0xc6e <do_init_system+0x9c>
	if (bit_is_set(pbin, 2) && bit_is_clear(pbin, 1) && bit_is_clear(pbin, 3)) {
		// neue Hardware
		hardwaretyp = 1;
	} else {
		// alte Hardware
		hardwaretyp = 0;
     c2e:	10 92 19 20 	sts	0x2019, r1	; 0x802019 <hardwaretyp>
		// alter Hardware Typ
		{
            // Multiplex BesetztLEDs

            // PORTD 0
			port_out(PORTD) = 0;
     c32:	20 e6       	ldi	r18, 0x60	; 96
     c34:	36 e0       	ldi	r19, 0x06	; 6
     c36:	f9 01       	movw	r30, r18
     c38:	14 82       	std	Z+4, r1	; 0x04
            // PORTD als Ausgabe
			port_dirout(PORTD, 0xff);
     c3a:	8f ef       	ldi	r24, 0xFF	; 255
     c3c:	81 83       	std	Z+1, r24	; 0x01
            // alle Pins Totem Pole
			PORTCFG_MPCMASK = 0xff; // all pins
     c3e:	a0 eb       	ldi	r26, 0xB0	; 176
     c40:	b0 e0       	ldi	r27, 0x00	; 0
     c42:	8c 93       	st	X, r24
			PORTD.PIN0CTRL = PORT_OPC_TOTEM_gc;
     c44:	10 8a       	std	Z+16, r1	; 0x10

            // PORTC als Sensor 8-15, Eingabe
			port_dirin(PORTC, 0xff);
     c46:	20 e4       	ldi	r18, 0x40	; 64
     c48:	36 e0       	ldi	r19, 0x06	; 6
     c4a:	f9 01       	movw	r30, r18
     c4c:	82 83       	std	Z+2, r24	; 0x02
            // alle Pins mit Pull Up
			PORTCFG_MPCMASK = 0xff; // all pins
     c4e:	8c 93       	st	X, r24
			PORTC.PIN0CTRL = PORT_OPC_PULLUP_gc;
     c50:	98 e1       	ldi	r25, 0x18	; 24
     c52:	90 8b       	std	Z+16, r25	; 0x10

            // PORTB als Eingabe
            port_dirin(PORTB, 0xff);
     c54:	20 e2       	ldi	r18, 0x20	; 32
     c56:	36 e0       	ldi	r19, 0x06	; 6
     c58:	f9 01       	movw	r30, r18
     c5a:	82 83       	std	Z+2, r24	; 0x02
            // alle Pins
            PORTCFG_MPCMASK = 0xff; // all pins
     c5c:	8c 93       	st	X, r24
            // PORTB als PullDown
            PORTB.PIN0CTRL = PORT_OPC_PULLDOWN_gc;
     c5e:	40 e1       	ldi	r20, 0x10	; 16
     c60:	40 8b       	std	Z+16, r20	; 0x10

            //port_dirout(PORTB, Bit(2));

            //PORTA als Sensor 0-7, Eingabe
            port_dirin(PORTA, 0xff);
     c62:	20 e0       	ldi	r18, 0x00	; 0
     c64:	36 e0       	ldi	r19, 0x06	; 6
     c66:	f9 01       	movw	r30, r18
     c68:	82 83       	std	Z+2, r24	; 0x02
            // alle Pins
            PORTCFG_MPCMASK = 0xff; // all pins
     c6a:	8c 93       	st	X, r24
            // Pull Up
            PORTA.PIN0CTRL = PORT_OPC_PULLUP_gc;
     c6c:	90 8b       	std	Z+16, r25	; 0x10
			break;
		}
	}
    
    // Konfigure Sleep Modus: idle sleep mode, sleep mode allowed
    SLEEP.CTRL = SLEEP_SMODE_IDLE_gc|Bit(SLEEP_SEN_bp);
     c6e:	ff 24       	eor	r15, r15
     c70:	f3 94       	inc	r15
     c72:	f0 92 48 00 	sts	0x0048, r15	; 0x800048 <__TEXT_REGION_LENGTH__+0x7f7048>
    PR.PRPB = Bit(PR_DAC_bp)|Bit(PR_ADC_bp)|Bit(PR_AC_bp);
    PR.PRPC = Bit(PR_TWI_bp)|Bit(PR_USART1_bp)|Bit(PR_USART0_bp)|Bit(PR_SPI_bp)|Bit(PR_HIRES_bp); // PR_TC1_bp PR_TC0_bp;
    PR.PRPD = Bit(PR_TWI_bp)|Bit(PR_USART1_bp)|Bit(PR_USART0_bp)|Bit(PR_SPI_bp)|Bit(PR_HIRES_bp); // PR_TC1_bp PR_TC0_bp;
    */
    // Produkt ID, Vendor ID, Firmware Version setzen
    g_com.productid = PRODUCT_ID;
     c76:	00 e0       	ldi	r16, 0x00	; 0
     c78:	10 e2       	ldi	r17, 0x20	; 32
     c7a:	8b e0       	ldi	r24, 0x0B	; 11
     c7c:	90 e0       	ldi	r25, 0x00	; 0
     c7e:	d8 01       	movw	r26, r16
     c80:	8d 93       	st	X+, r24
     c82:	9c 93       	st	X, r25
    g_com.vendorid = VENDOR_ID;
     c84:	89 e9       	ldi	r24, 0x99	; 153
     c86:	99 e9       	ldi	r25, 0x99	; 153
     c88:	f8 01       	movw	r30, r16
     c8a:	82 83       	std	Z+2, r24	; 0x02
     c8c:	93 83       	std	Z+3, r25	; 0x03
    g_com.firmware_version = FIRMWARE_VERSION;
     c8e:	80 e0       	ldi	r24, 0x00	; 0
     c90:	92 e0       	ldi	r25, 0x02	; 2
     c92:	84 83       	std	Z+4, r24	; 0x04
     c94:	95 83       	std	Z+5, r25	; 0x05
    // Fhigkeiten des Gerts
    g_com.capabilities = CAP_FB_OCCUPANCY; // Besetztmelder
     c96:	88 e0       	ldi	r24, 0x08	; 8
     c98:	90 e0       	ldi	r25, 0x00	; 0
     c9a:	86 83       	std	Z+6, r24	; 0x06
     c9c:	97 83       	std	Z+7, r25	; 0x07
    g_com.cap_class = 0;
     c9e:	10 86       	std	Z+8, r1	; 0x08
     ca0:	11 86       	std	Z+9, r1	; 0x09
    g_com.dev_desc_P = PSTR(DEVICE_DESC); // Beschreibung
     ca2:	8c ef       	ldi	r24, 0xFC	; 252
     ca4:	91 e0       	ldi	r25, 0x01	; 1
     ca6:	82 87       	std	Z+10, r24	; 0x0a
     ca8:	93 87       	std	Z+11, r25	; 0x0b
static INLINE void timer_register(struct timer* t, uint8_t resolution) {
    if (resolution == TIMER_RESOLUTION_16MS) {
        t->next = g_com.timer_16ms;
        g_com.timer_16ms = t;
    } else {
        t->next = g_com.timer_1ms;
     caa:	85 85       	ldd	r24, Z+13	; 0x0d
     cac:	96 85       	ldd	r25, Z+14	; 0x0e
     cae:	a6 ee       	ldi	r26, 0xE6	; 230
     cb0:	b0 e2       	ldi	r27, 0x20	; 32
     cb2:	8d 93       	st	X+, r24
     cb4:	9c 93       	st	X, r25
     cb6:	11 97       	sbiw	r26, 0x01	; 1
        g_com.timer_1ms = t;
     cb8:	a5 87       	std	Z+13, r26	; 0x0d
     cba:	b6 87       	std	Z+14, r27	; 0x0e
    }
    t->value = 0;
     cbc:	fd 01       	movw	r30, r26
     cbe:	12 82       	std	Z+2, r1	; 0x02
    struct ring_buffer rb;
};
typedef struct pipe pipe_t;

static INLINE void pipe_init(pipe_t* p, uint8_t size) {
    ringbuf_init(&p->rb, size);
     cc0:	60 e4       	ldi	r22, 0x40	; 64
     cc2:	8a e1       	ldi	r24, 0x1A	; 26
     cc4:	90 e2       	ldi	r25, 0x20	; 32
     cc6:	0e 94 24 01 	call	0x248	; 0x248 <ringbuf_init>
    
    // Lokadresse Pipeline einrichten
    pipe_init(&g_locoaddr_pipe.pipe, sizeof(g_locoaddr_pipe.buf));
    
    // Sensoren Init mit 0 == Nichts belegt
    memset(g_sensors, 0, sizeof(g_sensors));
     cca:	80 e7       	ldi	r24, 0x70	; 112
     ccc:	e6 e7       	ldi	r30, 0x76	; 118
     cce:	f0 e2       	ldi	r31, 0x20	; 32
     cd0:	df 01       	movw	r26, r30
     cd2:	1d 92       	st	X+, r1
     cd4:	8a 95       	dec	r24
     cd6:	e9 f7       	brne	.-6      	; 0xcd2 <do_init_system+0x100>
    
    // PB0  DCC Signal Pin

    // PB0 PullDown, beide Flanken
    DCCSENSE_PORT.PIN0CTRL = PORT_OPC_PULLDOWN_gc|PORT_ISC_BOTHEDGES_gc;
     cd8:	80 e1       	ldi	r24, 0x10	; 16
     cda:	80 93 30 06 	sts	0x0630, r24	; 0x800630 <__TEXT_REGION_LENGTH__+0x7f7630>
 * DCC Decoder Init. evmux Wert fr Kanal 0 Multiplexer C0MUX z.b. EVSYS_CHMUX_PORTC_PIN4_gc
 */
static void dec_init(uint8_t evmux) { // e.g.: EVSYS_CHMUX_PORTC_PIN4_gc
	// DCC Decoder Init
	
    g_dccdec.state = DEC_STATE_OFF; // Status OFF
     cde:	e3 e6       	ldi	r30, 0x63	; 99
     ce0:	f0 e2       	ldi	r31, 0x20	; 32
     ce2:	10 82       	st	Z, r1
    g_dccdec.preamble = 0;  // keine Preamble 
     ce4:	11 82       	std	Z+1, r1	; 0x01
    g_dccdec.bufsize = 0;   // aktuelle Buffergre
     ce6:	14 86       	std	Z+12, r1	; 0x0c
    g_dccdec.bits = 0;      // wieviele Bits sind im Buffer
     ce8:	15 86       	std	Z+13, r1	; 0x0d
    g_dccdec.lasthbit = 0;  // letzte Halfbit
     cea:	17 86       	std	Z+15, r1	; 0x0f
    g_dccdec.xor = 0;       // XOR Wert fr die CRC
     cec:	10 8a       	std	Z+16, r1	; 0x10
    g_dccdec.cutout = 0;    // Sind wir ein Cutout?
     cee:	11 8a       	std	Z+17, r1	; 0x11
    
	// setze Event System Multiplexer EVSYS_CHMUX_PORTC_PIN4_gc
    EVSYS.CH0MUX = evmux;
     cf0:	e0 e8       	ldi	r30, 0x80	; 128
     cf2:	f1 e0       	ldi	r31, 0x01	; 1
     cf4:	98 e5       	ldi	r25, 0x58	; 88
     cf6:	90 83       	st	Z, r25
	// Event Kanal 0: Quadratur ausgeschaltet
    EVSYS.CH0CTRL = 0;
     cf8:	10 86       	std	Z+8, r1	; 0x08
    
	// Timer D1 off
    TCD1.CTRLA = TC_CLKSEL_OFF_gc;
     cfa:	e0 e4       	ldi	r30, 0x40	; 64
     cfc:	f9 e0       	ldi	r31, 0x09	; 9
     cfe:	10 82       	st	Z, r1
	// Timer D1 CCA Enable, Normal WG Mode
    TCD1.CTRLB = Bit(TC1_CCAEN_bp)|TC_WGMODE_NORMAL_gc;
     d00:	81 83       	std	Z+1, r24	; 0x01
	// Timer D1 Event Action Input Capture, Event Channel 0
    TCD1.CTRLD = TC_EVACT_CAPT_gc|TC_EVSEL_CH0_gc;
     d02:	88 e2       	ldi	r24, 0x28	; 40
     d04:	83 83       	std	Z+3, r24	; 0x03
	// Upper Counter to Byte Mode
    TCD1.CTRLE = TC1_BYTEM_bm;
     d06:	f4 82       	std	Z+4, r15	; 0x04
	// TCD1 Kein OVF oder ERR Interrupt
    TCD1.INTCTRLA = 0;
     d08:	16 82       	std	Z+6, r1	; 0x06
	// TCD1 Kein CC Interrupt
    TCD1.INTCTRLB = 0;
     d0a:	17 82       	std	Z+7, r1	; 0x07
	// Interrupt Flags zurcksetzen
    TCD1.INTFLAGS = 0xff;
     d0c:	8f ef       	ldi	r24, 0xFF	; 255
     d0e:	84 87       	std	Z+12, r24	; 0x0c
	// TCD1 Periode auf 0xffff
    TCD1.PER = 0xffff;
     d10:	8f ef       	ldi	r24, 0xFF	; 255
     d12:	9f ef       	ldi	r25, 0xFF	; 255
     d14:	86 a3       	std	Z+38, r24	; 0x26
     d16:	97 a3       	std	Z+39, r25	; 0x27
#define TIMER_RESOLUTION_1MS  0
#define TIMER_RESOLUTION_16MS 1

static INLINE void timer_register(struct timer* t, uint8_t resolution) {
    if (resolution == TIMER_RESOLUTION_16MS) {
        t->next = g_com.timer_16ms;
     d18:	f8 01       	movw	r30, r16
     d1a:	87 85       	ldd	r24, Z+15	; 0x0f
     d1c:	90 89       	ldd	r25, Z+16	; 0x10
     d1e:	a0 e6       	ldi	r26, 0x60	; 96
     d20:	b0 e2       	ldi	r27, 0x20	; 32
     d22:	8d 93       	st	X+, r24
     d24:	9c 93       	st	X, r25
     d26:	11 97       	sbiw	r26, 0x01	; 1
        g_com.timer_16ms = t;
     d28:	a7 87       	std	Z+15, r26	; 0x0f
     d2a:	b0 8b       	std	Z+16, r27	; 0x10
    } else {
        t->next = g_com.timer_1ms;
        g_com.timer_1ms = t;
    }
    t->value = 0;
     d2c:	fd 01       	movw	r30, r26
     d2e:	12 82       	std	Z+2, r1	; 0x02
    // Decoder Init PortB0
    //dec_init(CONCAT5(EVSYS_CHMUX_,DCCSENSE_PORT,_PIN,DCCSENSE_PIN, _gc));
	dec_init(EVSYS_CHMUX_PORTB_PIN0_gc);
    
    timer_register(&g_power_on_timer, TIMER_RESOLUTION_16MS);
    g_power_on = 0;
     d30:	10 92 5e 20 	sts	0x205E, r1	; 0x80205e <g_power_on>
    
    g_holdtime = e2prom_get_byte(&g_eeprom.holdtime);
     d34:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
     d38:	88 23       	and	r24, r24
     d3a:	e4 f3       	brlt	.-8      	; 0xd34 <do_init_system+0x162>
     d3c:	ec ec       	ldi	r30, 0xCC	; 204
     d3e:	f1 e0       	ldi	r31, 0x01	; 1
     d40:	80 81       	ld	r24, Z
     d42:	88 60       	ori	r24, 0x08	; 8
     d44:	80 83       	st	Z, r24
     d46:	80 91 00 10 	lds	r24, 0x1000	; 0x801000 <__TEXT_REGION_LENGTH__+0x7f8000>
    if (g_holdtime == 0xff) {
     d4a:	8f 3f       	cpi	r24, 0xFF	; 255
     d4c:	19 f0       	breq	.+6      	; 0xd54 <do_init_system+0x182>
	dec_init(EVSYS_CHMUX_PORTB_PIN0_gc);
    
    timer_register(&g_power_on_timer, TIMER_RESOLUTION_16MS);
    g_power_on = 0;
    
    g_holdtime = e2prom_get_byte(&g_eeprom.holdtime);
     d4e:	80 93 5f 20 	sts	0x205F, r24	; 0x80205f <g_holdtime>
     d52:	03 c0       	rjmp	.+6      	; 0xd5a <do_init_system+0x188>
    if (g_holdtime == 0xff) {
        g_holdtime = DEFAULT_HOLDTIME;
     d54:	88 ec       	ldi	r24, 0xC8	; 200
     d56:	80 93 5f 20 	sts	0x205F, r24	; 0x80205f <g_holdtime>
    }
    g_old_holdtime = g_holdtime;
     d5a:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <g_holdtime>
     d5e:	80 93 75 20 	sts	0x2075, r24	; 0x802075 <g_old_holdtime>
    for (uint8_t i = 0; i < NUM_SENSORS; i++) {
     d62:	90 e0       	ldi	r25, 0x00	; 0
     d64:	24 c0       	rjmp	.+72     	; 0xdae <do_init_system+0x1dc>
        uint8_t ht = e2prom_get_byte(&g_eeprom.sensors[i].holdtime);
     d66:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
     d6a:	88 23       	and	r24, r24
     d6c:	e4 f3       	brlt	.-8      	; 0xd66 <do_init_system+0x194>
     d6e:	ec ec       	ldi	r30, 0xCC	; 204
     d70:	f1 e0       	ldi	r31, 0x01	; 1
     d72:	80 81       	ld	r24, Z
     d74:	88 60       	ori	r24, 0x08	; 8
     d76:	80 83       	st	Z, r24
     d78:	f9 01       	movw	r30, r18
     d7a:	e2 95       	swap	r30
     d7c:	f2 95       	swap	r31
     d7e:	f0 7f       	andi	r31, 0xF0	; 240
     d80:	fe 27       	eor	r31, r30
     d82:	e0 7f       	andi	r30, 0xF0	; 240
     d84:	fe 27       	eor	r31, r30
     d86:	ef 5f       	subi	r30, 0xFF	; 255
     d88:	ff 4e       	sbci	r31, 0xEF	; 239
     d8a:	80 81       	ld	r24, Z
        if (ht == 0xff) {
     d8c:	8f 3f       	cpi	r24, 0xFF	; 255
     d8e:	11 f4       	brne	.+4      	; 0xd94 <do_init_system+0x1c2>
            ht = g_holdtime;
     d90:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <g_holdtime>
        }
        g_sensors[i].holdtime = ht;
     d94:	f9 01       	movw	r30, r18
     d96:	ee 0f       	add	r30, r30
     d98:	ff 1f       	adc	r31, r31
     d9a:	ee 0f       	add	r30, r30
     d9c:	ff 1f       	adc	r31, r31
     d9e:	ee 0f       	add	r30, r30
     da0:	ff 1f       	adc	r31, r31
     da2:	e2 1b       	sub	r30, r18
     da4:	f3 0b       	sbc	r31, r19
     da6:	ea 58       	subi	r30, 0x8A	; 138
     da8:	ff 4d       	sbci	r31, 0xDF	; 223
     daa:	84 83       	std	Z+4, r24	; 0x04
    g_holdtime = e2prom_get_byte(&g_eeprom.holdtime);
    if (g_holdtime == 0xff) {
        g_holdtime = DEFAULT_HOLDTIME;
    }
    g_old_holdtime = g_holdtime;
    for (uint8_t i = 0; i < NUM_SENSORS; i++) {
     dac:	9f 5f       	subi	r25, 0xFF	; 255
     dae:	29 2f       	mov	r18, r25
     db0:	30 e0       	ldi	r19, 0x00	; 0
     db2:	80 91 19 20 	lds	r24, 0x2019	; 0x802019 <hardwaretyp>
     db6:	81 30       	cpi	r24, 0x01	; 1
     db8:	19 f0       	breq	.+6      	; 0xdc0 <do_init_system+0x1ee>
     dba:	40 e1       	ldi	r20, 0x10	; 16
     dbc:	50 e0       	ldi	r21, 0x00	; 0
     dbe:	02 c0       	rjmp	.+4      	; 0xdc4 <do_init_system+0x1f2>
     dc0:	4a e0       	ldi	r20, 0x0A	; 10
     dc2:	50 e0       	ldi	r21, 0x00	; 0
     dc4:	24 17       	cp	r18, r20
     dc6:	35 07       	cpc	r19, r21
     dc8:	74 f2       	brlt	.-100    	; 0xd66 <do_init_system+0x194>
        if (ht == 0xff) {
            ht = g_holdtime;
        }
        g_sensors[i].holdtime = ht;
    }
}
     dca:	0f 90       	pop	r0
     dcc:	df 91       	pop	r29
     dce:	cf 91       	pop	r28
     dd0:	1f 91       	pop	r17
     dd2:	0f 91       	pop	r16
     dd4:	ff 90       	pop	r15
     dd6:	08 95       	ret

00000dd8 <do_msg>:

uint8_t do_msg(struct sboxnet_msg_header *pmsg) {
     dd8:	cf 93       	push	r28
     dda:	df 93       	push	r29
     ddc:	ec 01       	movw	r28, r24
    if (pmsg->dstaddr == SBOXNET_ADDR_BROADCAST) {
     dde:	88 81       	ld	r24, Y
     de0:	8f 3f       	cpi	r24, 0xFF	; 255
     de2:	09 f4       	brne	.+2      	; 0xde6 <do_msg+0xe>
     de4:	4d c0       	rjmp	.+154    	; 0xe80 <do_msg+0xa8>
        return SBOXNET_ACKRC_CMD_UNKNOWN;
    }
    switch (pmsg->cmd) {
     de6:	8c 81       	ldd	r24, Y+4	; 0x04
     de8:	81 3b       	cpi	r24, 0xB1	; 177
     dea:	09 f0       	breq	.+2      	; 0xdee <do_msg+0x16>
     dec:	4b c0       	rjmp	.+150    	; 0xe84 <do_msg+0xac>
        case SBOXNET_CMD_FB_LOCOADDR|0x80: {
            if (pmsg->opt.len != 0) {
     dee:	8b 81       	ldd	r24, Y+3	; 0x03
     df0:	8f 73       	andi	r24, 0x3F	; 63
     df2:	09 f0       	breq	.+2      	; 0xdf6 <do_msg+0x1e>
     df4:	49 c0       	rjmp	.+146    	; 0xe88 <do_msg+0xb0>
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	32 c0       	rjmp	.+100    	; 0xe5e <do_msg+0x86>
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            for (uint8_t i = 0; i < NUM_SENSORS; i++) {
                if (g_sensors[i].flags.notack && pmsg->seq == g_sensors[i].last_seq) {
     dfa:	f9 01       	movw	r30, r18
     dfc:	ee 0f       	add	r30, r30
     dfe:	ff 1f       	adc	r31, r31
     e00:	ee 0f       	add	r30, r30
     e02:	ff 1f       	adc	r31, r31
     e04:	ee 0f       	add	r30, r30
     e06:	ff 1f       	adc	r31, r31
     e08:	e2 1b       	sub	r30, r18
     e0a:	f3 0b       	sbc	r31, r19
     e0c:	e5 58       	subi	r30, 0x85	; 133
     e0e:	ff 4d       	sbci	r31, 0xDF	; 223
     e10:	80 81       	ld	r24, Z
     e12:	80 ff       	sbrs	r24, 0
     e14:	23 c0       	rjmp	.+70     	; 0xe5c <do_msg+0x84>
     e16:	4a 81       	ldd	r20, Y+2	; 0x02
     e18:	f9 01       	movw	r30, r18
     e1a:	ee 0f       	add	r30, r30
     e1c:	ff 1f       	adc	r31, r31
     e1e:	ee 0f       	add	r30, r30
     e20:	ff 1f       	adc	r31, r31
     e22:	ee 0f       	add	r30, r30
     e24:	ff 1f       	adc	r31, r31
     e26:	e2 1b       	sub	r30, r18
     e28:	f3 0b       	sbc	r31, r19
     e2a:	ea 58       	subi	r30, 0x8A	; 138
     e2c:	ff 4d       	sbci	r31, 0xDF	; 223
     e2e:	83 81       	ldd	r24, Z+3	; 0x03
     e30:	48 13       	cpse	r20, r24
     e32:	14 c0       	rjmp	.+40     	; 0xe5c <do_msg+0x84>
                    g_sensors[i].flags.notack = 0;
     e34:	a9 01       	movw	r20, r18
     e36:	44 0f       	add	r20, r20
     e38:	55 1f       	adc	r21, r21
     e3a:	44 0f       	add	r20, r20
     e3c:	55 1f       	adc	r21, r21
     e3e:	44 0f       	add	r20, r20
     e40:	55 1f       	adc	r21, r21
     e42:	ba 01       	movw	r22, r20
     e44:	62 1b       	sub	r22, r18
     e46:	73 0b       	sbc	r23, r19
     e48:	fb 01       	movw	r30, r22
     e4a:	e5 58       	subi	r30, 0x85	; 133
     e4c:	ff 4d       	sbci	r31, 0xDF	; 223
     e4e:	80 81       	ld	r24, Z
     e50:	8e 7f       	andi	r24, 0xFE	; 254
     e52:	80 83       	st	Z, r24
                    g_sensors[i].last_seq = 0;
     e54:	fb 01       	movw	r30, r22
     e56:	ea 58       	subi	r30, 0x8A	; 138
     e58:	ff 4d       	sbci	r31, 0xDF	; 223
     e5a:	13 82       	std	Z+3, r1	; 0x03
    switch (pmsg->cmd) {
        case SBOXNET_CMD_FB_LOCOADDR|0x80: {
            if (pmsg->opt.len != 0) {
                return SBOXNET_ACKRC_INVALID_ARG;
            }
            for (uint8_t i = 0; i < NUM_SENSORS; i++) {
     e5c:	9f 5f       	subi	r25, 0xFF	; 255
     e5e:	29 2f       	mov	r18, r25
     e60:	30 e0       	ldi	r19, 0x00	; 0
     e62:	40 91 19 20 	lds	r20, 0x2019	; 0x802019 <hardwaretyp>
     e66:	41 30       	cpi	r20, 0x01	; 1
     e68:	19 f0       	breq	.+6      	; 0xe70 <do_msg+0x98>
     e6a:	40 e1       	ldi	r20, 0x10	; 16
     e6c:	50 e0       	ldi	r21, 0x00	; 0
     e6e:	02 c0       	rjmp	.+4      	; 0xe74 <do_msg+0x9c>
     e70:	4a e0       	ldi	r20, 0x0A	; 10
     e72:	50 e0       	ldi	r21, 0x00	; 0
     e74:	24 17       	cp	r18, r20
     e76:	35 07       	cpc	r19, r21
     e78:	0c f4       	brge	.+2      	; 0xe7c <do_msg+0xa4>
     e7a:	bf cf       	rjmp	.-130    	; 0xdfa <do_msg+0x22>
                if (g_sensors[i].flags.notack && pmsg->seq == g_sensors[i].last_seq) {
                    g_sensors[i].flags.notack = 0;
                    g_sensors[i].last_seq = 0;
                }
            }
            return SBOXNET_ACKRC_SEND_NO_ANSWER;
     e7c:	8f ef       	ldi	r24, 0xFF	; 255
     e7e:	05 c0       	rjmp	.+10     	; 0xe8a <do_msg+0xb2>
    }
}

uint8_t do_msg(struct sboxnet_msg_header *pmsg) {
    if (pmsg->dstaddr == SBOXNET_ADDR_BROADCAST) {
        return SBOXNET_ACKRC_CMD_UNKNOWN;
     e80:	82 e0       	ldi	r24, 0x02	; 2
     e82:	03 c0       	rjmp	.+6      	; 0xe8a <do_msg+0xb2>
                }
            }
            return SBOXNET_ACKRC_SEND_NO_ANSWER;
        }
    }
    return SBOXNET_ACKRC_CMD_UNKNOWN;
     e84:	82 e0       	ldi	r24, 0x02	; 2
     e86:	01 c0       	rjmp	.+2      	; 0xe8a <do_msg+0xb2>
        return SBOXNET_ACKRC_CMD_UNKNOWN;
    }
    switch (pmsg->cmd) {
        case SBOXNET_CMD_FB_LOCOADDR|0x80: {
            if (pmsg->opt.len != 0) {
                return SBOXNET_ACKRC_INVALID_ARG;
     e88:	83 e0       	ldi	r24, 0x03	; 3
            }
            return SBOXNET_ACKRC_SEND_NO_ANSWER;
        }
    }
    return SBOXNET_ACKRC_CMD_UNKNOWN;
}
     e8a:	df 91       	pop	r29
     e8c:	cf 91       	pop	r28
     e8e:	08 95       	ret

00000e90 <do_reg_read>:

uint8_t do_reg_read(uint16_t reg, uint16_t* pdata) {
    switch(reg) {
     e90:	85 31       	cpi	r24, 0x15	; 21
     e92:	91 05       	cpc	r25, r1
     e94:	a1 f0       	breq	.+40     	; 0xebe <do_reg_read+0x2e>
     e96:	8f 3f       	cpi	r24, 0xFF	; 255
     e98:	91 05       	cpc	r25, r1
     e9a:	d1 f0       	breq	.+52     	; 0xed0 <do_reg_read+0x40>
     e9c:	84 31       	cpi	r24, 0x14	; 20
     e9e:	91 05       	cpc	r25, r1
     ea0:	f9 f4       	brne	.+62     	; 0xee0 <do_reg_read+0x50>
        case R_FB_NUM:      *pdata = NUM_SENSORS; return 0;
     ea2:	80 91 19 20 	lds	r24, 0x2019	; 0x802019 <hardwaretyp>
     ea6:	81 30       	cpi	r24, 0x01	; 1
     ea8:	19 f0       	breq	.+6      	; 0xeb0 <do_reg_read+0x20>
     eaa:	80 e1       	ldi	r24, 0x10	; 16
     eac:	90 e0       	ldi	r25, 0x00	; 0
     eae:	02 c0       	rjmp	.+4      	; 0xeb4 <do_reg_read+0x24>
     eb0:	8a e0       	ldi	r24, 0x0A	; 10
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	fb 01       	movw	r30, r22
     eb6:	80 83       	st	Z, r24
     eb8:	91 83       	std	Z+1, r25	; 0x01
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	08 95       	ret
        case R_FB_VALUE0:   *pdata = g_sensor_bits; return 0;
     ebe:	80 91 17 20 	lds	r24, 0x2017	; 0x802017 <g_sensor_bits>
     ec2:	90 91 18 20 	lds	r25, 0x2018	; 0x802018 <g_sensor_bits+0x1>
     ec6:	fb 01       	movw	r30, r22
     ec8:	80 83       	st	Z, r24
     eca:	91 83       	std	Z+1, r25	; 0x01
     ecc:	80 e0       	ldi	r24, 0x00	; 0
     ece:	08 95       	ret
        
        case R_GBM_HOLDTIME: *pdata = g_holdtime; return 0;
     ed0:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <g_holdtime>
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	fb 01       	movw	r30, r22
     ed8:	80 83       	st	Z, r24
     eda:	91 83       	std	Z+1, r25	; 0x01
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	08 95       	ret
    }    
    if (reg >= R_GBM_PAR_0 && reg < R_GBM_PAR_15+NUM_GBM_PARS) {
     ee0:	9c 01       	movw	r18, r24
     ee2:	3a 95       	dec	r19
     ee4:	20 38       	cpi	r18, 0x80	; 128
     ee6:	31 05       	cpc	r19, r1
     ee8:	90 f5       	brcc	.+100    	; 0xf4e <do_reg_read+0xbe>
        uint8_t roffs = reg & NUM_GBM_PARS_MASK;
     eea:	87 70       	andi	r24, 0x07	; 7
        uint8_t gbmnum = (reg-R_GBM_PAR_0) / NUM_GBM_PARS;
     eec:	36 95       	lsr	r19
     eee:	27 95       	ror	r18
     ef0:	36 95       	lsr	r19
     ef2:	27 95       	ror	r18
     ef4:	36 95       	lsr	r19
     ef6:	27 95       	ror	r18
        switch (roffs) {
     ef8:	88 23       	and	r24, r24
     efa:	19 f0       	breq	.+6      	; 0xf02 <do_reg_read+0x72>
     efc:	81 30       	cpi	r24, 0x01	; 1
     efe:	a1 f0       	breq	.+40     	; 0xf28 <do_reg_read+0x98>
     f00:	28 c0       	rjmp	.+80     	; 0xf52 <do_reg_read+0xc2>
     f02:	33 27       	eor	r19, r19
            case ROFFS_GBM_HOLDTIME: {
                *pdata = g_sensors[gbmnum].holdtime;
     f04:	f9 01       	movw	r30, r18
     f06:	ee 0f       	add	r30, r30
     f08:	ff 1f       	adc	r31, r31
     f0a:	ee 0f       	add	r30, r30
     f0c:	ff 1f       	adc	r31, r31
     f0e:	ee 0f       	add	r30, r30
     f10:	ff 1f       	adc	r31, r31
     f12:	e2 1b       	sub	r30, r18
     f14:	f3 0b       	sbc	r31, r19
     f16:	ea 58       	subi	r30, 0x8A	; 138
     f18:	ff 4d       	sbci	r31, 0xDF	; 223
     f1a:	84 81       	ldd	r24, Z+4	; 0x04
     f1c:	90 e0       	ldi	r25, 0x00	; 0
     f1e:	fb 01       	movw	r30, r22
     f20:	80 83       	st	Z, r24
     f22:	91 83       	std	Z+1, r25	; 0x01
                return 0;
     f24:	80 e0       	ldi	r24, 0x00	; 0
     f26:	08 95       	ret
     f28:	33 27       	eor	r19, r19
            }
            case ROFFS_GBM_LOCOADDR: {
                *pdata = g_sensors[gbmnum].locoaddr;
     f2a:	f9 01       	movw	r30, r18
     f2c:	ee 0f       	add	r30, r30
     f2e:	ff 1f       	adc	r31, r31
     f30:	ee 0f       	add	r30, r30
     f32:	ff 1f       	adc	r31, r31
     f34:	ee 0f       	add	r30, r30
     f36:	ff 1f       	adc	r31, r31
     f38:	e2 1b       	sub	r30, r18
     f3a:	f3 0b       	sbc	r31, r19
     f3c:	ea 58       	subi	r30, 0x8A	; 138
     f3e:	ff 4d       	sbci	r31, 0xDF	; 223
     f40:	81 81       	ldd	r24, Z+1	; 0x01
     f42:	92 81       	ldd	r25, Z+2	; 0x02
     f44:	fb 01       	movw	r30, r22
     f46:	80 83       	st	Z, r24
     f48:	91 83       	std	Z+1, r25	; 0x01
                return 0;
     f4a:	80 e0       	ldi	r24, 0x00	; 0
     f4c:	08 95       	ret
            default: {
                break;
            }
        }
    }
    return SBOXNET_ACKRC_REG_INVALID;
     f4e:	84 e0       	ldi	r24, 0x04	; 4
     f50:	08 95       	ret
     f52:	84 e0       	ldi	r24, 0x04	; 4
};
     f54:	08 95       	ret

00000f56 <do_reg_write>:

uint8_t do_reg_write(uint16_t reg, uint16_t data, uint16_t mask) {
     f56:	cf 93       	push	r28
     f58:	df 93       	push	r29
    switch (reg) {
     f5a:	8f 3f       	cpi	r24, 0xFF	; 255
     f5c:	91 05       	cpc	r25, r1
     f5e:	61 f4       	brne	.+24     	; 0xf78 <do_reg_write+0x22>
        case R_GBM_HOLDTIME: {
            g_old_holdtime = g_holdtime;
     f60:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <g_holdtime>
     f64:	80 93 75 20 	sts	0x2075, r24	; 0x802075 <g_old_holdtime>
            g_holdtime = (data >= 0xff ? 0xff : (uint8_t)data);
     f68:	6f 3f       	cpi	r22, 0xFF	; 255
     f6a:	71 05       	cpc	r23, r1
     f6c:	08 f0       	brcs	.+2      	; 0xf70 <do_reg_write+0x1a>
     f6e:	6f ef       	ldi	r22, 0xFF	; 255
     f70:	60 93 5f 20 	sts	0x205F, r22	; 0x80205f <g_holdtime>
            return 0;
     f74:	80 e0       	ldi	r24, 0x00	; 0
     f76:	29 c0       	rjmp	.+82     	; 0xfca <do_reg_write+0x74>
        }
    }
    if (reg >= R_GBM_PAR_0 && reg < R_GBM_PAR_15+NUM_GBM_PARS) {
     f78:	9c 01       	movw	r18, r24
     f7a:	3a 95       	dec	r19
     f7c:	20 38       	cpi	r18, 0x80	; 128
     f7e:	31 05       	cpc	r19, r1
     f80:	08 f5       	brcc	.+66     	; 0xfc4 <do_reg_write+0x6e>
        uint8_t roffs = reg & NUM_GBM_PARS_MASK;
     f82:	87 70       	andi	r24, 0x07	; 7
        uint8_t gbmnum = (reg-R_GBM_PAR_0) / NUM_GBM_PARS;
        switch (roffs) {
     f84:	09 f5       	brne	.+66     	; 0xfc8 <do_reg_write+0x72>
            return 0;
        }
    }
    if (reg >= R_GBM_PAR_0 && reg < R_GBM_PAR_15+NUM_GBM_PARS) {
        uint8_t roffs = reg & NUM_GBM_PARS_MASK;
        uint8_t gbmnum = (reg-R_GBM_PAR_0) / NUM_GBM_PARS;
     f86:	36 95       	lsr	r19
     f88:	27 95       	ror	r18
     f8a:	36 95       	lsr	r19
     f8c:	27 95       	ror	r18
     f8e:	36 95       	lsr	r19
     f90:	27 95       	ror	r18
     f92:	33 27       	eor	r19, r19
        switch (roffs) {
            case ROFFS_GBM_HOLDTIME: {
                g_sensors[gbmnum].holdtime = (data >= 0xff ? 0xff : (uint8_t)data);
     f94:	6f 3f       	cpi	r22, 0xFF	; 255
     f96:	71 05       	cpc	r23, r1
     f98:	08 f0       	brcs	.+2      	; 0xf9c <do_reg_write+0x46>
     f9a:	6f ef       	ldi	r22, 0xFF	; 255
     f9c:	f9 01       	movw	r30, r18
     f9e:	ee 0f       	add	r30, r30
     fa0:	ff 1f       	adc	r31, r31
     fa2:	ee 0f       	add	r30, r30
     fa4:	ff 1f       	adc	r31, r31
     fa6:	ee 0f       	add	r30, r30
     fa8:	ff 1f       	adc	r31, r31
     faa:	e2 1b       	sub	r30, r18
     fac:	f3 0b       	sbc	r31, r19
     fae:	ef 01       	movw	r28, r30
     fb0:	ca 58       	subi	r28, 0x8A	; 138
     fb2:	df 4d       	sbci	r29, 0xDF	; 223
     fb4:	6c 83       	std	Y+4, r22	; 0x04
                g_sensors[gbmnum].flags.holdtime_changed = 1;
     fb6:	e5 58       	subi	r30, 0x85	; 133
     fb8:	ff 4d       	sbci	r31, 0xDF	; 223
     fba:	80 81       	ld	r24, Z
     fbc:	84 60       	ori	r24, 0x04	; 4
     fbe:	80 83       	st	Z, r24
                return 0;
     fc0:	80 e0       	ldi	r24, 0x00	; 0
     fc2:	03 c0       	rjmp	.+6      	; 0xfca <do_reg_write+0x74>
            default: {
                break;
            }
        }
    }
    return SBOXNET_ACKRC_REG_INVALID;
     fc4:	84 e0       	ldi	r24, 0x04	; 4
     fc6:	01 c0       	rjmp	.+2      	; 0xfca <do_reg_write+0x74>
     fc8:	84 e0       	ldi	r24, 0x04	; 4
}
     fca:	df 91       	pop	r29
     fcc:	cf 91       	pop	r28
     fce:	08 95       	ret

00000fd0 <do_setup>:
/* void dec_start(void)
 * Start den DCC Decoder.
 */
static void dec_start(void) {
	// Erstes Bit
    g_dccdec.state = DEC_STATE_FIRST;
     fd0:	e3 e6       	ldi	r30, 0x63	; 99
     fd2:	f0 e2       	ldi	r31, 0x20	; 32
     fd4:	81 e0       	ldi	r24, 0x01	; 1
     fd6:	80 83       	st	Z, r24
	// noch keine Preamble
    g_dccdec.preamble = 0;
     fd8:	11 82       	std	Z+1, r1	; 0x01
	// der Buffer ist noch leer
    g_dccdec.bufsize = 0;
     fda:	14 86       	std	Z+12, r1	; 0x0c
	// kein Cutout
    g_dccdec.cutout = 0;
     fdc:	11 8a       	std	Z+17, r1	; 0x11
    
	// TCD1 Restart
    TCD1.CTRLFSET = TC_CMD_RESTART_gc;
     fde:	e0 e4       	ldi	r30, 0x40	; 64
     fe0:	f9 e0       	ldi	r31, 0x09	; 9
     fe2:	98 e0       	ldi	r25, 0x08	; 8
     fe4:	91 87       	std	Z+9, r25	; 0x09
	// alle Interrupt Flags clearen
    TCD1.INTFLAGS = 0xff;
     fe6:	9f ef       	ldi	r25, 0xFF	; 255
     fe8:	94 87       	std	Z+12, r25	; 0x0c
	// TCD2.CCA auf LO Interrupt
    TCD1.INTCTRLB = TC_CCAINTLVL_LO_gc;
     fea:	87 83       	std	Z+7, r24	; 0x07
	// TCD1 Timer starten mit /64
    TCD1.CTRLA = TC_CLKSEL_DIV64_gc;
     fec:	85 e0       	ldi	r24, 0x05	; 5
     fee:	80 83       	st	Z, r24
     ff0:	08 95       	ret

00000ff2 <do_main>:

void do_setup(void) {
    dec_start();
}

void do_main(void) {    
     ff2:	af 92       	push	r10
     ff4:	bf 92       	push	r11
     ff6:	cf 92       	push	r12
     ff8:	df 92       	push	r13
     ffa:	ef 92       	push	r14
     ffc:	ff 92       	push	r15
     ffe:	0f 93       	push	r16
    1000:	1f 93       	push	r17
    1002:	cf 93       	push	r28
    1004:	df 93       	push	r29
    1006:	cd b7       	in	r28, 0x3d	; 61
    1008:	de b7       	in	r29, 0x3e	; 62
    100a:	c5 54       	subi	r28, 0x45	; 69
    100c:	d1 09       	sbc	r29, r1
    100e:	cd bf       	out	0x3d, r28	; 61
    1010:	de bf       	out	0x3e, r29	; 62
}

static INLINE uint8_t timer_timedout(struct timer* t) {
    return t->value == 0;
    1012:	80 91 e8 20 	lds	r24, 0x20E8	; 0x8020e8 <g_led_timer+0x2>
    if (timer_timedout(&g_led_timer)) {
    1016:	81 11       	cpse	r24, r1
    1018:	06 c1       	rjmp	.+524    	; 0x1226 <__DATA_REGION_LENGTH__+0x226>
}

static INLINE void timer_set(struct timer* t, int8_t value) {
    t->value = value;
    101a:	85 e0       	ldi	r24, 0x05	; 5
    101c:	80 93 e8 20 	sts	0x20E8, r24	; 0x8020e8 <g_led_timer+0x2>
    g_dec_lastaddr = 0;
}


static void read_sensors(void) {
    uint8_t sens1 = ~port_in(PORTA);
    1020:	60 91 08 06 	lds	r22, 0x0608	; 0x800608 <__TEXT_REGION_LENGTH__+0x7f7608>
    1024:	60 95       	com	r22
    uint8_t sens2 = ~port_in(PORTC);
    1026:	80 91 48 06 	lds	r24, 0x0648	; 0x800648 <__TEXT_REGION_LENGTH__+0x7f7648>
    102a:	80 95       	com	r24
    
    uint16_t sensors = (uint16_t)sens2 << 8 | sens1;
    102c:	70 e0       	ldi	r23, 0x00	; 0
    102e:	78 2b       	or	r23, r24
}

static INLINE void debounce_16(uint16_t* k, uint16_t* k_t, uint16_t newk) {
    uint16_t newk_save = newk;
    
    uint16_t changed = newk ^ *k_t;      // XOR: 1 means: changed since last query
    1030:	80 91 15 20 	lds	r24, 0x2015	; 0x802015 <g_sensor_bits_1>
    1034:	90 91 16 20 	lds	r25, 0x2016	; 0x802016 <g_sensor_bits_1+0x1>
    1038:	9b 01       	movw	r18, r22
    103a:	28 27       	eor	r18, r24
    103c:	39 27       	eor	r19, r25
    
    *k &= changed;        // transfer unchanged button bits into keys: clear unchanged button bits
    103e:	80 91 17 20 	lds	r24, 0x2017	; 0x802017 <g_sensor_bits>
    1042:	90 91 18 20 	lds	r25, 0x2018	; 0x802018 <g_sensor_bits+0x1>
    1046:	86 27       	eor	r24, r22
    1048:	97 27       	eor	r25, r23
    104a:	82 23       	and	r24, r18
    104c:	93 23       	and	r25, r19
    *k |= (newk_save & ~changed);
    104e:	86 27       	eor	r24, r22
    1050:	97 27       	eor	r25, r23
    1052:	80 93 17 20 	sts	0x2017, r24	; 0x802017 <g_sensor_bits>
    1056:	90 93 18 20 	sts	0x2018, r25	; 0x802018 <g_sensor_bits+0x1>
    
    *k_t = newk_save;   // time shift
    105a:	60 93 15 20 	sts	0x2015, r22	; 0x802015 <g_sensor_bits_1>
    105e:	70 93 16 20 	sts	0x2016, r23	; 0x802016 <g_sensor_bits_1+0x1>
    
    debounce_16(&g_sensor_bits, &g_sensor_bits_1, sensors);
    
    uint16_t mask = 0x01;
    for (uint8_t i = 0; i < NUM_SENSORS; i++, mask <<= 1) {
    1062:	30 e0       	ldi	r19, 0x00	; 0
    
    uint16_t sensors = (uint16_t)sens2 << 8 | sens1;
    
    debounce_16(&g_sensor_bits, &g_sensor_bits_1, sensors);
    
    uint16_t mask = 0x01;
    1064:	41 e0       	ldi	r20, 0x01	; 1
    1066:	50 e0       	ldi	r21, 0x00	; 0
    1068:	b6 c0       	rjmp	.+364    	; 0x11d6 <__DATA_REGION_LENGTH__+0x1d6>
    for (uint8_t i = 0; i < NUM_SENSORS; i++, mask <<= 1) {
        if (sensors & mask) {
    106a:	fb 01       	movw	r30, r22
    106c:	e4 23       	and	r30, r20
    106e:	f5 23       	and	r31, r21
    1070:	ef 2b       	or	r30, r31
    1072:	e9 f1       	breq	.+122    	; 0x10ee <__DATA_REGION_LENGTH__+0xee>
            if (!g_sensors[i].flags.on) {
    1074:	fc 01       	movw	r30, r24
    1076:	ee 0f       	add	r30, r30
    1078:	ff 1f       	adc	r31, r31
    107a:	ee 0f       	add	r30, r30
    107c:	ff 1f       	adc	r31, r31
    107e:	ee 0f       	add	r30, r30
    1080:	ff 1f       	adc	r31, r31
    1082:	e8 1b       	sub	r30, r24
    1084:	f9 0b       	sbc	r31, r25
    1086:	e5 58       	subi	r30, 0x85	; 133
    1088:	ff 4d       	sbci	r31, 0xDF	; 223
    108a:	20 81       	ld	r18, Z
    108c:	21 fd       	sbrc	r18, 1
    108e:	14 c0       	rjmp	.+40     	; 0x10b8 <__DATA_REGION_LENGTH__+0xb8>
                g_sensors[i].flags.notack = 1;
    1090:	fc 01       	movw	r30, r24
    1092:	ee 0f       	add	r30, r30
    1094:	ff 1f       	adc	r31, r31
    1096:	ee 0f       	add	r30, r30
    1098:	ff 1f       	adc	r31, r31
    109a:	ee 0f       	add	r30, r30
    109c:	ff 1f       	adc	r31, r31
    109e:	e8 1b       	sub	r30, r24
    10a0:	f9 0b       	sbc	r31, r25
    10a2:	df 01       	movw	r26, r30
    10a4:	a5 58       	subi	r26, 0x85	; 133
    10a6:	bf 4d       	sbci	r27, 0xDF	; 223
                g_sensors[i].flags.on = 1;
    10a8:	21 60       	ori	r18, 0x01	; 1
    10aa:	22 60       	ori	r18, 0x02	; 2
    10ac:	2c 93       	st	X, r18
                g_sensors[i].retry_timer = 0;
    10ae:	ea 58       	subi	r30, 0x8A	; 138
    10b0:	ff 4d       	sbci	r31, 0xDF	; 223
    10b2:	16 82       	std	Z+6, r1	; 0x06
                g_sensors[i].locoaddr = 0;
    10b4:	11 82       	std	Z+1, r1	; 0x01
    10b6:	12 82       	std	Z+2, r1	; 0x02
            }
            g_sensors[i].timer = g_sensors[i].holdtime;
    10b8:	fc 01       	movw	r30, r24
    10ba:	ee 0f       	add	r30, r30
    10bc:	ff 1f       	adc	r31, r31
    10be:	ee 0f       	add	r30, r30
    10c0:	ff 1f       	adc	r31, r31
    10c2:	ee 0f       	add	r30, r30
    10c4:	ff 1f       	adc	r31, r31
    10c6:	e8 1b       	sub	r30, r24
    10c8:	f9 0b       	sbc	r31, r25
    10ca:	ea 58       	subi	r30, 0x8A	; 138
    10cc:	ff 4d       	sbci	r31, 0xDF	; 223
    10ce:	24 81       	ldd	r18, Z+4	; 0x04
    10d0:	20 83       	st	Z, r18
            g_sensor_bits |= mask;
    10d2:	e0 91 17 20 	lds	r30, 0x2017	; 0x802017 <g_sensor_bits>
    10d6:	f0 91 18 20 	lds	r31, 0x2018	; 0x802018 <g_sensor_bits+0x1>
    10da:	e4 2b       	or	r30, r20
    10dc:	f5 2b       	or	r31, r21
    10de:	e0 93 17 20 	sts	0x2017, r30	; 0x802017 <g_sensor_bits>
    10e2:	f0 93 18 20 	sts	0x2018, r31	; 0x802018 <g_sensor_bits+0x1>
                g_sensors[i].retry_timer = 0;                
            }
            g_sensors[i].locoaddr = 0;
            g_sensor_bits &= ~mask;
        }
        if (g_sensors[i].timer)
    10e6:	22 23       	and	r18, r18
    10e8:	09 f4       	brne	.+2      	; 0x10ec <__DATA_REGION_LENGTH__+0xec>
    10ea:	57 c0       	rjmp	.+174    	; 0x119a <__DATA_REGION_LENGTH__+0x19a>
    10ec:	49 c0       	rjmp	.+146    	; 0x1180 <__DATA_REGION_LENGTH__+0x180>
                g_sensors[i].retry_timer = 0;
                g_sensors[i].locoaddr = 0;
            }
            g_sensors[i].timer = g_sensors[i].holdtime;
            g_sensor_bits |= mask;
        } else if (g_sensors[i].timer == 0) {
    10ee:	fc 01       	movw	r30, r24
    10f0:	ee 0f       	add	r30, r30
    10f2:	ff 1f       	adc	r31, r31
    10f4:	ee 0f       	add	r30, r30
    10f6:	ff 1f       	adc	r31, r31
    10f8:	ee 0f       	add	r30, r30
    10fa:	ff 1f       	adc	r31, r31
    10fc:	e8 1b       	sub	r30, r24
    10fe:	f9 0b       	sbc	r31, r25
    1100:	ea 58       	subi	r30, 0x8A	; 138
    1102:	ff 4d       	sbci	r31, 0xDF	; 223
    1104:	20 81       	ld	r18, Z
    1106:	21 11       	cpse	r18, r1
    1108:	3b c0       	rjmp	.+118    	; 0x1180 <__DATA_REGION_LENGTH__+0x180>
            if (g_sensors[i].flags.on) {
    110a:	fc 01       	movw	r30, r24
    110c:	ee 0f       	add	r30, r30
    110e:	ff 1f       	adc	r31, r31
    1110:	ee 0f       	add	r30, r30
    1112:	ff 1f       	adc	r31, r31
    1114:	ee 0f       	add	r30, r30
    1116:	ff 1f       	adc	r31, r31
    1118:	e8 1b       	sub	r30, r24
    111a:	f9 0b       	sbc	r31, r25
    111c:	e5 58       	subi	r30, 0x85	; 133
    111e:	ff 4d       	sbci	r31, 0xDF	; 223
    1120:	20 81       	ld	r18, Z
    1122:	21 ff       	sbrs	r18, 1
    1124:	12 c0       	rjmp	.+36     	; 0x114a <__DATA_REGION_LENGTH__+0x14a>
                g_sensors[i].flags.notack = 1;
    1126:	fc 01       	movw	r30, r24
    1128:	ee 0f       	add	r30, r30
    112a:	ff 1f       	adc	r31, r31
    112c:	ee 0f       	add	r30, r30
    112e:	ff 1f       	adc	r31, r31
    1130:	ee 0f       	add	r30, r30
    1132:	ff 1f       	adc	r31, r31
    1134:	e8 1b       	sub	r30, r24
    1136:	f9 0b       	sbc	r31, r25
    1138:	df 01       	movw	r26, r30
    113a:	a5 58       	subi	r26, 0x85	; 133
    113c:	bf 4d       	sbci	r27, 0xDF	; 223
                g_sensors[i].flags.on = 0;
    113e:	21 60       	ori	r18, 0x01	; 1
    1140:	2d 7f       	andi	r18, 0xFD	; 253
    1142:	2c 93       	st	X, r18
                g_sensors[i].retry_timer = 0;                
    1144:	ea 58       	subi	r30, 0x8A	; 138
    1146:	ff 4d       	sbci	r31, 0xDF	; 223
    1148:	16 82       	std	Z+6, r1	; 0x06
            }
            g_sensors[i].locoaddr = 0;
    114a:	fc 01       	movw	r30, r24
    114c:	ee 0f       	add	r30, r30
    114e:	ff 1f       	adc	r31, r31
    1150:	ee 0f       	add	r30, r30
    1152:	ff 1f       	adc	r31, r31
    1154:	ee 0f       	add	r30, r30
    1156:	ff 1f       	adc	r31, r31
    1158:	e8 1b       	sub	r30, r24
    115a:	f9 0b       	sbc	r31, r25
    115c:	ea 58       	subi	r30, 0x8A	; 138
    115e:	ff 4d       	sbci	r31, 0xDF	; 223
    1160:	11 82       	std	Z+1, r1	; 0x01
    1162:	12 82       	std	Z+2, r1	; 0x02
            g_sensor_bits &= ~mask;
    1164:	e0 91 17 20 	lds	r30, 0x2017	; 0x802017 <g_sensor_bits>
    1168:	f0 91 18 20 	lds	r31, 0x2018	; 0x802018 <g_sensor_bits+0x1>
    116c:	da 01       	movw	r26, r20
    116e:	a0 95       	com	r26
    1170:	b0 95       	com	r27
    1172:	ea 23       	and	r30, r26
    1174:	fb 23       	and	r31, r27
    1176:	e0 93 17 20 	sts	0x2017, r30	; 0x802017 <g_sensor_bits>
    117a:	f0 93 18 20 	sts	0x2018, r31	; 0x802018 <g_sensor_bits+0x1>
    117e:	0d c0       	rjmp	.+26     	; 0x119a <__DATA_REGION_LENGTH__+0x19a>
        }
        if (g_sensors[i].timer)
            g_sensors[i].timer--;
    1180:	21 50       	subi	r18, 0x01	; 1
    1182:	fc 01       	movw	r30, r24
    1184:	ee 0f       	add	r30, r30
    1186:	ff 1f       	adc	r31, r31
    1188:	ee 0f       	add	r30, r30
    118a:	ff 1f       	adc	r31, r31
    118c:	ee 0f       	add	r30, r30
    118e:	ff 1f       	adc	r31, r31
    1190:	e8 1b       	sub	r30, r24
    1192:	f9 0b       	sbc	r31, r25
    1194:	ea 58       	subi	r30, 0x8A	; 138
    1196:	ff 4d       	sbci	r31, 0xDF	; 223
    1198:	20 83       	st	Z, r18
        if (g_sensors[i].retry_timer)
    119a:	fc 01       	movw	r30, r24
    119c:	ee 0f       	add	r30, r30
    119e:	ff 1f       	adc	r31, r31
    11a0:	ee 0f       	add	r30, r30
    11a2:	ff 1f       	adc	r31, r31
    11a4:	ee 0f       	add	r30, r30
    11a6:	ff 1f       	adc	r31, r31
    11a8:	e8 1b       	sub	r30, r24
    11aa:	f9 0b       	sbc	r31, r25
    11ac:	ea 58       	subi	r30, 0x8A	; 138
    11ae:	ff 4d       	sbci	r31, 0xDF	; 223
    11b0:	26 81       	ldd	r18, Z+6	; 0x06
    11b2:	22 23       	and	r18, r18
    11b4:	69 f0       	breq	.+26     	; 0x11d0 <__DATA_REGION_LENGTH__+0x1d0>
            g_sensors[i].retry_timer--;
    11b6:	21 50       	subi	r18, 0x01	; 1
    11b8:	fc 01       	movw	r30, r24
    11ba:	ee 0f       	add	r30, r30
    11bc:	ff 1f       	adc	r31, r31
    11be:	ee 0f       	add	r30, r30
    11c0:	ff 1f       	adc	r31, r31
    11c2:	ee 0f       	add	r30, r30
    11c4:	ff 1f       	adc	r31, r31
    11c6:	e8 1b       	sub	r30, r24
    11c8:	f9 0b       	sbc	r31, r25
    11ca:	ea 58       	subi	r30, 0x8A	; 138
    11cc:	ff 4d       	sbci	r31, 0xDF	; 223
    11ce:	26 83       	std	Z+6, r18	; 0x06
    uint16_t sensors = (uint16_t)sens2 << 8 | sens1;
    
    debounce_16(&g_sensor_bits, &g_sensor_bits_1, sensors);
    
    uint16_t mask = 0x01;
    for (uint8_t i = 0; i < NUM_SENSORS; i++, mask <<= 1) {
    11d0:	3f 5f       	subi	r19, 0xFF	; 255
    11d2:	44 0f       	add	r20, r20
    11d4:	55 1f       	adc	r21, r21
    11d6:	83 2f       	mov	r24, r19
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	20 91 19 20 	lds	r18, 0x2019	; 0x802019 <hardwaretyp>
    11de:	21 30       	cpi	r18, 0x01	; 1
    11e0:	19 f0       	breq	.+6      	; 0x11e8 <__DATA_REGION_LENGTH__+0x1e8>
    11e2:	e0 e1       	ldi	r30, 0x10	; 16
    11e4:	f0 e0       	ldi	r31, 0x00	; 0
    11e6:	02 c0       	rjmp	.+4      	; 0x11ec <__DATA_REGION_LENGTH__+0x1ec>
    11e8:	ea e0       	ldi	r30, 0x0A	; 10
    11ea:	f0 e0       	ldi	r31, 0x00	; 0
    11ec:	8e 17       	cp	r24, r30
    11ee:	9f 07       	cpc	r25, r31
    11f0:	0c f4       	brge	.+2      	; 0x11f4 <__DATA_REGION_LENGTH__+0x1f4>
    11f2:	3b cf       	rjmp	.-394    	; 0x106a <__DATA_REGION_LENGTH__+0x6a>
            g_sensors[i].timer--;
        if (g_sensors[i].retry_timer)
            g_sensors[i].retry_timer--;
    }
    
    if (sensors) {
    11f4:	67 2b       	or	r22, r23
    11f6:	59 f0       	breq	.+22     	; 0x120e <__DATA_REGION_LENGTH__+0x20e>
        if (!g_power_on) {
    11f8:	80 91 5e 20 	lds	r24, 0x205E	; 0x80205e <g_power_on>
    11fc:	81 11       	cpse	r24, r1
    11fe:	0c c0       	rjmp	.+24     	; 0x1218 <__DATA_REGION_LENGTH__+0x218>
static INLINE uint8_t timer_timedout(struct timer* t) {
    return t->value == 0;
}

static INLINE void timer_set(struct timer* t, int8_t value) {
    t->value = value;
    1200:	8e e1       	ldi	r24, 0x1E	; 30
    1202:	80 93 62 20 	sts	0x2062, r24	; 0x802062 <g_power_on_timer+0x2>
            timer_set(&g_power_on_timer, 30);
            g_power_on = 1;
    1206:	81 e0       	ldi	r24, 0x01	; 1
    1208:	80 93 5e 20 	sts	0x205E, r24	; 0x80205e <g_power_on>
    120c:	05 c0       	rjmp	.+10     	; 0x1218 <__DATA_REGION_LENGTH__+0x218>
        }
    } else if (g_power_on) {
    120e:	80 91 5e 20 	lds	r24, 0x205E	; 0x80205e <g_power_on>
    1212:	81 11       	cpse	r24, r1
        g_power_on = 0;
    1214:	10 92 5e 20 	sts	0x205E, r1	; 0x80205e <g_power_on>
    if (timer_timedout(&g_led_timer)) {
        timer_set(&g_led_timer, 5); // 5ms

        read_sensors();
        
		if (hardwaretyp == 1) {
    1218:	21 30       	cpi	r18, 0x01	; 1
    121a:	19 f4       	brne	.+6      	; 0x1222 <__DATA_REGION_LENGTH__+0x222>
			// neue Hardware
			show_besetzt_leds();
    121c:	0e 94 28 05 	call	0xa50	; 0xa50 <show_besetzt_leds>
    1220:	02 c0       	rjmp	.+4      	; 0x1226 <__DATA_REGION_LENGTH__+0x226>
		} else {
			//alte hardware
			multiplex_leds();
    1222:	0e 94 8a 05 	call	0xb14	; 0xb14 <multiplex_leds>
		}
    }
        
    uint8_t canread = 0;
    ATOMIC_BLOCK(ATOMIC_RESTORESTATE) {
    1226:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1228:	f8 94       	cli
}

static inline uint8_t ringbuf_count(struct ring_buffer* a_rb) {
    return a_rb->count;
    122a:	80 91 1d 20 	lds	r24, 0x201D	; 0x80201d <g_locoaddr_pipe+0x3>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    122e:	9f bf       	out	0x3f, r25	; 63
        canread = pipe_count(&g_locoaddr_pipe.pipe);
    }
    if (canread >= 4) {
    1230:	84 30       	cpi	r24, 0x04	; 4
    1232:	08 f4       	brcc	.+2      	; 0x1236 <__DATA_REGION_LENGTH__+0x236>
    1234:	65 c0       	rjmp	.+202    	; 0x1300 <__DATA_REGION_LENGTH__+0x300>
        uint16_t sens = 0;
        uint16_t lastaddr = 0;
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { lastaddr = pipe_read(&g_locoaddr_pipe.pipe); }
    1236:	ff b6       	in	r15, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1238:	f8 94       	cli
static INLINE uint8_t pipe_can_read(pipe_t* p) {
    return !ringbuf_isempty(&p->rb);
}

static INLINE uint8_t pipe_read(pipe_t* p) {
    return ringbuf_read(&p->rb);
    123a:	8a e1       	ldi	r24, 0x1A	; 26
    123c:	90 e2       	ldi	r25, 0x20	; 32
    123e:	0e 94 2a 01 	call	0x254	; 0x254 <ringbuf_read>
    1242:	08 2f       	mov	r16, r24
    1244:	10 e0       	ldi	r17, 0x00	; 0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1246:	ff be       	out	0x3f, r15	; 63
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { lastaddr |= ((uint16_t)pipe_read(&g_locoaddr_pipe.pipe) << 8); }
    1248:	df b6       	in	r13, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    124a:	f8 94       	cli
    124c:	8a e1       	ldi	r24, 0x1A	; 26
    124e:	90 e2       	ldi	r25, 0x20	; 32
    1250:	0e 94 2a 01 	call	0x254	; 0x254 <ringbuf_read>
    1254:	78 01       	movw	r14, r16
    1256:	f8 2a       	or	r15, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    1258:	df be       	out	0x3f, r13	; 63
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { sens = pipe_read(&g_locoaddr_pipe.pipe); }
    125a:	df b6       	in	r13, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    125c:	f8 94       	cli
    125e:	8a e1       	ldi	r24, 0x1A	; 26
    1260:	90 e2       	ldi	r25, 0x20	; 32
    1262:	0e 94 2a 01 	call	0x254	; 0x254 <ringbuf_read>
    1266:	08 2f       	mov	r16, r24
    1268:	10 e0       	ldi	r17, 0x00	; 0
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    126a:	df be       	out	0x3f, r13	; 63
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { sens |= ((uint16_t)pipe_read(&g_locoaddr_pipe.pipe) << 8); }
    126c:	df b6       	in	r13, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    126e:	f8 94       	cli
    1270:	8a e1       	ldi	r24, 0x1A	; 26
    1272:	90 e2       	ldi	r25, 0x20	; 32
    1274:	0e 94 2a 01 	call	0x254	; 0x254 <ringbuf_read>
    1278:	98 01       	movw	r18, r16
    127a:	38 2b       	or	r19, r24
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
    127c:	df be       	out	0x3f, r13	; 63
        
        uint16_t mask = 0x01;
        for (uint8_t i = 0; i < 16; i++, mask <<= 1) {
    127e:	90 e0       	ldi	r25, 0x00	; 0
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { lastaddr = pipe_read(&g_locoaddr_pipe.pipe); }
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { lastaddr |= ((uint16_t)pipe_read(&g_locoaddr_pipe.pipe) << 8); }
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { sens = pipe_read(&g_locoaddr_pipe.pipe); }
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { sens |= ((uint16_t)pipe_read(&g_locoaddr_pipe.pipe) << 8); }
        
        uint16_t mask = 0x01;
    1280:	41 e0       	ldi	r20, 0x01	; 1
    1282:	50 e0       	ldi	r21, 0x00	; 0
        for (uint8_t i = 0; i < 16; i++, mask <<= 1) {
            if (sens & mask) {
    1284:	b9 01       	movw	r22, r18
    1286:	64 23       	and	r22, r20
    1288:	75 23       	and	r23, r21
    128a:	67 2b       	or	r22, r23
    128c:	a1 f1       	breq	.+104    	; 0x12f6 <__DATA_REGION_LENGTH__+0x2f6>
                if (g_sensors[i].flags.on && g_sensors[i].locoaddr != lastaddr) {
    128e:	69 2f       	mov	r22, r25
    1290:	70 e0       	ldi	r23, 0x00	; 0
    1292:	87 e0       	ldi	r24, 0x07	; 7
    1294:	98 9f       	mul	r25, r24
    1296:	f0 01       	movw	r30, r0
    1298:	11 24       	eor	r1, r1
    129a:	e5 58       	subi	r30, 0x85	; 133
    129c:	ff 4d       	sbci	r31, 0xDF	; 223
    129e:	80 81       	ld	r24, Z
    12a0:	81 ff       	sbrs	r24, 1
    12a2:	29 c0       	rjmp	.+82     	; 0x12f6 <__DATA_REGION_LENGTH__+0x2f6>
    12a4:	fb 01       	movw	r30, r22
    12a6:	ee 0f       	add	r30, r30
    12a8:	ff 1f       	adc	r31, r31
    12aa:	ee 0f       	add	r30, r30
    12ac:	ff 1f       	adc	r31, r31
    12ae:	ee 0f       	add	r30, r30
    12b0:	ff 1f       	adc	r31, r31
    12b2:	e6 1b       	sub	r30, r22
    12b4:	f7 0b       	sbc	r31, r23
    12b6:	ea 58       	subi	r30, 0x8A	; 138
    12b8:	ff 4d       	sbci	r31, 0xDF	; 223
    12ba:	01 80       	ldd	r0, Z+1	; 0x01
    12bc:	f2 81       	ldd	r31, Z+2	; 0x02
    12be:	e0 2d       	mov	r30, r0
    12c0:	ee 16       	cp	r14, r30
    12c2:	ff 06       	cpc	r15, r31
    12c4:	c1 f0       	breq	.+48     	; 0x12f6 <__DATA_REGION_LENGTH__+0x2f6>
                    g_sensors[i].locoaddr = lastaddr;
    12c6:	fb 01       	movw	r30, r22
    12c8:	ee 0f       	add	r30, r30
    12ca:	ff 1f       	adc	r31, r31
    12cc:	ee 0f       	add	r30, r30
    12ce:	ff 1f       	adc	r31, r31
    12d0:	ee 0f       	add	r30, r30
    12d2:	ff 1f       	adc	r31, r31
    12d4:	df 01       	movw	r26, r30
    12d6:	a6 1b       	sub	r26, r22
    12d8:	b7 0b       	sbc	r27, r23
    12da:	bd 01       	movw	r22, r26
    12dc:	6a 58       	subi	r22, 0x8A	; 138
    12de:	7f 4d       	sbci	r23, 0xDF	; 223
    12e0:	fb 01       	movw	r30, r22
    12e2:	e1 82       	std	Z+1, r14	; 0x01
    12e4:	f2 82       	std	Z+2, r15	; 0x02
                    g_sensors[i].flags.notack = 1;
    12e6:	fd 01       	movw	r30, r26
    12e8:	e5 58       	subi	r30, 0x85	; 133
    12ea:	ff 4d       	sbci	r31, 0xDF	; 223
    12ec:	80 81       	ld	r24, Z
    12ee:	81 60       	ori	r24, 0x01	; 1
    12f0:	80 83       	st	Z, r24
                    g_sensors[i].retry_timer = 0;
    12f2:	fb 01       	movw	r30, r22
    12f4:	16 82       	std	Z+6, r1	; 0x06
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { lastaddr |= ((uint16_t)pipe_read(&g_locoaddr_pipe.pipe) << 8); }
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { sens = pipe_read(&g_locoaddr_pipe.pipe); }
        ATOMIC_BLOCK(ATOMIC_RESTORESTATE) { sens |= ((uint16_t)pipe_read(&g_locoaddr_pipe.pipe) << 8); }
        
        uint16_t mask = 0x01;
        for (uint8_t i = 0; i < 16; i++, mask <<= 1) {
    12f6:	9f 5f       	subi	r25, 0xFF	; 255
    12f8:	44 0f       	add	r20, r20
    12fa:	55 1f       	adc	r21, r21
    12fc:	90 31       	cpi	r25, 0x10	; 16
    12fe:	10 f2       	brcs	.-124    	; 0x1284 <__DATA_REGION_LENGTH__+0x284>
                }
            }
        }
    }
    
    if (bit_is_clear(g_dev_state, DEV_STATE_FLG_WATCHDOG_b)) {
    1300:	05 9b       	sbis	0x00, 5	; 0
    1302:	5a c0       	rjmp	.+180    	; 0x13b8 <__DATA_REGION_LENGTH__+0x3b8>
    1304:	69 c0       	rjmp	.+210    	; 0x13d8 <__DATA_REGION_LENGTH__+0x3d8>
        for (uint8_t i = 0; i < NUM_SENSORS; i++) {
            if (g_sensors[i].retry_timer == 0 && g_sensors[i].flags.notack) {
    1306:	f8 01       	movw	r30, r16
    1308:	ee 0f       	add	r30, r30
    130a:	ff 1f       	adc	r31, r31
    130c:	ee 0f       	add	r30, r30
    130e:	ff 1f       	adc	r31, r31
    1310:	ee 0f       	add	r30, r30
    1312:	ff 1f       	adc	r31, r31
    1314:	e0 1b       	sub	r30, r16
    1316:	f1 0b       	sbc	r31, r17
    1318:	ea 58       	subi	r30, 0x8A	; 138
    131a:	ff 4d       	sbci	r31, 0xDF	; 223
    131c:	86 81       	ldd	r24, Z+6	; 0x06
    131e:	81 11       	cpse	r24, r1
    1320:	49 c0       	rjmp	.+146    	; 0x13b4 <__DATA_REGION_LENGTH__+0x3b4>
    1322:	f8 01       	movw	r30, r16
    1324:	ee 0f       	add	r30, r30
    1326:	ff 1f       	adc	r31, r31
    1328:	ee 0f       	add	r30, r30
    132a:	ff 1f       	adc	r31, r31
    132c:	ee 0f       	add	r30, r30
    132e:	ff 1f       	adc	r31, r31
    1330:	e0 1b       	sub	r30, r16
    1332:	f1 0b       	sbc	r31, r17
    1334:	e5 58       	subi	r30, 0x85	; 133
    1336:	ff 4d       	sbci	r31, 0xDF	; 223
    1338:	80 81       	ld	r24, Z
    133a:	80 ff       	sbrs	r24, 0
    133c:	3b c0       	rjmp	.+118    	; 0x13b4 <__DATA_REGION_LENGTH__+0x3b4>
                g_sensors[i].retry_timer = 50;
    133e:	68 01       	movw	r12, r16
    1340:	cc 0c       	add	r12, r12
    1342:	dd 1c       	adc	r13, r13
    1344:	cc 0c       	add	r12, r12
    1346:	dd 1c       	adc	r13, r13
    1348:	cc 0c       	add	r12, r12
    134a:	dd 1c       	adc	r13, r13
    134c:	c0 1a       	sub	r12, r16
    134e:	d1 0a       	sbc	r13, r17
    1350:	c6 01       	movw	r24, r12
    1352:	8a 58       	subi	r24, 0x8A	; 138
    1354:	9f 4d       	sbci	r25, 0xDF	; 223
    1356:	5c 01       	movw	r10, r24
    1358:	82 e3       	ldi	r24, 0x32	; 50
    135a:	f5 01       	movw	r30, r10
    135c:	86 83       	std	Z+6, r24	; 0x06
                
                struct sboxnet_msg_max msg;
                msg.msgh.dstaddr = 0;
    135e:	19 82       	std	Y+1, r1	; 0x01
                msg.msgh.seq = g_sensors[i].last_seq = get_next_transmit_seq();
    1360:	0e 94 b1 05 	call	0xb62	; 0xb62 <get_next_transmit_seq>
    1364:	f5 01       	movw	r30, r10
    1366:	83 83       	std	Z+3, r24	; 0x03
    1368:	8b 83       	std	Y+3, r24	; 0x03
                msg.msgh.opt.len = 3;
    136a:	8c 81       	ldd	r24, Y+4	; 0x04
    136c:	80 7c       	andi	r24, 0xC0	; 192
    136e:	83 60       	ori	r24, 0x03	; 3
    1370:	8c 83       	std	Y+4, r24	; 0x04
                msg.msgh.cmd = SBOXNET_CMD_FB_LOCOADDR;
    1372:	81 e3       	ldi	r24, 0x31	; 49
    1374:	8d 83       	std	Y+5, r24	; 0x05
                if (g_sensors[i].flags.on) {
    1376:	f6 01       	movw	r30, r12
    1378:	e5 58       	subi	r30, 0x85	; 133
    137a:	ff 4d       	sbci	r31, 0xDF	; 223
    137c:	80 81       	ld	r24, Z
    137e:	81 ff       	sbrs	r24, 1
    1380:	04 c0       	rjmp	.+8      	; 0x138a <__DATA_REGION_LENGTH__+0x38a>
                    msg.data[0] = i|0x80;
    1382:	8f 2d       	mov	r24, r15
    1384:	80 68       	ori	r24, 0x80	; 128
    1386:	8e 83       	std	Y+6, r24	; 0x06
    1388:	01 c0       	rjmp	.+2      	; 0x138c <__DATA_REGION_LENGTH__+0x38c>
                } else {
                    msg.data[0] = i;
    138a:	fe 82       	std	Y+6, r15	; 0x06
                }
                msg.data[1] = lowbyte(g_sensors[i].locoaddr);
    138c:	f8 01       	movw	r30, r16
    138e:	ee 0f       	add	r30, r30
    1390:	ff 1f       	adc	r31, r31
    1392:	ee 0f       	add	r30, r30
    1394:	ff 1f       	adc	r31, r31
    1396:	ee 0f       	add	r30, r30
    1398:	ff 1f       	adc	r31, r31
    139a:	e0 1b       	sub	r30, r16
    139c:	f1 0b       	sbc	r31, r17
    139e:	ea 58       	subi	r30, 0x8A	; 138
    13a0:	ff 4d       	sbci	r31, 0xDF	; 223
    13a2:	91 81       	ldd	r25, Z+1	; 0x01
    13a4:	82 81       	ldd	r24, Z+2	; 0x02
    13a6:	9f 83       	std	Y+7, r25	; 0x07
                msg.data[2] = highbyte(g_sensors[i].locoaddr);
    13a8:	88 87       	std	Y+8, r24	; 0x08
                
                sboxnet_send_msg(&msg.msgh);
    13aa:	ce 01       	movw	r24, r28
    13ac:	01 96       	adiw	r24, 0x01	; 1
    13ae:	0e 94 71 45 	call	0x8ae2	; 0x8ae2 <sboxnet_send_msg>
    13b2:	12 c0       	rjmp	.+36     	; 0x13d8 <__DATA_REGION_LENGTH__+0x3d8>
            }
        }
    }
    
    if (bit_is_clear(g_dev_state, DEV_STATE_FLG_WATCHDOG_b)) {
        for (uint8_t i = 0; i < NUM_SENSORS; i++) {
    13b4:	f3 94       	inc	r15
    13b6:	01 c0       	rjmp	.+2      	; 0x13ba <__DATA_REGION_LENGTH__+0x3ba>
    13b8:	f1 2c       	mov	r15, r1
    13ba:	0f 2d       	mov	r16, r15
    13bc:	10 e0       	ldi	r17, 0x00	; 0
    13be:	80 91 19 20 	lds	r24, 0x2019	; 0x802019 <hardwaretyp>
    13c2:	81 30       	cpi	r24, 0x01	; 1
    13c4:	19 f0       	breq	.+6      	; 0x13cc <__DATA_REGION_LENGTH__+0x3cc>
    13c6:	80 e1       	ldi	r24, 0x10	; 16
    13c8:	90 e0       	ldi	r25, 0x00	; 0
    13ca:	02 c0       	rjmp	.+4      	; 0x13d0 <__DATA_REGION_LENGTH__+0x3d0>
    13cc:	8a e0       	ldi	r24, 0x0A	; 10
    13ce:	90 e0       	ldi	r25, 0x00	; 0
    13d0:	08 17       	cp	r16, r24
    13d2:	19 07       	cpc	r17, r25
    13d4:	0c f4       	brge	.+2      	; 0x13d8 <__DATA_REGION_LENGTH__+0x3d8>
    13d6:	97 cf       	rjmp	.-210    	; 0x1306 <__DATA_REGION_LENGTH__+0x306>
            }
        }
    }
    
    // write eeprom
    if (g_holdtime != g_old_holdtime && eeprom_is_ready()) {
    13d8:	60 91 5f 20 	lds	r22, 0x205F	; 0x80205f <g_holdtime>
    13dc:	80 91 75 20 	lds	r24, 0x2075	; 0x802075 <g_old_holdtime>
    13e0:	68 17       	cp	r22, r24
    13e2:	61 f0       	breq	.+24     	; 0x13fc <__DATA_REGION_LENGTH__+0x3fc>
    13e4:	80 91 cf 01 	lds	r24, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    13e8:	88 23       	and	r24, r24
    13ea:	44 f0       	brlt	.+16     	; 0x13fc <__DATA_REGION_LENGTH__+0x3fc>
        eeprom_update_byte(&g_eeprom.holdtime, g_holdtime);
    13ec:	80 e0       	ldi	r24, 0x00	; 0
    13ee:	90 e0       	ldi	r25, 0x00	; 0
    13f0:	0e 94 67 0a 	call	0x14ce	; 0x14ce <eeprom_update_byte>
        g_old_holdtime = g_holdtime;
    13f4:	80 91 5f 20 	lds	r24, 0x205F	; 0x80205f <g_holdtime>
    13f8:	80 93 75 20 	sts	0x2075, r24	; 0x802075 <g_old_holdtime>
            }
        }
    }
    
    if (bit_is_clear(g_dev_state, DEV_STATE_FLG_WATCHDOG_b)) {
        for (uint8_t i = 0; i < NUM_SENSORS; i++) {
    13fc:	10 e0       	ldi	r17, 0x00	; 0
    13fe:	30 c0       	rjmp	.+96     	; 0x1460 <__DATA_REGION_LENGTH__+0x460>
    if (g_holdtime != g_old_holdtime && eeprom_is_ready()) {
        eeprom_update_byte(&g_eeprom.holdtime, g_holdtime);
        g_old_holdtime = g_holdtime;
    }
    for (uint8_t i = 0; i < NUM_SENSORS; i++) {
        if (g_sensors[i].flags.holdtime_changed && eeprom_is_ready()) {
    1400:	fc 01       	movw	r30, r24
    1402:	ee 0f       	add	r30, r30
    1404:	ff 1f       	adc	r31, r31
    1406:	ee 0f       	add	r30, r30
    1408:	ff 1f       	adc	r31, r31
    140a:	ee 0f       	add	r30, r30
    140c:	ff 1f       	adc	r31, r31
    140e:	e8 1b       	sub	r30, r24
    1410:	f9 0b       	sbc	r31, r25
    1412:	e5 58       	subi	r30, 0x85	; 133
    1414:	ff 4d       	sbci	r31, 0xDF	; 223
    1416:	20 81       	ld	r18, Z
    1418:	22 ff       	sbrs	r18, 2
    141a:	21 c0       	rjmp	.+66     	; 0x145e <__DATA_REGION_LENGTH__+0x45e>
    141c:	20 91 cf 01 	lds	r18, 0x01CF	; 0x8001cf <__TEXT_REGION_LENGTH__+0x7f71cf>
    1420:	22 23       	and	r18, r18
    1422:	ec f0       	brlt	.+58     	; 0x145e <__DATA_REGION_LENGTH__+0x45e>
            eeprom_update_byte(&g_eeprom.sensors[i].holdtime, g_sensors[i].holdtime);
    1424:	7c 01       	movw	r14, r24
    1426:	ee 0c       	add	r14, r14
    1428:	ff 1c       	adc	r15, r15
    142a:	ee 0c       	add	r14, r14
    142c:	ff 1c       	adc	r15, r15
    142e:	ee 0c       	add	r14, r14
    1430:	ff 1c       	adc	r15, r15
    1432:	e8 1a       	sub	r14, r24
    1434:	f9 0a       	sbc	r15, r25
    1436:	f7 01       	movw	r30, r14
    1438:	ea 58       	subi	r30, 0x8A	; 138
    143a:	ff 4d       	sbci	r31, 0xDF	; 223
    143c:	64 81       	ldd	r22, Z+4	; 0x04
    143e:	82 95       	swap	r24
    1440:	92 95       	swap	r25
    1442:	90 7f       	andi	r25, 0xF0	; 240
    1444:	98 27       	eor	r25, r24
    1446:	80 7f       	andi	r24, 0xF0	; 240
    1448:	98 27       	eor	r25, r24
    144a:	8f 5f       	subi	r24, 0xFF	; 255
    144c:	9f 4f       	sbci	r25, 0xFF	; 255
    144e:	0e 94 67 0a 	call	0x14ce	; 0x14ce <eeprom_update_byte>
            g_sensors[i].flags.holdtime_changed = 0;
    1452:	f7 01       	movw	r30, r14
    1454:	e5 58       	subi	r30, 0x85	; 133
    1456:	ff 4d       	sbci	r31, 0xDF	; 223
    1458:	80 81       	ld	r24, Z
    145a:	8b 7f       	andi	r24, 0xFB	; 251
    145c:	80 83       	st	Z, r24
    // write eeprom
    if (g_holdtime != g_old_holdtime && eeprom_is_ready()) {
        eeprom_update_byte(&g_eeprom.holdtime, g_holdtime);
        g_old_holdtime = g_holdtime;
    }
    for (uint8_t i = 0; i < NUM_SENSORS; i++) {
    145e:	1f 5f       	subi	r17, 0xFF	; 255
    1460:	81 2f       	mov	r24, r17
    1462:	90 e0       	ldi	r25, 0x00	; 0
    1464:	20 91 19 20 	lds	r18, 0x2019	; 0x802019 <hardwaretyp>
    1468:	21 30       	cpi	r18, 0x01	; 1
    146a:	19 f0       	breq	.+6      	; 0x1472 <__DATA_REGION_LENGTH__+0x472>
    146c:	20 e1       	ldi	r18, 0x10	; 16
    146e:	30 e0       	ldi	r19, 0x00	; 0
    1470:	02 c0       	rjmp	.+4      	; 0x1476 <__DATA_REGION_LENGTH__+0x476>
    1472:	2a e0       	ldi	r18, 0x0A	; 10
    1474:	30 e0       	ldi	r19, 0x00	; 0
    1476:	82 17       	cp	r24, r18
    1478:	93 07       	cpc	r25, r19
    147a:	14 f2       	brlt	.-124    	; 0x1400 <__DATA_REGION_LENGTH__+0x400>
            eeprom_update_byte(&g_eeprom.sensors[i].holdtime, g_sensors[i].holdtime);
            g_sensors[i].flags.holdtime_changed = 0;
        }
    }
    
    sleep_cpu();
    147c:	88 95       	sleep
}
    147e:	cb 5b       	subi	r28, 0xBB	; 187
    1480:	df 4f       	sbci	r29, 0xFF	; 255
    1482:	cd bf       	out	0x3d, r28	; 61
    1484:	de bf       	out	0x3e, r29	; 62
    1486:	df 91       	pop	r29
    1488:	cf 91       	pop	r28
    148a:	1f 91       	pop	r17
    148c:	0f 91       	pop	r16
    148e:	ff 90       	pop	r15
    1490:	ef 90       	pop	r14
    1492:	df 90       	pop	r13
    1494:	cf 90       	pop	r12
    1496:	bf 90       	pop	r11
    1498:	af 90       	pop	r10
    149a:	08 95       	ret

0000149c <do_before_bldr_activate>:
/* void dec_stop(void)
 * DCC Decoder stoppen.
 */
static void dec_stop(void) {
	// Status auf OFF
    g_dccdec.state = DEC_STATE_OFF;
    149c:	10 92 63 20 	sts	0x2063, r1	; 0x802063 <g_dccdec>
	// keine Interrupts
    TCD1.INTCTRLB = 0;
    14a0:	e0 e4       	ldi	r30, 0x40	; 64
    14a2:	f9 e0       	ldi	r31, 0x09	; 9
    14a4:	17 82       	std	Z+7, r1	; 0x07
	// Interrupt Flags clearen
    TCD1.INTFLAGS = 0xff;
    14a6:	8f ef       	ldi	r24, 0xFF	; 255
    14a8:	84 87       	std	Z+12, r24	; 0x0c
	// und Timer TCD1 aus
    TCD1.CTRLA = TC_CLKSEL_OFF_gc;
    14aa:	10 82       	st	Z, r1
    14ac:	08 95       	ret

000014ae <eeprom_update_block>:
    14ae:	dc 01       	movw	r26, r24
    14b0:	a4 0f       	add	r26, r20
    14b2:	b5 1f       	adc	r27, r21
    14b4:	41 50       	subi	r20, 0x01	; 1
    14b6:	50 40       	sbci	r21, 0x00	; 0
    14b8:	48 f0       	brcs	.+18     	; 0x14cc <eeprom_update_block+0x1e>
    14ba:	cb 01       	movw	r24, r22
    14bc:	84 0f       	add	r24, r20
    14be:	95 1f       	adc	r25, r21
    14c0:	2e 91       	ld	r18, -X
    14c2:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <eeprom_update_r18>
    14c6:	41 50       	subi	r20, 0x01	; 1
    14c8:	50 40       	sbci	r21, 0x00	; 0
    14ca:	d0 f7       	brcc	.-12     	; 0x14c0 <eeprom_update_block+0x12>
    14cc:	08 95       	ret

000014ce <eeprom_update_byte>:
    14ce:	26 2f       	mov	r18, r22

000014d0 <eeprom_update_r18>:
    14d0:	0e 94 9f 0a 	call	0x153e	; 0x153e <eeprom_mapen>
    14d4:	00 80       	ld	r0, Z
    14d6:	02 16       	cp	r0, r18
    14d8:	19 f0       	breq	.+6      	; 0x14e0 <eeprom_update_r18+0x10>
    14da:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <eeprom_write_r18>
    14de:	01 97       	sbiw	r24, 0x01	; 1
    14e0:	01 97       	sbiw	r24, 0x01	; 1
    14e2:	08 95       	ret

000014e4 <eeprom_update_word>:
    14e4:	01 96       	adiw	r24, 0x01	; 1
    14e6:	27 2f       	mov	r18, r23
    14e8:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <eeprom_update_r18>
    14ec:	0c 94 67 0a 	jmp	0x14ce	; 0x14ce <eeprom_update_byte>

000014f0 <eeprom_write_byte>:
    14f0:	26 2f       	mov	r18, r22

000014f2 <eeprom_write_r18>:
    14f2:	e0 ec       	ldi	r30, 0xC0	; 192
    14f4:	f1 e0       	ldi	r31, 0x01	; 1
    14f6:	37 85       	ldd	r19, Z+15	; 0x0f
    14f8:	37 fd       	sbrc	r19, 7
    14fa:	fd cf       	rjmp	.-6      	; 0x14f6 <eeprom_write_r18+0x4>
    14fc:	34 85       	ldd	r19, Z+12	; 0x0c
    14fe:	37 7f       	andi	r19, 0xF7	; 247
    1500:	34 87       	std	Z+12, r19	; 0x0c
    1502:	37 85       	ldd	r19, Z+15	; 0x0f
    1504:	31 ff       	sbrs	r19, 1
    1506:	09 c0       	rjmp	.+18     	; 0x151a <eeprom_write_r18+0x28>
    1508:	36 e3       	ldi	r19, 0x36	; 54
    150a:	32 87       	std	Z+10, r19	; 0x0a
    150c:	38 ed       	ldi	r19, 0xD8	; 216
    150e:	34 bf       	out	0x34, r19	; 52
    1510:	31 e0       	ldi	r19, 0x01	; 1
    1512:	33 87       	std	Z+11, r19	; 0x0b
    1514:	37 85       	ldd	r19, Z+15	; 0x0f
    1516:	37 fd       	sbrc	r19, 7
    1518:	fd cf       	rjmp	.-6      	; 0x1514 <eeprom_write_r18+0x22>
    151a:	33 e3       	ldi	r19, 0x33	; 51
    151c:	32 87       	std	Z+10, r19	; 0x0a
    151e:	80 83       	st	Z, r24
    1520:	91 83       	std	Z+1, r25	; 0x01
    1522:	12 82       	std	Z+2, r1	; 0x02
    1524:	24 83       	std	Z+4, r18	; 0x04
    1526:	25 e3       	ldi	r18, 0x35	; 53
    1528:	22 87       	std	Z+10, r18	; 0x0a
    152a:	28 ed       	ldi	r18, 0xD8	; 216
    152c:	31 e0       	ldi	r19, 0x01	; 1
    152e:	24 bf       	out	0x34, r18	; 52
    1530:	33 87       	std	Z+11, r19	; 0x0b
    1532:	01 96       	adiw	r24, 0x01	; 1
    1534:	08 95       	ret

00001536 <eeprom_read_byte>:
    1536:	03 d0       	rcall	.+6      	; 0x153e <eeprom_mapen>
    1538:	80 81       	ld	r24, Z
    153a:	99 27       	eor	r25, r25
    153c:	08 95       	ret

0000153e <eeprom_mapen>:
    153e:	e0 ec       	ldi	r30, 0xC0	; 192
    1540:	f1 e0       	ldi	r31, 0x01	; 1
    1542:	37 85       	ldd	r19, Z+15	; 0x0f
    1544:	37 fd       	sbrc	r19, 7
    1546:	fd cf       	rjmp	.-6      	; 0x1542 <eeprom_mapen+0x4>
    1548:	34 85       	ldd	r19, Z+12	; 0x0c
    154a:	38 60       	ori	r19, 0x08	; 8
    154c:	34 87       	std	Z+12, r19	; 0x0c
    154e:	fc 01       	movw	r30, r24
    1550:	e0 50       	subi	r30, 0x00	; 0
    1552:	f0 4f       	sbci	r31, 0xF0	; 240
    1554:	08 95       	ret

00001556 <_exit>:
    1556:	f8 94       	cli

00001558 <__stop_program>:
    1558:	ff cf       	rjmp	.-2      	; 0x1558 <__stop_program>
