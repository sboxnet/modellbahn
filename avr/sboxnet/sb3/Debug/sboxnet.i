# 1 ".././sboxnet.c"
# 1 "C:\\Users\\balagi\\Documents\\git\\sb3\\sb3\\Debug//"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 ".././sboxnet.c"
# 20 ".././sboxnet.c"
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 1 3
# 46 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 1 3 4
# 216 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 3 4

# 216 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 47 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 2 3
# 125 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern int ffs(int __val) __attribute__((__const__));





extern int ffsl(long __val) __attribute__((__const__));





__extension__ extern int ffsll(long long __val) __attribute__((__const__));
# 150 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern void *memccpy(void *, const void *, int, size_t);
# 162 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern void *memchr(const void *, int, size_t) __attribute__((__pure__));
# 180 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern int memcmp(const void *, const void *, size_t) __attribute__((__pure__));
# 191 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern void *memcpy(void *, const void *, size_t);
# 203 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern void *memmem(const void *, size_t, const void *, size_t) __attribute__((__pure__));
# 213 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern void *memmove(void *, const void *, size_t);
# 225 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern void *memrchr(const void *, int, size_t) __attribute__((__pure__));
# 235 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern void *memset(void *, int, size_t);
# 248 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strcat(char *, const char *);
# 262 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strchr(const char *, int) __attribute__((__pure__));
# 274 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strchrnul(const char *, int) __attribute__((__pure__));
# 287 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern int strcmp(const char *, const char *) __attribute__((__pure__));
# 305 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strcpy(char *, const char *);
# 320 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern int strcasecmp(const char *, const char *) __attribute__((__pure__));
# 333 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strcasestr(const char *, const char *) __attribute__((__pure__));
# 344 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern size_t strcspn(const char *__s, const char *__reject) __attribute__((__pure__));
# 364 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strdup(const char *s1);
# 377 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern size_t strlcat(char *, const char *, size_t);
# 388 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern size_t strlcpy(char *, const char *, size_t);
# 399 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern size_t strlen(const char *) __attribute__((__pure__));
# 411 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strlwr(char *);
# 422 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strncat(char *, const char *, size_t);
# 434 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern int strncmp(const char *, const char *, size_t) __attribute__((__pure__));
# 449 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strncpy(char *, const char *, size_t);
# 464 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern int strncasecmp(const char *, const char *, size_t) __attribute__((__pure__));
# 478 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern size_t strnlen(const char *, size_t) __attribute__((__pure__));
# 491 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strpbrk(const char *__s, const char *__accept) __attribute__((__pure__));
# 505 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strrchr(const char *, int) __attribute__((__pure__));
# 515 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strrev(char *);
# 533 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strsep(char **, const char *);
# 544 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern size_t strspn(const char *__s, const char *__accept) __attribute__((__pure__));
# 557 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strstr(const char *, const char *) __attribute__((__pure__));
# 576 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strtok(char *, const char *);
# 593 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strtok_r(char *, const char *, char **);
# 606 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\string.h" 3
extern char *strupr(char *);



extern int strcoll(const char *s1, const char *s2);
extern char *strerror(int errnum);
extern size_t strxfrm(char *dest, const char *src, size_t n);
# 21 ".././sboxnet.c" 2

# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 1 3
# 39 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 1 3 4
# 9 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 3 4
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 1 3 4
# 125 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef signed int int8_t __attribute__((__mode__(__QI__)));
typedef unsigned int uint8_t __attribute__((__mode__(__QI__)));
typedef signed int int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int uint16_t __attribute__ ((__mode__ (__HI__)));
typedef signed int int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int uint32_t __attribute__ ((__mode__ (__SI__)));

typedef signed int int64_t __attribute__((__mode__(__DI__)));
typedef unsigned int uint64_t __attribute__((__mode__(__DI__)));
# 146 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int16_t intptr_t;




typedef uint16_t uintptr_t;
# 163 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int8_t int_least8_t;




typedef uint8_t uint_least8_t;




typedef int16_t int_least16_t;




typedef uint16_t uint_least16_t;




typedef int32_t int_least32_t;




typedef uint32_t uint_least32_t;







typedef int64_t int_least64_t;






typedef uint64_t uint_least64_t;
# 217 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int8_t int_fast8_t;




typedef uint8_t uint_fast8_t;




typedef int16_t int_fast16_t;




typedef uint16_t uint_fast16_t;




typedef int32_t int_fast32_t;




typedef uint32_t uint_fast32_t;







typedef int64_t int_fast64_t;






typedef uint64_t uint_fast64_t;
# 277 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\stdint.h" 3 4
typedef int64_t intmax_t;




typedef uint64_t uintmax_t;
# 10 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stdint.h" 2 3 4
# 40 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 2 3
# 112 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint16_t
_crc16_update(uint16_t __crc, uint8_t __data)
{
 uint8_t __tmp;
 uint16_t __ret;

 __asm__ __volatile__ (
  "eor %A0,%2" "\n\t"
  "mov %1,%A0" "\n\t"
  "swap %1" "\n\t"
  "eor %1,%A0" "\n\t"
  "mov __tmp_reg__,%1" "\n\t"
  "lsr %1" "\n\t"
  "lsr %1" "\n\t"
  "eor %1,__tmp_reg__" "\n\t"
  "mov __tmp_reg__,%1" "\n\t"
  "lsr %1" "\n\t"
  "eor %1,__tmp_reg__" "\n\t"
  "andi %1,0x07" "\n\t"
  "mov __tmp_reg__,%A0" "\n\t"
  "mov %A0,%B0" "\n\t"
  "lsr %1" "\n\t"
  "ror __tmp_reg__" "\n\t"
  "ror %1" "\n\t"
  "mov %B0,__tmp_reg__" "\n\t"
  "eor %A0,%1" "\n\t"
  "lsr __tmp_reg__" "\n\t"
  "ror %1" "\n\t"
  "eor %B0,__tmp_reg__" "\n\t"
  "eor %A0,%1"
  : "=r" (__ret), "=d" (__tmp)
  : "r" (__data), "0" (__crc)
  : "r0"
 );
 return __ret;
}
# 178 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint16_t
_crc_xmodem_update(uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;
    uint8_t __tmp1;
    uint8_t __tmp2;


    __asm__ __volatile__ (
        "eor    %B0,%3" "\n\t"
        "mov    __tmp_reg__,%B0" "\n\t"
        "swap   __tmp_reg__" "\n\t"


        "mov    %1,__tmp_reg__" "\n\t"
        "andi   %1,0x0f" "\n\t"
        "eor    %1,%B0" "\n\t"
        "mov    %2,%B0" "\n\t"
        "eor    %2,__tmp_reg__" "\n\t"
        "lsl    %2" "\n\t"
        "andi   %2,0xe0" "\n\t"
        "eor    %1,%2" "\n\t"


        "mov    %2,__tmp_reg__" "\n\t"
        "eor    %2,%B0" "\n\t"
        "andi   %2,0xf0" "\n\t"
        "lsr    %2" "\n\t"
        "mov    __tmp_reg__,%B0" "\n\t"
        "lsl    __tmp_reg__" "\n\t"
        "rol    %2" "\n\t"
        "lsr    %B0" "\n\t"
        "lsr    %B0" "\n\t"
        "lsr    %B0" "\n\t"
        "andi   %B0,0x1f" "\n\t"
        "eor    %B0,%2" "\n\t"
        "eor    %B0,%A0" "\n\t"
        "mov    %A0,%1" "\n\t"
        : "=d" (__ret), "=d" (__tmp1), "=d" (__tmp2)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
# 252 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint16_t
_crc_ccitt_update (uint16_t __crc, uint8_t __data)
{
    uint16_t __ret;

    __asm__ __volatile__ (
        "eor    %A0,%1" "\n\t"

        "mov    __tmp_reg__,%A0" "\n\t"
        "swap   %A0" "\n\t"
        "andi   %A0,0xf0" "\n\t"
        "eor    %A0,__tmp_reg__" "\n\t"

        "mov    __tmp_reg__,%B0" "\n\t"

        "mov    %B0,%A0" "\n\t"

        "swap   %A0" "\n\t"
        "andi   %A0,0x0f" "\n\t"
        "eor    __tmp_reg__,%A0" "\n\t"

        "lsr    %A0" "\n\t"
        "eor    %B0,%A0" "\n\t"

        "eor    %A0,%B0" "\n\t"
        "lsl    %A0" "\n\t"
        "lsl    %A0" "\n\t"
        "lsl    %A0" "\n\t"
        "eor    %A0,__tmp_reg__"

        : "=d" (__ret)
        : "r" (__data), "0" (__crc)
        : "r0"
    );
    return __ret;
}
# 319 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint8_t
_crc_ibutton_update(uint8_t __crc, uint8_t __data)
{
 uint8_t __i, __pattern;
 __asm__ __volatile__ (
  "	eor	%0, %4" "\n\t"
  "	ldi	%1, 8" "\n\t"
  "	ldi	%2, 0x8C" "\n\t"
  "1:	lsr	%0" "\n\t"
  "	brcc	2f" "\n\t"
  "	eor	%0, %2" "\n\t"
  "2:	dec	%1" "\n\t"
  "	brne	1b" "\n\t"
  : "=r" (__crc), "=d" (__i), "=d" (__pattern)
  : "0" (__crc), "r" (__data));
 return __crc;
}
# 385 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\crc16.h" 3
static __inline__ uint8_t
_crc8_ccitt_update(uint8_t __crc, uint8_t __data)
{
    uint8_t __i, __pattern;
    __asm__ __volatile__ (
        "    eor    %0, %4" "\n\t"
        "    ldi    %1, 8" "\n\t"
        "    ldi    %2, 0x07" "\n\t"
        "1:  lsl    %0" "\n\t"
        "    brcc   2f" "\n\t"
        "    eor    %0, %2" "\n\t"
        "2:  dec    %1" "\n\t"
        "    brne   1b" "\n\t"
        : "=r" (__crc), "=d" (__i), "=d" (__pattern)
        : "0" (__crc), "r" (__data));
    return __crc;
}
# 23 ".././sboxnet.c" 2
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 1 3
# 37 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 1 3
# 99 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\sfr_defs.h" 1 3
# 126 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\sfr_defs.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\inttypes.h" 1 3
# 77 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\inttypes.h" 3
typedef int32_t int_farptr_t;



typedef uint32_t uint_farptr_t;
# 127 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\sfr_defs.h" 2 3
# 100 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3
# 488 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 3
# 1 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 1 3
# 84 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef volatile uint8_t register8_t;
typedef volatile uint16_t register16_t;
typedef volatile uint32_t register32_t;
# 134 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct AC_struct
{
    register8_t AC0CTRL;
    register8_t AC1CTRL;
    register8_t AC0MUXCTRL;
    register8_t AC1MUXCTRL;
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t WINCTRL;
    register8_t STATUS;
} AC_t;


typedef enum AC_HYSMODE_enum
{
    AC_HYSMODE_NO_gc = (0x00<<1),
    AC_HYSMODE_SMALL_gc = (0x01<<1),
    AC_HYSMODE_LARGE_gc = (0x02<<1),
} AC_HYSMODE_t;


typedef enum AC_INTLVL_enum
{
    AC_INTLVL_OFF_gc = (0x00<<4),
    AC_INTLVL_LO_gc = (0x01<<4),
    AC_INTLVL_MED_gc = (0x02<<4),
    AC_INTLVL_HI_gc = (0x03<<4),
} AC_INTLVL_t;


typedef enum AC_INTMODE_enum
{
    AC_INTMODE_BOTHEDGES_gc = (0x00<<6),
    AC_INTMODE_FALLING_gc = (0x02<<6),
    AC_INTMODE_RISING_gc = (0x03<<6),
} AC_INTMODE_t;


typedef enum AC_MUXNEG_enum
{
    AC_MUXNEG_PIN0_gc = (0x00<<0),
    AC_MUXNEG_PIN1_gc = (0x01<<0),
    AC_MUXNEG_PIN3_gc = (0x02<<0),
    AC_MUXNEG_PIN5_gc = (0x03<<0),
    AC_MUXNEG_PIN7_gc = (0x04<<0),
    AC_MUXNEG_DAC_gc = (0x05<<0),
    AC_MUXNEG_BANDGAP_gc = (0x06<<0),
    AC_MUXNEG_SCALER_gc = (0x07<<0),
} AC_MUXNEG_t;


typedef enum AC_MUXPOS_enum
{
    AC_MUXPOS_PIN0_gc = (0x00<<3),
    AC_MUXPOS_PIN1_gc = (0x01<<3),
    AC_MUXPOS_PIN2_gc = (0x02<<3),
    AC_MUXPOS_PIN3_gc = (0x03<<3),
    AC_MUXPOS_PIN4_gc = (0x04<<3),
    AC_MUXPOS_PIN5_gc = (0x05<<3),
    AC_MUXPOS_PIN6_gc = (0x06<<3),
    AC_MUXPOS_DAC_gc = (0x07<<3),
} AC_MUXPOS_t;


typedef enum AC_WINTLVL_enum
{
    AC_WINTLVL_OFF_gc = (0x00<<0),
    AC_WINTLVL_LO_gc = (0x01<<0),
    AC_WINTLVL_MED_gc = (0x02<<0),
    AC_WINTLVL_HI_gc = (0x03<<0),
} AC_WINTLVL_t;


typedef enum AC_WINTMODE_enum
{
    AC_WINTMODE_ABOVE_gc = (0x00<<2),
    AC_WINTMODE_INSIDE_gc = (0x01<<2),
    AC_WINTMODE_BELOW_gc = (0x02<<2),
    AC_WINTMODE_OUTSIDE_gc = (0x03<<2),
} AC_WINTMODE_t;


typedef enum AC_WSTATE_enum
{
    AC_WSTATE_ABOVE_gc = (0x00<<6),
    AC_WSTATE_INSIDE_gc = (0x01<<6),
    AC_WSTATE_BELOW_gc = (0x02<<6),
} AC_WSTATE_t;
# 230 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct ADC_CH_struct
{
    register8_t CTRL;
    register8_t MUXCTRL;
    register8_t INTCTRL;
    register8_t INTFLAGS;
    __extension__ union { register16_t RES; struct { register8_t RESL; register8_t RESH; }; };
    register8_t SCAN;
    register8_t reserved_1[1];
} ADC_CH_t;



typedef struct ADC_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t REFCTRL;
    register8_t EVCTRL;
    register8_t PRESCALER;
    register8_t reserved_1[1];
    register8_t INTFLAGS;
    register8_t TEMP;
    register8_t reserved_2[4];
    __extension__ union { register16_t CAL; struct { register8_t CALL; register8_t CALH; }; };
    register8_t reserved_3[2];
    __extension__ union { register16_t CH0RES; struct { register8_t CH0RESL; register8_t CH0RESH; }; };
    __extension__ union { register16_t CH1RES; struct { register8_t CH1RESL; register8_t CH1RESH; }; };
    __extension__ union { register16_t CH2RES; struct { register8_t CH2RESL; register8_t CH2RESH; }; };
    __extension__ union { register16_t CH3RES; struct { register8_t CH3RESL; register8_t CH3RESH; }; };
    __extension__ union { register16_t CMP; struct { register8_t CMPL; register8_t CMPH; }; };
    register8_t reserved_4[6];
    ADC_CH_t CH0;
    ADC_CH_t CH1;
    ADC_CH_t CH2;
    ADC_CH_t CH3;
} ADC_t;


typedef enum ADC_CH_GAIN_enum
{
    ADC_CH_GAIN_1X_gc = (0x00<<2),
    ADC_CH_GAIN_2X_gc = (0x01<<2),
    ADC_CH_GAIN_4X_gc = (0x02<<2),
    ADC_CH_GAIN_8X_gc = (0x03<<2),
    ADC_CH_GAIN_16X_gc = (0x04<<2),
    ADC_CH_GAIN_32X_gc = (0x05<<2),
    ADC_CH_GAIN_64X_gc = (0x06<<2),
    ADC_CH_GAIN_DIV2_gc = (0x07<<2),
} ADC_CH_GAIN_t;


typedef enum ADC_CH_INPUTMODE_enum
{
    ADC_CH_INPUTMODE_INTERNAL_gc = (0x00<<0),
    ADC_CH_INPUTMODE_SINGLEENDED_gc = (0x01<<0),
    ADC_CH_INPUTMODE_DIFF_gc = (0x02<<0),
    ADC_CH_INPUTMODE_DIFFWGAIN_gc = (0x03<<0),
} ADC_CH_INPUTMODE_t;


typedef enum ADC_CH_INTLVL_enum
{
    ADC_CH_INTLVL_OFF_gc = (0x00<<0),
    ADC_CH_INTLVL_LO_gc = (0x01<<0),
    ADC_CH_INTLVL_MED_gc = (0x02<<0),
    ADC_CH_INTLVL_HI_gc = (0x03<<0),
} ADC_CH_INTLVL_t;


typedef enum ADC_CH_INTMODE_enum
{
    ADC_CH_INTMODE_COMPLETE_gc = (0x00<<2),
    ADC_CH_INTMODE_BELOW_gc = (0x01<<2),
    ADC_CH_INTMODE_ABOVE_gc = (0x03<<2),
} ADC_CH_INTMODE_t;


typedef enum ADC_CH_MUXINT_enum
{
    ADC_CH_MUXINT_TEMP_gc = (0x00<<3),
    ADC_CH_MUXINT_BANDGAP_gc = (0x01<<3),
    ADC_CH_MUXINT_SCALEDVCC_gc = (0x02<<3),
    ADC_CH_MUXINT_DAC_gc = (0x03<<3),
} ADC_CH_MUXINT_t;


typedef enum ADC_CH_MUXNEG_enum
{
    ADC_CH_MUXNEG_PIN0_gc = (0x00<<0),
    ADC_CH_MUXNEG_PIN4_gc = (0x00<<0),
    ADC_CH_MUXNEG_PIN1_gc = (0x01<<0),
    ADC_CH_MUXNEG_PIN5_gc = (0x01<<0),
    ADC_CH_MUXNEG_PIN2_gc = (0x02<<0),
    ADC_CH_MUXNEG_PIN6_gc = (0x02<<0),
    ADC_CH_MUXNEG_PIN3_gc = (0x03<<0),
    ADC_CH_MUXNEG_PIN7_gc = (0x03<<0),
    ADC_CH_MUXNEG_INTGND_MODE4_gc = (0x04<<0),
    ADC_CH_MUXNEG_GND_MODE3_gc = (0x05<<0),
    ADC_CH_MUXNEG_INTGND_MODE3_gc = (0x07<<0),
    ADC_CH_MUXNEG_GND_MODE4_gc = (0x07<<0),
} ADC_CH_MUXNEG_t;


typedef enum ADC_CH_MUXPOS_enum
{
    ADC_CH_MUXPOS_PIN0_gc = (0x00<<3),
    ADC_CH_MUXPOS_PIN1_gc = (0x01<<3),
    ADC_CH_MUXPOS_PIN2_gc = (0x02<<3),
    ADC_CH_MUXPOS_PIN3_gc = (0x03<<3),
    ADC_CH_MUXPOS_PIN4_gc = (0x04<<3),
    ADC_CH_MUXPOS_PIN5_gc = (0x05<<3),
    ADC_CH_MUXPOS_PIN6_gc = (0x06<<3),
    ADC_CH_MUXPOS_PIN7_gc = (0x07<<3),
    ADC_CH_MUXPOS_PIN8_gc = (0x08<<3),
    ADC_CH_MUXPOS_PIN9_gc = (0x09<<3),
    ADC_CH_MUXPOS_PIN10_gc = (0x0A<<3),
    ADC_CH_MUXPOS_PIN11_gc = (0x0B<<3),
    ADC_CH_MUXPOS_PIN12_gc = (0x0C<<3),
    ADC_CH_MUXPOS_PIN13_gc = (0x0D<<3),
    ADC_CH_MUXPOS_PIN14_gc = (0x0E<<3),
    ADC_CH_MUXPOS_PIN15_gc = (0x0F<<3),
} ADC_CH_MUXPOS_t;


typedef enum ADC_CURRLIMIT_enum
{
    ADC_CURRLIMIT_NO_gc = (0x00<<5),
    ADC_CURRLIMIT_LOW_gc = (0x01<<5),
    ADC_CURRLIMIT_MED_gc = (0x02<<5),
    ADC_CURRLIMIT_HIGH_gc = (0x03<<5),
} ADC_CURRLIMIT_t;


typedef enum ADC_DMASEL_enum
{
    ADC_DMASEL_OFF_gc = (0x00<<6),
    ADC_DMASEL_CH01_gc = (0x01<<6),
    ADC_DMASEL_CH012_gc = (0x02<<6),
    ADC_DMASEL_CH0123_gc = (0x03<<6),
} ADC_DMASEL_t;


typedef enum ADC_EVACT_enum
{
    ADC_EVACT_NONE_gc = (0x00<<0),
    ADC_EVACT_CH0_gc = (0x01<<0),
    ADC_EVACT_CH01_gc = (0x02<<0),
    ADC_EVACT_CH012_gc = (0x03<<0),
    ADC_EVACT_CH0123_gc = (0x04<<0),
    ADC_EVACT_SWEEP_gc = (0x05<<0),
    ADC_EVACT_SYNCSWEEP_gc = (0x06<<0),
} ADC_EVACT_t;


typedef enum ADC_EVSEL_enum
{
    ADC_EVSEL_0123_gc = (0x00<<3),
    ADC_EVSEL_1234_gc = (0x01<<3),
    ADC_EVSEL_2345_gc = (0x02<<3),
    ADC_EVSEL_3456_gc = (0x03<<3),
    ADC_EVSEL_4567_gc = (0x04<<3),
    ADC_EVSEL_567_gc = (0x05<<3),
    ADC_EVSEL_67_gc = (0x06<<3),
    ADC_EVSEL_7_gc = (0x07<<3),
} ADC_EVSEL_t;


typedef enum ADC_PRESCALER_enum
{
    ADC_PRESCALER_DIV4_gc = (0x00<<0),
    ADC_PRESCALER_DIV8_gc = (0x01<<0),
    ADC_PRESCALER_DIV16_gc = (0x02<<0),
    ADC_PRESCALER_DIV32_gc = (0x03<<0),
    ADC_PRESCALER_DIV64_gc = (0x04<<0),
    ADC_PRESCALER_DIV128_gc = (0x05<<0),
    ADC_PRESCALER_DIV256_gc = (0x06<<0),
    ADC_PRESCALER_DIV512_gc = (0x07<<0),
} ADC_PRESCALER_t;


typedef enum ADC_REFSEL_enum
{
    ADC_REFSEL_INT1V_gc = (0x00<<4),
    ADC_REFSEL_INTVCC_gc = (0x01<<4),
    ADC_REFSEL_AREFA_gc = (0x02<<4),
    ADC_REFSEL_AREFB_gc = (0x03<<4),
    ADC_REFSEL_INTVCC2_gc = (0x04<<4),
} ADC_REFSEL_t;


typedef enum ADC_RESOLUTION_enum
{
    ADC_RESOLUTION_12BIT_gc = (0x00<<1),
    ADC_RESOLUTION_8BIT_gc = (0x02<<1),
    ADC_RESOLUTION_LEFT12BIT_gc = (0x03<<1),
} ADC_RESOLUTION_t;


typedef enum ADC_SWEEP_enum
{
    ADC_SWEEP_0_gc = (0x00<<6),
    ADC_SWEEP_01_gc = (0x01<<6),
    ADC_SWEEP_012_gc = (0x02<<6),
    ADC_SWEEP_0123_gc = (0x03<<6),
} ADC_SWEEP_t;
# 444 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct AES_struct
{
    register8_t CTRL;
    register8_t STATUS;
    register8_t STATE;
    register8_t KEY;
    register8_t INTCTRL;
} AES_t;


typedef enum AES_INTLVL_enum
{
    AES_INTLVL_OFF_gc = (0x00<<0),
    AES_INTLVL_LO_gc = (0x01<<0),
    AES_INTLVL_MED_gc = (0x02<<0),
    AES_INTLVL_HI_gc = (0x03<<0),
} AES_INTLVL_t;
# 469 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct AWEX_struct
{
    register8_t CTRL;
    register8_t reserved_1[1];
    register8_t FDEMASK;
    register8_t FDCTRL;
    register8_t STATUS;
    register8_t STATUSSET;
    register8_t DTBOTH;
    register8_t DTBOTHBUF;
    register8_t DTLS;
    register8_t DTHS;
    register8_t DTLSBUF;
    register8_t DTHSBUF;
    register8_t OUTOVEN;
} AWEX_t;


typedef enum AWEX_FDACT_enum
{
    AWEX_FDACT_NONE_gc = (0x00<<0),
    AWEX_FDACT_CLEAROE_gc = (0x01<<0),
    AWEX_FDACT_CLEARDIR_gc = (0x03<<0),
} AWEX_FDACT_t;
# 501 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct CLK_struct
{
    register8_t CTRL;
    register8_t PSCTRL;
    register8_t LOCK;
    register8_t RTCCTRL;
    register8_t USBCTRL;
} CLK_t;


typedef enum CLK_PSADIV_enum
{
    CLK_PSADIV_1_gc = (0x00<<2),
    CLK_PSADIV_2_gc = (0x01<<2),
    CLK_PSADIV_4_gc = (0x03<<2),
    CLK_PSADIV_8_gc = (0x05<<2),
    CLK_PSADIV_16_gc = (0x07<<2),
    CLK_PSADIV_32_gc = (0x09<<2),
    CLK_PSADIV_64_gc = (0x0B<<2),
    CLK_PSADIV_128_gc = (0x0D<<2),
    CLK_PSADIV_256_gc = (0x0F<<2),
    CLK_PSADIV_512_gc = (0x11<<2),
} CLK_PSADIV_t;


typedef enum CLK_PSBCDIV_enum
{
    CLK_PSBCDIV_1_1_gc = (0x00<<0),
    CLK_PSBCDIV_1_2_gc = (0x01<<0),
    CLK_PSBCDIV_4_1_gc = (0x02<<0),
    CLK_PSBCDIV_2_2_gc = (0x03<<0),
} CLK_PSBCDIV_t;


typedef enum CLK_RTCSRC_enum
{
    CLK_RTCSRC_ULP_gc = (0x00<<1),
    CLK_RTCSRC_TOSC_gc = (0x01<<1),
    CLK_RTCSRC_RCOSC_gc = (0x02<<1),
    CLK_RTCSRC_TOSC32_gc = (0x05<<1),
    CLK_RTCSRC_RCOSC32_gc = (0x06<<1),
    CLK_RTCSRC_EXTCLK_gc = (0x07<<1),
} CLK_RTCSRC_t;


typedef enum CLK_SCLKSEL_enum
{
    CLK_SCLKSEL_RC2M_gc = (0x00<<0),
    CLK_SCLKSEL_RC32M_gc = (0x01<<0),
    CLK_SCLKSEL_RC32K_gc = (0x02<<0),
    CLK_SCLKSEL_XOSC_gc = (0x03<<0),
    CLK_SCLKSEL_PLL_gc = (0x04<<0),
} CLK_SCLKSEL_t;


typedef enum CLK_USBPSDIV_enum
{
    CLK_USBPSDIV_1_gc = (0x00<<3),
    CLK_USBPSDIV_2_gc = (0x01<<3),
    CLK_USBPSDIV_4_gc = (0x02<<3),
    CLK_USBPSDIV_8_gc = (0x03<<3),
    CLK_USBPSDIV_16_gc = (0x04<<3),
    CLK_USBPSDIV_32_gc = (0x05<<3),
} CLK_USBPSDIV_t;


typedef enum CLK_USBSRC_enum
{
    CLK_USBSRC_PLL_gc = (0x00<<1),
    CLK_USBSRC_RC32M_gc = (0x01<<1),
} CLK_USBSRC_t;
# 580 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef enum CCP_enum
{
    CCP_SPM_gc = (0x9D<<0),
    CCP_IOREG_gc = (0xD8<<0),
} CCP_t;
# 593 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct CRC_struct
{
    register8_t CTRL;
    register8_t STATUS;
    register8_t reserved_1[1];
    register8_t DATAIN;
    register8_t CHECKSUM0;
    register8_t CHECKSUM1;
    register8_t CHECKSUM2;
    register8_t CHECKSUM3;
} CRC_t;


typedef enum CRC_RESET_enum
{
    CRC_RESET_NO_gc = (0x00<<6),
    CRC_RESET_RESET0_gc = (0x02<<6),
    CRC_RESET_RESET1_gc = (0x03<<6),
} CRC_RESET_t;


typedef enum CRC_SOURCE_enum
{
    CRC_SOURCE_DISABLE_gc = (0x00<<0),
    CRC_SOURCE_IO_gc = (0x01<<0),
    CRC_SOURCE_FLASH_gc = (0x02<<0),
    CRC_SOURCE_DMAC0_gc = (0x04<<0),
    CRC_SOURCE_DMAC1_gc = (0x05<<0),
    CRC_SOURCE_DMAC2_gc = (0x06<<0),
    CRC_SOURCE_DMAC3_gc = (0x07<<0),
} CRC_SOURCE_t;
# 632 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct DAC_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t CTRLC;
    register8_t EVCTRL;
    register8_t reserved_1[1];
    register8_t STATUS;
    register8_t reserved_2[2];
    register8_t CH0GAINCAL;
    register8_t CH0OFFSETCAL;
    register8_t CH1GAINCAL;
    register8_t CH1OFFSETCAL;
    register8_t reserved_3[12];
    __extension__ union { register16_t CH0DATA; struct { register8_t CH0DATAL; register8_t CH0DATAH; }; };
    __extension__ union { register16_t CH1DATA; struct { register8_t CH1DATAL; register8_t CH1DATAH; }; };
} DAC_t;


typedef enum DAC_CHSEL_enum
{
    DAC_CHSEL_SINGLE_gc = (0x00<<5),
    DAC_CHSEL_SINGLE1_gc = (0x01<<5),
    DAC_CHSEL_DUAL_gc = (0x02<<5),
} DAC_CHSEL_t;


typedef enum DAC_EVSEL_enum
{
    DAC_EVSEL_0_gc = (0x00<<0),
    DAC_EVSEL_1_gc = (0x01<<0),
    DAC_EVSEL_2_gc = (0x02<<0),
    DAC_EVSEL_3_gc = (0x03<<0),
    DAC_EVSEL_4_gc = (0x04<<0),
    DAC_EVSEL_5_gc = (0x05<<0),
    DAC_EVSEL_6_gc = (0x06<<0),
    DAC_EVSEL_7_gc = (0x07<<0),
} DAC_EVSEL_t;


typedef enum DAC_REFSEL_enum
{
    DAC_REFSEL_INT1V_gc = (0x00<<3),
    DAC_REFSEL_AVCC_gc = (0x01<<3),
    DAC_REFSEL_AREFA_gc = (0x02<<3),
    DAC_REFSEL_AREFB_gc = (0x03<<3),
} DAC_REFSEL_t;
# 687 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct DFLL_struct
{
    register8_t CTRL;
    register8_t reserved_1[1];
    register8_t CALA;
    register8_t CALB;
    register8_t COMP0;
    register8_t COMP1;
    register8_t COMP2;
    register8_t reserved_2[1];
} DFLL_t;
# 707 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct DMA_CH_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t ADDRCTRL;
    register8_t TRIGSRC;
    __extension__ union { register16_t TRFCNT; struct { register8_t TRFCNTL; register8_t TRFCNTH; }; };
    register8_t REPCNT;
    register8_t reserved_1[1];
    register8_t SRCADDR0;
    register8_t SRCADDR1;
    register8_t SRCADDR2;
    register8_t reserved_2[1];
    register8_t DESTADDR0;
    register8_t DESTADDR1;
    register8_t DESTADDR2;
    register8_t reserved_3[1];
} DMA_CH_t;



typedef struct DMA_struct
{
    register8_t CTRL;
    register8_t reserved_1[2];
    register8_t INTFLAGS;
    register8_t STATUS;
    register8_t reserved_2[1];
    __extension__ union { register16_t TEMP; struct { register8_t TEMPL; register8_t TEMPH; }; };
    register8_t reserved_3[8];
    DMA_CH_t CH0;
    DMA_CH_t CH1;
    DMA_CH_t CH2;
    DMA_CH_t CH3;
} DMA_t;


typedef enum DMA_CH_BURSTLEN_enum
{
    DMA_CH_BURSTLEN_1BYTE_gc = (0x00<<0),
    DMA_CH_BURSTLEN_2BYTE_gc = (0x01<<0),
    DMA_CH_BURSTLEN_4BYTE_gc = (0x02<<0),
    DMA_CH_BURSTLEN_8BYTE_gc = (0x03<<0),
} DMA_CH_BURSTLEN_t;


typedef enum DMA_CH_DESTDIR_enum
{
    DMA_CH_DESTDIR_FIXED_gc = (0x00<<0),
    DMA_CH_DESTDIR_INC_gc = (0x01<<0),
    DMA_CH_DESTDIR_DEC_gc = (0x02<<0),
} DMA_CH_DESTDIR_t;


typedef enum DMA_CH_DESTRELOAD_enum
{
    DMA_CH_DESTRELOAD_NONE_gc = (0x00<<2),
    DMA_CH_DESTRELOAD_BLOCK_gc = (0x01<<2),
    DMA_CH_DESTRELOAD_BURST_gc = (0x02<<2),
    DMA_CH_DESTRELOAD_TRANSACTION_gc = (0x03<<2),
} DMA_CH_DESTRELOAD_t;


typedef enum DMA_CH_ERRINTLVL_enum
{
    DMA_CH_ERRINTLVL_OFF_gc = (0x00<<2),
    DMA_CH_ERRINTLVL_LO_gc = (0x01<<2),
    DMA_CH_ERRINTLVL_MED_gc = (0x02<<2),
    DMA_CH_ERRINTLVL_HI_gc = (0x03<<2),
} DMA_CH_ERRINTLVL_t;


typedef enum DMA_CH_SRCDIR_enum
{
    DMA_CH_SRCDIR_FIXED_gc = (0x00<<4),
    DMA_CH_SRCDIR_INC_gc = (0x01<<4),
    DMA_CH_SRCDIR_DEC_gc = (0x02<<4),
} DMA_CH_SRCDIR_t;


typedef enum DMA_CH_SRCRELOAD_enum
{
    DMA_CH_SRCRELOAD_NONE_gc = (0x00<<6),
    DMA_CH_SRCRELOAD_BLOCK_gc = (0x01<<6),
    DMA_CH_SRCRELOAD_BURST_gc = (0x02<<6),
    DMA_CH_SRCRELOAD_TRANSACTION_gc = (0x03<<6),
} DMA_CH_SRCRELOAD_t;


typedef enum DMA_CH_TRIGSRC_enum
{
    DMA_CH_TRIGSRC_OFF_gc = (0x00<<0),
    DMA_CH_TRIGSRC_EVSYS_CH0_gc = (0x01<<0),
    DMA_CH_TRIGSRC_EVSYS_CH1_gc = (0x02<<0),
    DMA_CH_TRIGSRC_EVSYS_CH2_gc = (0x03<<0),
    DMA_CH_TRIGSRC_AES_gc = (0x04<<0),
    DMA_CH_TRIGSRC_ADCA_CH0_gc = (0x10<<0),
    DMA_CH_TRIGSRC_ADCA_CH1_gc = (0x11<<0),
    DMA_CH_TRIGSRC_ADCA_CH2_gc = (0x12<<0),
    DMA_CH_TRIGSRC_ADCA_CH3_gc = (0x13<<0),
    DMA_CH_TRIGSRC_ADCA_CH4_gc = (0x14<<0),
    DMA_CH_TRIGSRC_DACA_CH0_gc = (0x15<<0),
    DMA_CH_TRIGSRC_DACA_CH1_gc = (0x16<<0),
    DMA_CH_TRIGSRC_ADCB_CH0_gc = (0x20<<0),
    DMA_CH_TRIGSRC_ADCB_CH1_gc = (0x21<<0),
    DMA_CH_TRIGSRC_ADCB_CH2_gc = (0x22<<0),
    DMA_CH_TRIGSRC_ADCB_CH3_gc = (0x23<<0),
    DMA_CH_TRIGSRC_ADCB_CH4_gc = (0x24<<0),
    DMA_CH_TRIGSRC_DACB_CH0_gc = (0x25<<0),
    DMA_CH_TRIGSRC_DACB_CH1_gc = (0x26<<0),
    DMA_CH_TRIGSRC_TCC0_OVF_gc = (0x40<<0),
    DMA_CH_TRIGSRC_TCC0_ERR_gc = (0x41<<0),
    DMA_CH_TRIGSRC_TCC0_CCA_gc = (0x42<<0),
    DMA_CH_TRIGSRC_TCC0_CCB_gc = (0x43<<0),
    DMA_CH_TRIGSRC_TCC0_CCC_gc = (0x44<<0),
    DMA_CH_TRIGSRC_TCC0_CCD_gc = (0x45<<0),
    DMA_CH_TRIGSRC_TCC1_OVF_gc = (0x46<<0),
    DMA_CH_TRIGSRC_TCC1_ERR_gc = (0x47<<0),
    DMA_CH_TRIGSRC_TCC1_CCA_gc = (0x48<<0),
    DMA_CH_TRIGSRC_TCC1_CCB_gc = (0x49<<0),
    DMA_CH_TRIGSRC_SPIC_gc = (0x4A<<0),
    DMA_CH_TRIGSRC_USARTC0_RXC_gc = (0x4B<<0),
    DMA_CH_TRIGSRC_USARTC0_DRE_gc = (0x4C<<0),
    DMA_CH_TRIGSRC_USARTC1_RXC_gc = (0x4E<<0),
    DMA_CH_TRIGSRC_USARTC1_DRE_gc = (0x4F<<0),
    DMA_CH_TRIGSRC_TCD0_OVF_gc = (0x60<<0),
    DMA_CH_TRIGSRC_TCD0_ERR_gc = (0x61<<0),
    DMA_CH_TRIGSRC_TCD0_CCA_gc = (0x62<<0),
    DMA_CH_TRIGSRC_TCD0_CCB_gc = (0x63<<0),
    DMA_CH_TRIGSRC_TCD0_CCC_gc = (0x64<<0),
    DMA_CH_TRIGSRC_TCD0_CCD_gc = (0x65<<0),
    DMA_CH_TRIGSRC_TCD1_OVF_gc = (0x66<<0),
    DMA_CH_TRIGSRC_TCD1_ERR_gc = (0x67<<0),
    DMA_CH_TRIGSRC_TCD1_CCA_gc = (0x68<<0),
    DMA_CH_TRIGSRC_TCD1_CCB_gc = (0x69<<0),
    DMA_CH_TRIGSRC_SPID_gc = (0x6A<<0),
    DMA_CH_TRIGSRC_USARTD0_RXC_gc = (0x6B<<0),
    DMA_CH_TRIGSRC_USARTD0_DRE_gc = (0x6C<<0),
    DMA_CH_TRIGSRC_USARTD1_RXC_gc = (0x6E<<0),
    DMA_CH_TRIGSRC_USARTD1_DRE_gc = (0x6F<<0),
    DMA_CH_TRIGSRC_TCE0_OVF_gc = (0x80<<0),
    DMA_CH_TRIGSRC_TCE0_ERR_gc = (0x81<<0),
    DMA_CH_TRIGSRC_TCE0_CCA_gc = (0x82<<0),
    DMA_CH_TRIGSRC_TCE0_CCB_gc = (0x83<<0),
    DMA_CH_TRIGSRC_TCE0_CCC_gc = (0x84<<0),
    DMA_CH_TRIGSRC_TCE0_CCD_gc = (0x85<<0),
    DMA_CH_TRIGSRC_TCE1_OVF_gc = (0x86<<0),
    DMA_CH_TRIGSRC_TCE1_ERR_gc = (0x87<<0),
    DMA_CH_TRIGSRC_TCE1_CCA_gc = (0x88<<0),
    DMA_CH_TRIGSRC_TCE1_CCB_gc = (0x89<<0),
    DMA_CH_TRIGSRC_SPIE_gc = (0x8A<<0),
    DMA_CH_TRIGSRC_USARTE0_RXC_gc = (0x8B<<0),
    DMA_CH_TRIGSRC_USARTE0_DRE_gc = (0x8C<<0),
    DMA_CH_TRIGSRC_USARTE1_RXC_gc = (0x8E<<0),
    DMA_CH_TRIGSRC_USARTE1_DRE_gc = (0x8F<<0),
    DMA_CH_TRIGSRC_TCF0_OVF_gc = (0xA0<<0),
    DMA_CH_TRIGSRC_TCF0_ERR_gc = (0xA1<<0),
    DMA_CH_TRIGSRC_TCF0_CCA_gc = (0xA2<<0),
    DMA_CH_TRIGSRC_TCF0_CCB_gc = (0xA3<<0),
    DMA_CH_TRIGSRC_TCF0_CCC_gc = (0xA4<<0),
    DMA_CH_TRIGSRC_TCF0_CCD_gc = (0xA5<<0),
    DMA_CH_TRIGSRC_TCF1_OVF_gc = (0xA6<<0),
    DMA_CH_TRIGSRC_TCF1_ERR_gc = (0xA7<<0),
    DMA_CH_TRIGSRC_TCF1_CCA_gc = (0xA8<<0),
    DMA_CH_TRIGSRC_TCF1_CCB_gc = (0xA9<<0),
    DMA_CH_TRIGSRC_SPIF_gc = (0xAA<<0),
    DMA_CH_TRIGSRC_USARTF0_RXC_gc = (0xAB<<0),
    DMA_CH_TRIGSRC_USARTF0_DRE_gc = (0xAC<<0),
    DMA_CH_TRIGSRC_USARTF1_RXC_gc = (0xAE<<0),
    DMA_CH_TRIGSRC_USARTF1_DRE_gc = (0xAF<<0),
} DMA_CH_TRIGSRC_t;


typedef enum DMA_CH_TRNINTLVL_enum
{
    DMA_CH_TRNINTLVL_OFF_gc = (0x00<<0),
    DMA_CH_TRNINTLVL_LO_gc = (0x01<<0),
    DMA_CH_TRNINTLVL_MED_gc = (0x02<<0),
    DMA_CH_TRNINTLVL_HI_gc = (0x03<<0),
} DMA_CH_TRNINTLVL_t;


typedef enum DMA_DBUFMODE_enum
{
    DMA_DBUFMODE_DISABLED_gc = (0x00<<2),
    DMA_DBUFMODE_CH01_gc = (0x01<<2),
    DMA_DBUFMODE_CH23_gc = (0x02<<2),
    DMA_DBUFMODE_CH01CH23_gc = (0x03<<2),
} DMA_DBUFMODE_t;


typedef enum DMA_PRIMODE_enum
{
    DMA_PRIMODE_RR0123_gc = (0x00<<0),
    DMA_PRIMODE_CH0RR123_gc = (0x01<<0),
    DMA_PRIMODE_CH01RR23_gc = (0x02<<0),
    DMA_PRIMODE_CH0123_gc = (0x03<<0),
} DMA_PRIMODE_t;
# 913 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct EVSYS_struct
{
    register8_t CH0MUX;
    register8_t CH1MUX;
    register8_t CH2MUX;
    register8_t CH3MUX;
    register8_t CH4MUX;
    register8_t CH5MUX;
    register8_t CH6MUX;
    register8_t CH7MUX;
    register8_t CH0CTRL;
    register8_t CH1CTRL;
    register8_t CH2CTRL;
    register8_t CH3CTRL;
    register8_t CH4CTRL;
    register8_t CH5CTRL;
    register8_t CH6CTRL;
    register8_t CH7CTRL;
    register8_t STROBE;
    register8_t DATA;
} EVSYS_t;


typedef enum EVSYS_CHMUX_enum
{
    EVSYS_CHMUX_OFF_gc = (0x00<<0),
    EVSYS_CHMUX_RTC_OVF_gc = (0x08<<0),
    EVSYS_CHMUX_RTC_CMP_gc = (0x09<<0),
    EVSYS_CHMUX_USB_gc = (0x0A<<0),
    EVSYS_CHMUX_ACA_CH0_gc = (0x10<<0),
    EVSYS_CHMUX_ACA_CH1_gc = (0x11<<0),
    EVSYS_CHMUX_ACA_WIN_gc = (0x12<<0),
    EVSYS_CHMUX_ACB_CH0_gc = (0x13<<0),
    EVSYS_CHMUX_ACB_CH1_gc = (0x14<<0),
    EVSYS_CHMUX_ACB_WIN_gc = (0x15<<0),
    EVSYS_CHMUX_ADCA_CH0_gc = (0x20<<0),
    EVSYS_CHMUX_ADCA_CH1_gc = (0x21<<0),
    EVSYS_CHMUX_ADCA_CH2_gc = (0x22<<0),
    EVSYS_CHMUX_ADCA_CH3_gc = (0x23<<0),
    EVSYS_CHMUX_ADCB_CH0_gc = (0x24<<0),
    EVSYS_CHMUX_ADCB_CH1_gc = (0x25<<0),
    EVSYS_CHMUX_ADCB_CH2_gc = (0x26<<0),
    EVSYS_CHMUX_ADCB_CH3_gc = (0x27<<0),
    EVSYS_CHMUX_PORTA_PIN0_gc = (0x50<<0),
    EVSYS_CHMUX_PORTA_PIN1_gc = (0x51<<0),
    EVSYS_CHMUX_PORTA_PIN2_gc = (0x52<<0),
    EVSYS_CHMUX_PORTA_PIN3_gc = (0x53<<0),
    EVSYS_CHMUX_PORTA_PIN4_gc = (0x54<<0),
    EVSYS_CHMUX_PORTA_PIN5_gc = (0x55<<0),
    EVSYS_CHMUX_PORTA_PIN6_gc = (0x56<<0),
    EVSYS_CHMUX_PORTA_PIN7_gc = (0x57<<0),
    EVSYS_CHMUX_PORTB_PIN0_gc = (0x58<<0),
    EVSYS_CHMUX_PORTB_PIN1_gc = (0x59<<0),
    EVSYS_CHMUX_PORTB_PIN2_gc = (0x5A<<0),
    EVSYS_CHMUX_PORTB_PIN3_gc = (0x5B<<0),
    EVSYS_CHMUX_PORTB_PIN4_gc = (0x5C<<0),
    EVSYS_CHMUX_PORTB_PIN5_gc = (0x5D<<0),
    EVSYS_CHMUX_PORTB_PIN6_gc = (0x5E<<0),
    EVSYS_CHMUX_PORTB_PIN7_gc = (0x5F<<0),
    EVSYS_CHMUX_PORTC_PIN0_gc = (0x60<<0),
    EVSYS_CHMUX_PORTC_PIN1_gc = (0x61<<0),
    EVSYS_CHMUX_PORTC_PIN2_gc = (0x62<<0),
    EVSYS_CHMUX_PORTC_PIN3_gc = (0x63<<0),
    EVSYS_CHMUX_PORTC_PIN4_gc = (0x64<<0),
    EVSYS_CHMUX_PORTC_PIN5_gc = (0x65<<0),
    EVSYS_CHMUX_PORTC_PIN6_gc = (0x66<<0),
    EVSYS_CHMUX_PORTC_PIN7_gc = (0x67<<0),
    EVSYS_CHMUX_PORTD_PIN0_gc = (0x68<<0),
    EVSYS_CHMUX_PORTD_PIN1_gc = (0x69<<0),
    EVSYS_CHMUX_PORTD_PIN2_gc = (0x6A<<0),
    EVSYS_CHMUX_PORTD_PIN3_gc = (0x6B<<0),
    EVSYS_CHMUX_PORTD_PIN4_gc = (0x6C<<0),
    EVSYS_CHMUX_PORTD_PIN5_gc = (0x6D<<0),
    EVSYS_CHMUX_PORTD_PIN6_gc = (0x6E<<0),
    EVSYS_CHMUX_PORTD_PIN7_gc = (0x6F<<0),
    EVSYS_CHMUX_PORTE_PIN0_gc = (0x70<<0),
    EVSYS_CHMUX_PORTE_PIN1_gc = (0x71<<0),
    EVSYS_CHMUX_PORTE_PIN2_gc = (0x72<<0),
    EVSYS_CHMUX_PORTE_PIN3_gc = (0x73<<0),
    EVSYS_CHMUX_PORTE_PIN4_gc = (0x74<<0),
    EVSYS_CHMUX_PORTE_PIN5_gc = (0x75<<0),
    EVSYS_CHMUX_PORTE_PIN6_gc = (0x76<<0),
    EVSYS_CHMUX_PORTE_PIN7_gc = (0x77<<0),
    EVSYS_CHMUX_PORTF_PIN0_gc = (0x78<<0),
    EVSYS_CHMUX_PORTF_PIN1_gc = (0x79<<0),
    EVSYS_CHMUX_PORTF_PIN2_gc = (0x7A<<0),
    EVSYS_CHMUX_PORTF_PIN3_gc = (0x7B<<0),
    EVSYS_CHMUX_PORTF_PIN4_gc = (0x7C<<0),
    EVSYS_CHMUX_PORTF_PIN5_gc = (0x7D<<0),
    EVSYS_CHMUX_PORTF_PIN6_gc = (0x7E<<0),
    EVSYS_CHMUX_PORTF_PIN7_gc = (0x7F<<0),
    EVSYS_CHMUX_PRESCALER_1_gc = (0x80<<0),
    EVSYS_CHMUX_PRESCALER_2_gc = (0x81<<0),
    EVSYS_CHMUX_PRESCALER_4_gc = (0x82<<0),
    EVSYS_CHMUX_PRESCALER_8_gc = (0x83<<0),
    EVSYS_CHMUX_PRESCALER_16_gc = (0x84<<0),
    EVSYS_CHMUX_PRESCALER_32_gc = (0x85<<0),
    EVSYS_CHMUX_PRESCALER_64_gc = (0x86<<0),
    EVSYS_CHMUX_PRESCALER_128_gc = (0x87<<0),
    EVSYS_CHMUX_PRESCALER_256_gc = (0x88<<0),
    EVSYS_CHMUX_PRESCALER_512_gc = (0x89<<0),
    EVSYS_CHMUX_PRESCALER_1024_gc = (0x8A<<0),
    EVSYS_CHMUX_PRESCALER_2048_gc = (0x8B<<0),
    EVSYS_CHMUX_PRESCALER_4096_gc = (0x8C<<0),
    EVSYS_CHMUX_PRESCALER_8192_gc = (0x8D<<0),
    EVSYS_CHMUX_PRESCALER_16384_gc = (0x8E<<0),
    EVSYS_CHMUX_PRESCALER_32768_gc = (0x8F<<0),
    EVSYS_CHMUX_TCC0_OVF_gc = (0xC0<<0),
    EVSYS_CHMUX_TCC0_ERR_gc = (0xC1<<0),
    EVSYS_CHMUX_TCC0_CCA_gc = (0xC4<<0),
    EVSYS_CHMUX_TCC0_CCB_gc = (0xC5<<0),
    EVSYS_CHMUX_TCC0_CCC_gc = (0xC6<<0),
    EVSYS_CHMUX_TCC0_CCD_gc = (0xC7<<0),
    EVSYS_CHMUX_TCC1_OVF_gc = (0xC8<<0),
    EVSYS_CHMUX_TCC1_ERR_gc = (0xC9<<0),
    EVSYS_CHMUX_TCC1_CCA_gc = (0xCC<<0),
    EVSYS_CHMUX_TCC1_CCB_gc = (0xCD<<0),
    EVSYS_CHMUX_TCD0_OVF_gc = (0xD0<<0),
    EVSYS_CHMUX_TCD0_ERR_gc = (0xD1<<0),
    EVSYS_CHMUX_TCD0_CCA_gc = (0xD4<<0),
    EVSYS_CHMUX_TCD0_CCB_gc = (0xD5<<0),
    EVSYS_CHMUX_TCD0_CCC_gc = (0xD6<<0),
    EVSYS_CHMUX_TCD0_CCD_gc = (0xD7<<0),
    EVSYS_CHMUX_TCD1_OVF_gc = (0xD8<<0),
    EVSYS_CHMUX_TCD1_ERR_gc = (0xD9<<0),
    EVSYS_CHMUX_TCD1_CCA_gc = (0xDC<<0),
    EVSYS_CHMUX_TCD1_CCB_gc = (0xDD<<0),
    EVSYS_CHMUX_TCE0_OVF_gc = (0xE0<<0),
    EVSYS_CHMUX_TCE0_ERR_gc = (0xE1<<0),
    EVSYS_CHMUX_TCE0_CCA_gc = (0xE4<<0),
    EVSYS_CHMUX_TCE0_CCB_gc = (0xE5<<0),
    EVSYS_CHMUX_TCE0_CCC_gc = (0xE6<<0),
    EVSYS_CHMUX_TCE0_CCD_gc = (0xE7<<0),
    EVSYS_CHMUX_TCE1_OVF_gc = (0xE8<<0),
    EVSYS_CHMUX_TCE1_ERR_gc = (0xE9<<0),
    EVSYS_CHMUX_TCE1_CCA_gc = (0xEC<<0),
    EVSYS_CHMUX_TCE1_CCB_gc = (0xED<<0),
    EVSYS_CHMUX_TCF0_OVF_gc = (0xF0<<0),
    EVSYS_CHMUX_TCF0_ERR_gc = (0xF1<<0),
    EVSYS_CHMUX_TCF0_CCA_gc = (0xF4<<0),
    EVSYS_CHMUX_TCF0_CCB_gc = (0xF5<<0),
    EVSYS_CHMUX_TCF0_CCC_gc = (0xF6<<0),
    EVSYS_CHMUX_TCF0_CCD_gc = (0xF7<<0),
    EVSYS_CHMUX_TCF1_OVF_gc = (0xF8<<0),
    EVSYS_CHMUX_TCF1_ERR_gc = (0xF9<<0),
    EVSYS_CHMUX_TCF1_CCA_gc = (0xFC<<0),
    EVSYS_CHMUX_TCF1_CCB_gc = (0xFD<<0),
} EVSYS_CHMUX_t;


typedef enum EVSYS_DIGFILT_enum
{
    EVSYS_DIGFILT_1SAMPLE_gc = (0x00<<0),
    EVSYS_DIGFILT_2SAMPLES_gc = (0x01<<0),
    EVSYS_DIGFILT_3SAMPLES_gc = (0x02<<0),
    EVSYS_DIGFILT_4SAMPLES_gc = (0x03<<0),
    EVSYS_DIGFILT_5SAMPLES_gc = (0x04<<0),
    EVSYS_DIGFILT_6SAMPLES_gc = (0x05<<0),
    EVSYS_DIGFILT_7SAMPLES_gc = (0x06<<0),
    EVSYS_DIGFILT_8SAMPLES_gc = (0x07<<0),
} EVSYS_DIGFILT_t;


typedef enum EVSYS_QDIRM_enum
{
    EVSYS_QDIRM_00_gc = (0x00<<5),
    EVSYS_QDIRM_01_gc = (0x01<<5),
    EVSYS_QDIRM_10_gc = (0x02<<5),
    EVSYS_QDIRM_11_gc = (0x03<<5),
} EVSYS_QDIRM_t;
# 1091 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct NVM_FUSES_struct
{
    register8_t FUSEBYTE0;
    register8_t FUSEBYTE1;
    register8_t FUSEBYTE2;
    register8_t reserved_1[1];
    register8_t FUSEBYTE4;
    register8_t FUSEBYTE5;
} NVM_FUSES_t;


typedef enum BODACT_enum
{
    BODACT_SAMPLED_gc = (0x01<<4),
    BODACT_CONTINUOUS_gc = (0x02<<4),
    BODACT_DISABLED_gc = (0x03<<4),
} BODACT_t;


typedef enum BODLEVEL_enum
{
    BODLEVEL_3V0_gc = (0x00<<0),
    BODLEVEL_2V8_gc = (0x01<<0),
    BODLEVEL_2V6_gc = (0x02<<0),
    BODLEVEL_2V4_gc = (0x03<<0),
    BODLEVEL_2V2_gc = (0x04<<0),
    BODLEVEL_2V0_gc = (0x05<<0),
    BODLEVEL_1V8_gc = (0x06<<0),
    BODLEVEL_1V6_gc = (0x07<<0),
} BODLEVEL_t;


typedef enum BODPD_enum
{
    BODPD_SAMPLED_gc = (0x01<<0),
    BODPD_CONTINUOUS_gc = (0x02<<0),
    BODPD_DISABLED_gc = (0x03<<0),
} BODPD_t;


typedef enum BOOTRST_enum
{
    BOOTRST_BOOTLDR_gc = (0x00<<6),
    BOOTRST_APPLICATION_gc = (0x01<<6),
} BOOTRST_t;


typedef enum STARTUPTIME_enum
{
    STARTUPTIME_64MS_gc = (0x00<<2),
    STARTUPTIME_4MS_gc = (0x01<<2),
    STARTUPTIME_0MS_gc = (0x03<<2),
} STARTUPTIME_t;


typedef enum TOSCSEL_enum
{
    TOSCSEL_ALTERNATE_gc = (0x00<<5),
    TOSCSEL_XTAL_gc = (0x01<<5),
} TOSCSEL_t;


typedef enum WDPER_enum
{
    WDPER_8CLK_gc = (0x00<<0),
    WDPER_16CLK_gc = (0x01<<0),
    WDPER_32CLK_gc = (0x02<<0),
    WDPER_64CLK_gc = (0x03<<0),
    WDPER_128CLK_gc = (0x04<<0),
    WDPER_256CLK_gc = (0x05<<0),
    WDPER_512CLK_gc = (0x06<<0),
    WDPER_1KCLK_gc = (0x07<<0),
    WDPER_2KCLK_gc = (0x08<<0),
    WDPER_4KCLK_gc = (0x09<<0),
    WDPER_8KCLK_gc = (0x0A<<0),
} WDPER_t;


typedef enum WDWPER_enum
{
    WDWPER_8CLK_gc = (0x00<<4),
    WDWPER_16CLK_gc = (0x01<<4),
    WDWPER_32CLK_gc = (0x02<<4),
    WDWPER_64CLK_gc = (0x03<<4),
    WDWPER_128CLK_gc = (0x04<<4),
    WDWPER_256CLK_gc = (0x05<<4),
    WDWPER_512CLK_gc = (0x06<<4),
    WDWPER_1KCLK_gc = (0x07<<4),
    WDWPER_2KCLK_gc = (0x08<<4),
    WDWPER_4KCLK_gc = (0x09<<4),
    WDWPER_8KCLK_gc = (0x0A<<4),
} WDWPER_t;
# 1191 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct HIRES_struct
{
    register8_t CTRLA;
} HIRES_t;


typedef enum HIRES_HREN_enum
{
    HIRES_HREN_NONE_gc = (0x00<<0),
    HIRES_HREN_TC0_gc = (0x01<<0),
    HIRES_HREN_TC1_gc = (0x02<<0),
    HIRES_HREN_BOTH_gc = (0x03<<0),
} HIRES_HREN_t;
# 1212 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct IRCOM_struct
{
    register8_t CTRL;
    register8_t TXPLCTRL;
    register8_t RXPLCTRL;
} IRCOM_t;


typedef enum IRCOM_EVSEL_enum
{
    IRCOM_EVSEL_OFF_gc = (0x00<<0),
    IRCOM_EVSEL_0_gc = (0x08<<0),
    IRCOM_EVSEL_1_gc = (0x09<<0),
    IRCOM_EVSEL_2_gc = (0x0A<<0),
    IRCOM_EVSEL_3_gc = (0x0B<<0),
    IRCOM_EVSEL_4_gc = (0x0C<<0),
    IRCOM_EVSEL_5_gc = (0x0D<<0),
    IRCOM_EVSEL_6_gc = (0x0E<<0),
    IRCOM_EVSEL_7_gc = (0x0F<<0),
} IRCOM_EVSEL_t;
# 1240 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct NVM_LOCKBITS_struct
{
    register8_t LOCK_BITS;
} NVM_LOCKBITS_t;


typedef enum BLBA_enum
{
    BLBA_RWLOCK_gc = (0x00<<4),
    BLBA_RLOCK_gc = (0x01<<4),
    BLBA_WLOCK_gc = (0x02<<4),
    BLBA_NOLOCK_gc = (0x03<<4),
} BLBA_t;


typedef enum BLBAT_enum
{
    BLBAT_RWLOCK_gc = (0x00<<2),
    BLBAT_RLOCK_gc = (0x01<<2),
    BLBAT_WLOCK_gc = (0x02<<2),
    BLBAT_NOLOCK_gc = (0x03<<2),
} BLBAT_t;


typedef enum BLBB_enum
{
    BLBB_RWLOCK_gc = (0x00<<6),
    BLBB_RLOCK_gc = (0x01<<6),
    BLBB_WLOCK_gc = (0x02<<6),
    BLBB_NOLOCK_gc = (0x03<<6),
} BLBB_t;


typedef enum LB_enum
{
    LB_RWLOCK_gc = (0x00<<0),
    LB_WLOCK_gc = (0x02<<0),
    LB_NOLOCK_gc = (0x03<<0),
} LB_t;
# 1287 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct MCU_struct
{
    register8_t DEVID0;
    register8_t DEVID1;
    register8_t DEVID2;
    register8_t REVID;
    register8_t JTAGUID;
    register8_t reserved_1[1];
    register8_t MCUCR;
    register8_t ANAINIT;
    register8_t EVSYSLOCK;
    register8_t AWEXLOCK;
    register8_t reserved_2[2];
} MCU_t;
# 1310 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct NVM_struct
{
    register8_t ADDR0;
    register8_t ADDR1;
    register8_t ADDR2;
    register8_t reserved_1[1];
    register8_t DATA0;
    register8_t DATA1;
    register8_t DATA2;
    register8_t reserved_2[3];
    register8_t CMD;
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t INTCTRL;
    register8_t reserved_3[1];
    register8_t STATUS;
    register8_t LOCK_BITS;
} NVM_t;


typedef enum NVM_BLBA_enum
{
    NVM_BLBA_RWLOCK_gc = (0x00<<4),
    NVM_BLBA_RLOCK_gc = (0x01<<4),
    NVM_BLBA_WLOCK_gc = (0x02<<4),
    NVM_BLBA_NOLOCK_gc = (0x03<<4),
} NVM_BLBA_t;


typedef enum NVM_BLBAT_enum
{
    NVM_BLBAT_RWLOCK_gc = (0x00<<2),
    NVM_BLBAT_RLOCK_gc = (0x01<<2),
    NVM_BLBAT_WLOCK_gc = (0x02<<2),
    NVM_BLBAT_NOLOCK_gc = (0x03<<2),
} NVM_BLBAT_t;


typedef enum NVM_BLBB_enum
{
    NVM_BLBB_RWLOCK_gc = (0x00<<6),
    NVM_BLBB_RLOCK_gc = (0x01<<6),
    NVM_BLBB_WLOCK_gc = (0x02<<6),
    NVM_BLBB_NOLOCK_gc = (0x03<<6),
} NVM_BLBB_t;


typedef enum NVM_CMD_enum
{
    NVM_CMD_NO_OPERATION_gc = (0x00<<0),
    NVM_CMD_READ_USER_SIG_ROW_gc = (0x01<<0),
    NVM_CMD_READ_CALIB_ROW_gc = (0x02<<0),
    NVM_CMD_READ_EEPROM_gc = (0x06<<0),
    NVM_CMD_READ_FUSES_gc = (0x07<<0),
    NVM_CMD_WRITE_LOCK_BITS_gc = (0x08<<0),
    NVM_CMD_ERASE_USER_SIG_ROW_gc = (0x18<<0),
    NVM_CMD_WRITE_USER_SIG_ROW_gc = (0x1A<<0),
    NVM_CMD_ERASE_APP_gc = (0x20<<0),
    NVM_CMD_ERASE_APP_PAGE_gc = (0x22<<0),
    NVM_CMD_LOAD_FLASH_BUFFER_gc = (0x23<<0),
    NVM_CMD_WRITE_APP_PAGE_gc = (0x24<<0),
    NVM_CMD_ERASE_WRITE_APP_PAGE_gc = (0x25<<0),
    NVM_CMD_ERASE_FLASH_BUFFER_gc = (0x26<<0),
    NVM_CMD_ERASE_BOOT_PAGE_gc = (0x2A<<0),
    NVM_CMD_ERASE_FLASH_PAGE_gc = (0x2B<<0),
    NVM_CMD_WRITE_BOOT_PAGE_gc = (0x2C<<0),
    NVM_CMD_ERASE_WRITE_BOOT_PAGE_gc = (0x2D<<0),
    NVM_CMD_WRITE_FLASH_PAGE_gc = (0x2E<<0),
    NVM_CMD_ERASE_WRITE_FLASH_PAGE_gc = (0x2F<<0),
    NVM_CMD_ERASE_EEPROM_gc = (0x30<<0),
    NVM_CMD_ERASE_EEPROM_PAGE_gc = (0x32<<0),
    NVM_CMD_LOAD_EEPROM_BUFFER_gc = (0x33<<0),
    NVM_CMD_WRITE_EEPROM_PAGE_gc = (0x34<<0),
    NVM_CMD_ERASE_WRITE_EEPROM_PAGE_gc = (0x35<<0),
    NVM_CMD_ERASE_EEPROM_BUFFER_gc = (0x36<<0),
    NVM_CMD_APP_CRC_gc = (0x38<<0),
    NVM_CMD_BOOT_CRC_gc = (0x39<<0),
    NVM_CMD_FLASH_RANGE_CRC_gc = (0x3A<<0),
    NVM_CMD_CHIP_ERASE_gc = (0x40<<0),
    NVM_CMD_READ_NVM_gc = (0x43<<0),
    NVM_CMD_WRITE_FUSE_gc = (0x4C<<0),
    NVM_CMD_ERASE_BOOT_gc = (0x68<<0),
    NVM_CMD_FLASH_CRC_gc = (0x78<<0),
} NVM_CMD_t;


typedef enum NVM_EELVL_enum
{
    NVM_EELVL_OFF_gc = (0x00<<0),
    NVM_EELVL_LO_gc = (0x01<<0),
    NVM_EELVL_MED_gc = (0x02<<0),
    NVM_EELVL_HI_gc = (0x03<<0),
} NVM_EELVL_t;


typedef enum NVM_LB_enum
{
    NVM_LB_RWLOCK_gc = (0x00<<0),
    NVM_LB_WLOCK_gc = (0x02<<0),
    NVM_LB_NOLOCK_gc = (0x03<<0),
} NVM_LB_t;


typedef enum NVM_SPMLVL_enum
{
    NVM_SPMLVL_OFF_gc = (0x00<<2),
    NVM_SPMLVL_LO_gc = (0x01<<2),
    NVM_SPMLVL_MED_gc = (0x02<<2),
    NVM_SPMLVL_HI_gc = (0x03<<2),
} NVM_SPMLVL_t;
# 1428 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct OSC_struct
{
    register8_t CTRL;
    register8_t STATUS;
    register8_t XOSCCTRL;
    register8_t XOSCFAIL;
    register8_t RC32KCAL;
    register8_t PLLCTRL;
    register8_t DFLLCTRL;
} OSC_t;


typedef enum OSC_FRQRANGE_enum
{
    OSC_FRQRANGE_04TO2_gc = (0x00<<6),
    OSC_FRQRANGE_2TO9_gc = (0x01<<6),
    OSC_FRQRANGE_9TO12_gc = (0x02<<6),
    OSC_FRQRANGE_12TO16_gc = (0x03<<6),
} OSC_FRQRANGE_t;


typedef enum OSC_PLLSRC_enum
{
    OSC_PLLSRC_RC2M_gc = (0x00<<6),
    OSC_PLLSRC_RC32M_gc = (0x02<<6),
    OSC_PLLSRC_XOSC_gc = (0x03<<6),
} OSC_PLLSRC_t;


typedef enum OSC_RC2MCREF_enum
{
    OSC_RC2MCREF_RC32K_gc = (0x00<<0),
    OSC_RC2MCREF_XOSC32K_gc = (0x01<<0),
} OSC_RC2MCREF_t;


typedef enum OSC_RC32MCREF_enum
{
    OSC_RC32MCREF_RC32K_gc = (0x00<<1),
    OSC_RC32MCREF_XOSC32K_gc = (0x01<<1),
    OSC_RC32MCREF_USBSOF_gc = (0x02<<1),
} OSC_RC32MCREF_t;


typedef enum OSC_XOSCSEL_enum
{
    OSC_XOSCSEL_EXTCLK_gc = (0x00<<0),
    OSC_XOSCSEL_32KHz_gc = (0x02<<0),
    OSC_XOSCSEL_XTAL_256CLK_gc = (0x03<<0),
    OSC_XOSCSEL_XTAL_1KCLK_gc = (0x07<<0),
    OSC_XOSCSEL_XTAL_16KCLK_gc = (0x0B<<0),
} OSC_XOSCSEL_t;
# 1488 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct PMIC_struct
{
    register8_t STATUS;
    register8_t INTPRI;
    register8_t CTRL;
    register8_t reserved_1[13];
} PMIC_t;
# 1504 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct PORT_struct
{
    register8_t DIR;
    register8_t DIRSET;
    register8_t DIRCLR;
    register8_t DIRTGL;
    register8_t OUT;
    register8_t OUTSET;
    register8_t OUTCLR;
    register8_t OUTTGL;
    register8_t IN;
    register8_t INTCTRL;
    register8_t INT0MASK;
    register8_t INT1MASK;
    register8_t INTFLAGS;
    register8_t reserved_1[1];
    register8_t REMAP;
    register8_t reserved_2[1];
    register8_t PIN0CTRL;
    register8_t PIN1CTRL;
    register8_t PIN2CTRL;
    register8_t PIN3CTRL;
    register8_t PIN4CTRL;
    register8_t PIN5CTRL;
    register8_t PIN6CTRL;
    register8_t PIN7CTRL;
} PORT_t;


typedef enum PORT_INT0LVL_enum
{
    PORT_INT0LVL_OFF_gc = (0x00<<0),
    PORT_INT0LVL_LO_gc = (0x01<<0),
    PORT_INT0LVL_MED_gc = (0x02<<0),
    PORT_INT0LVL_HI_gc = (0x03<<0),
} PORT_INT0LVL_t;


typedef enum PORT_INT1LVL_enum
{
    PORT_INT1LVL_OFF_gc = (0x00<<2),
    PORT_INT1LVL_LO_gc = (0x01<<2),
    PORT_INT1LVL_MED_gc = (0x02<<2),
    PORT_INT1LVL_HI_gc = (0x03<<2),
} PORT_INT1LVL_t;


typedef enum PORT_ISC_enum
{
    PORT_ISC_BOTHEDGES_gc = (0x00<<0),
    PORT_ISC_RISING_gc = (0x01<<0),
    PORT_ISC_FALLING_gc = (0x02<<0),
    PORT_ISC_LEVEL_gc = (0x03<<0),
    PORT_ISC_INPUT_DISABLE_gc = (0x07<<0),
} PORT_ISC_t;


typedef enum PORT_OPC_enum
{
    PORT_OPC_TOTEM_gc = (0x00<<3),
    PORT_OPC_BUSKEEPER_gc = (0x01<<3),
    PORT_OPC_PULLDOWN_gc = (0x02<<3),
    PORT_OPC_PULLUP_gc = (0x03<<3),
    PORT_OPC_WIREDOR_gc = (0x04<<3),
    PORT_OPC_WIREDAND_gc = (0x05<<3),
    PORT_OPC_WIREDORPULL_gc = (0x06<<3),
    PORT_OPC_WIREDANDPULL_gc = (0x07<<3),
} PORT_OPC_t;
# 1580 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct PORTCFG_struct
{
    register8_t MPCMASK;
    register8_t reserved_1[1];
    register8_t VPCTRLA;
    register8_t VPCTRLB;
    register8_t CLKEVOUT;
    register8_t reserved_2[1];
    register8_t EVOUTSEL;
} PORTCFG_t;


typedef enum PORTCFG_CLKEVPIN_enum
{
    PORTCFG_CLKEVPIN_PIN7_gc = (0x00<<7),
    PORTCFG_CLKEVPIN_PIN4_gc = (0x01<<7),
} PORTCFG_CLKEVPIN_t;


typedef enum PORTCFG_CLKOUT_enum
{
    PORTCFG_CLKOUT_OFF_gc = (0x00<<0),
    PORTCFG_CLKOUT_PC7_gc = (0x01<<0),
    PORTCFG_CLKOUT_PD7_gc = (0x02<<0),
    PORTCFG_CLKOUT_PE7_gc = (0x03<<0),
} PORTCFG_CLKOUT_t;


typedef enum PORTCFG_CLKOUTSEL_enum
{
    PORTCFG_CLKOUTSEL_CLK1X_gc = (0x00<<2),
    PORTCFG_CLKOUTSEL_CLK2X_gc = (0x01<<2),
    PORTCFG_CLKOUTSEL_CLK4X_gc = (0x02<<2),
} PORTCFG_CLKOUTSEL_t;


typedef enum PORTCFG_EVOUT_enum
{
    PORTCFG_EVOUT_OFF_gc = (0x00<<4),
    PORTCFG_EVOUT_PC7_gc = (0x01<<4),
    PORTCFG_EVOUT_PD7_gc = (0x02<<4),
    PORTCFG_EVOUT_PE7_gc = (0x03<<4),
} PORTCFG_EVOUT_t;


typedef enum PORTCFG_EVOUTSEL_enum
{
    PORTCFG_EVOUTSEL_0_gc = (0x00<<0),
    PORTCFG_EVOUTSEL_1_gc = (0x01<<0),
    PORTCFG_EVOUTSEL_2_gc = (0x02<<0),
    PORTCFG_EVOUTSEL_3_gc = (0x03<<0),
    PORTCFG_EVOUTSEL_4_gc = (0x04<<0),
    PORTCFG_EVOUTSEL_5_gc = (0x05<<0),
    PORTCFG_EVOUTSEL_6_gc = (0x06<<0),
    PORTCFG_EVOUTSEL_7_gc = (0x07<<0),
} PORTCFG_EVOUTSEL_t;


typedef enum PORTCFG_VP0MAP_enum
{
    PORTCFG_VP0MAP_PORTA_gc = (0x00<<0),
    PORTCFG_VP0MAP_PORTB_gc = (0x01<<0),
    PORTCFG_VP0MAP_PORTC_gc = (0x02<<0),
    PORTCFG_VP0MAP_PORTD_gc = (0x03<<0),
    PORTCFG_VP0MAP_PORTE_gc = (0x04<<0),
    PORTCFG_VP0MAP_PORTF_gc = (0x05<<0),
    PORTCFG_VP0MAP_PORTG_gc = (0x06<<0),
    PORTCFG_VP0MAP_PORTH_gc = (0x07<<0),
    PORTCFG_VP0MAP_PORTJ_gc = (0x08<<0),
    PORTCFG_VP0MAP_PORTK_gc = (0x09<<0),
    PORTCFG_VP0MAP_PORTL_gc = (0x0A<<0),
    PORTCFG_VP0MAP_PORTM_gc = (0x0B<<0),
    PORTCFG_VP0MAP_PORTN_gc = (0x0C<<0),
    PORTCFG_VP0MAP_PORTP_gc = (0x0D<<0),
    PORTCFG_VP0MAP_PORTQ_gc = (0x0E<<0),
    PORTCFG_VP0MAP_PORTR_gc = (0x0F<<0),


    PORTCFG_VP02MAP_PORTA_gc = (0x00<<0),
    PORTCFG_VP02MAP_PORTB_gc = (0x01<<0),
    PORTCFG_VP02MAP_PORTC_gc = (0x02<<0),
    PORTCFG_VP02MAP_PORTD_gc = (0x03<<0),
    PORTCFG_VP02MAP_PORTE_gc = (0x04<<0),
    PORTCFG_VP02MAP_PORTF_gc = (0x05<<0),
    PORTCFG_VP02MAP_PORTG_gc = (0x06<<0),
    PORTCFG_VP02MAP_PORTH_gc = (0x07<<0),
    PORTCFG_VP02MAP_PORTJ_gc = (0x08<<0),
    PORTCFG_VP02MAP_PORTK_gc = (0x09<<0),
    PORTCFG_VP02MAP_PORTL_gc = (0x0A<<0),
    PORTCFG_VP02MAP_PORTM_gc = (0x0B<<0),
    PORTCFG_VP02MAP_PORTN_gc = (0x0C<<0),
    PORTCFG_VP02MAP_PORTP_gc = (0x0D<<0),
    PORTCFG_VP02MAP_PORTQ_gc = (0x0E<<0),
    PORTCFG_VP02MAP_PORTR_gc = (0x0F<<0),
} PORTCFG_VP0MAP_t;


typedef enum PORTCFG_VP0MAP_enum PORTCFG_VP02MAP_t;


typedef enum PORTCFG_VP1MAP_enum
{
    PORTCFG_VP1MAP_PORTA_gc = (0x00<<4),
    PORTCFG_VP1MAP_PORTB_gc = (0x01<<4),
    PORTCFG_VP1MAP_PORTC_gc = (0x02<<4),
    PORTCFG_VP1MAP_PORTD_gc = (0x03<<4),
    PORTCFG_VP1MAP_PORTE_gc = (0x04<<4),
    PORTCFG_VP1MAP_PORTF_gc = (0x05<<4),
    PORTCFG_VP1MAP_PORTG_gc = (0x06<<4),
    PORTCFG_VP1MAP_PORTH_gc = (0x07<<4),
    PORTCFG_VP1MAP_PORTJ_gc = (0x08<<4),
    PORTCFG_VP1MAP_PORTK_gc = (0x09<<4),
    PORTCFG_VP1MAP_PORTL_gc = (0x0A<<4),
    PORTCFG_VP1MAP_PORTM_gc = (0x0B<<4),
    PORTCFG_VP1MAP_PORTN_gc = (0x0C<<4),
    PORTCFG_VP1MAP_PORTP_gc = (0x0D<<4),
    PORTCFG_VP1MAP_PORTQ_gc = (0x0E<<4),
    PORTCFG_VP1MAP_PORTR_gc = (0x0F<<4),


    PORTCFG_VP13MAP_PORTA_gc = (0x00<<4),
    PORTCFG_VP13MAP_PORTB_gc = (0x01<<4),
    PORTCFG_VP13MAP_PORTC_gc = (0x02<<4),
    PORTCFG_VP13MAP_PORTD_gc = (0x03<<4),
    PORTCFG_VP13MAP_PORTE_gc = (0x04<<4),
    PORTCFG_VP13MAP_PORTF_gc = (0x05<<4),
    PORTCFG_VP13MAP_PORTG_gc = (0x06<<4),
    PORTCFG_VP13MAP_PORTH_gc = (0x07<<4),
    PORTCFG_VP13MAP_PORTJ_gc = (0x08<<4),
    PORTCFG_VP13MAP_PORTK_gc = (0x09<<4),
    PORTCFG_VP13MAP_PORTL_gc = (0x0A<<4),
    PORTCFG_VP13MAP_PORTM_gc = (0x0B<<4),
    PORTCFG_VP13MAP_PORTN_gc = (0x0C<<4),
    PORTCFG_VP13MAP_PORTP_gc = (0x0D<<4),
    PORTCFG_VP13MAP_PORTQ_gc = (0x0E<<4),
    PORTCFG_VP13MAP_PORTR_gc = (0x0F<<4),
} PORTCFG_VP1MAP_t;


typedef enum PORTCFG_VP1MAP_enum PORTCFG_VP13MAP_t;


typedef enum PORTCFG_VP2MAP_enum
{
    PORTCFG_VP2MAP_PORTA_gc = (0x00<<0),
    PORTCFG_VP2MAP_PORTB_gc = (0x01<<0),
    PORTCFG_VP2MAP_PORTC_gc = (0x02<<0),
    PORTCFG_VP2MAP_PORTD_gc = (0x03<<0),
    PORTCFG_VP2MAP_PORTE_gc = (0x04<<0),
    PORTCFG_VP2MAP_PORTF_gc = (0x05<<0),
    PORTCFG_VP2MAP_PORTG_gc = (0x06<<0),
    PORTCFG_VP2MAP_PORTH_gc = (0x07<<0),
    PORTCFG_VP2MAP_PORTJ_gc = (0x08<<0),
    PORTCFG_VP2MAP_PORTK_gc = (0x09<<0),
    PORTCFG_VP2MAP_PORTL_gc = (0x0A<<0),
    PORTCFG_VP2MAP_PORTM_gc = (0x0B<<0),
    PORTCFG_VP2MAP_PORTN_gc = (0x0C<<0),
    PORTCFG_VP2MAP_PORTP_gc = (0x0D<<0),
    PORTCFG_VP2MAP_PORTQ_gc = (0x0E<<0),
    PORTCFG_VP2MAP_PORTR_gc = (0x0F<<0),
} PORTCFG_VP2MAP_t;


typedef enum PORTCFG_VP3MAP_enum
{
    PORTCFG_VP3MAP_PORTA_gc = (0x00<<4),
    PORTCFG_VP3MAP_PORTB_gc = (0x01<<4),
    PORTCFG_VP3MAP_PORTC_gc = (0x02<<4),
    PORTCFG_VP3MAP_PORTD_gc = (0x03<<4),
    PORTCFG_VP3MAP_PORTE_gc = (0x04<<4),
    PORTCFG_VP3MAP_PORTF_gc = (0x05<<4),
    PORTCFG_VP3MAP_PORTG_gc = (0x06<<4),
    PORTCFG_VP3MAP_PORTH_gc = (0x07<<4),
    PORTCFG_VP3MAP_PORTJ_gc = (0x08<<4),
    PORTCFG_VP3MAP_PORTK_gc = (0x09<<4),
    PORTCFG_VP3MAP_PORTL_gc = (0x0A<<4),
    PORTCFG_VP3MAP_PORTM_gc = (0x0B<<4),
    PORTCFG_VP3MAP_PORTN_gc = (0x0C<<4),
    PORTCFG_VP3MAP_PORTP_gc = (0x0D<<4),
    PORTCFG_VP3MAP_PORTQ_gc = (0x0E<<4),
    PORTCFG_VP3MAP_PORTR_gc = (0x0F<<4),
} PORTCFG_VP3MAP_t;
# 1770 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct PR_struct
{
    register8_t PRGEN;
    register8_t PRPA;
    register8_t PRPB;
    register8_t PRPC;
    register8_t PRPD;
    register8_t PRPE;
    register8_t PRPF;
} PR_t;
# 1789 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct RST_struct
{
    register8_t STATUS;
    register8_t CTRL;
} RST_t;
# 1803 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct RTC_struct
{
    register8_t CTRL;
    register8_t STATUS;
    register8_t INTCTRL;
    register8_t INTFLAGS;
    register8_t TEMP;
    register8_t reserved_1[3];
    __extension__ union { register16_t CNT; struct { register8_t CNTL; register8_t CNTH; }; };
    __extension__ union { register16_t PER; struct { register8_t PERL; register8_t PERH; }; };
    __extension__ union { register16_t COMP; struct { register8_t COMPL; register8_t COMPH; }; };
} RTC_t;


typedef enum RTC_COMPINTLVL_enum
{
    RTC_COMPINTLVL_OFF_gc = (0x00<<2),
    RTC_COMPINTLVL_LO_gc = (0x01<<2),
    RTC_COMPINTLVL_MED_gc = (0x02<<2),
    RTC_COMPINTLVL_HI_gc = (0x03<<2),
} RTC_COMPINTLVL_t;


typedef enum RTC_OVFINTLVL_enum
{
    RTC_OVFINTLVL_OFF_gc = (0x00<<0),
    RTC_OVFINTLVL_LO_gc = (0x01<<0),
    RTC_OVFINTLVL_MED_gc = (0x02<<0),
    RTC_OVFINTLVL_HI_gc = (0x03<<0),
} RTC_OVFINTLVL_t;


typedef enum RTC_PRESCALER_enum
{
    RTC_PRESCALER_OFF_gc = (0x00<<0),
    RTC_PRESCALER_DIV1_gc = (0x01<<0),
    RTC_PRESCALER_DIV2_gc = (0x02<<0),
    RTC_PRESCALER_DIV8_gc = (0x03<<0),
    RTC_PRESCALER_DIV16_gc = (0x04<<0),
    RTC_PRESCALER_DIV64_gc = (0x05<<0),
    RTC_PRESCALER_DIV256_gc = (0x06<<0),
    RTC_PRESCALER_DIV1024_gc = (0x07<<0),
} RTC_PRESCALER_t;
# 1854 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct NVM_PROD_SIGNATURES_struct
{
    register8_t RCOSC2M;
    register8_t RCOSC2MA;
    register8_t RCOSC32K;
    register8_t RCOSC32M;
    register8_t RCOSC32MA;
    register8_t reserved_1[3];
    register8_t LOTNUM0;
    register8_t LOTNUM1;
    register8_t LOTNUM2;
    register8_t LOTNUM3;
    register8_t LOTNUM4;
    register8_t LOTNUM5;
    register8_t reserved_2[2];
    register8_t WAFNUM;
    register8_t reserved_3[1];
    register8_t COORDX0;
    register8_t COORDX1;
    register8_t COORDY0;
    register8_t COORDY1;
    register8_t reserved_4[4];
    register8_t USBCAL0;
    register8_t USBCAL1;
    register8_t USBRCOSC;
    register8_t USBRCOSCA;
    register8_t reserved_5[2];
    register8_t ADCACAL0;
    register8_t ADCACAL1;
    register8_t reserved_6[2];
    register8_t ADCBCAL0;
    register8_t ADCBCAL1;
    register8_t reserved_7[8];
    register8_t TEMPSENSE0;
    register8_t TEMPSENSE1;
    register8_t DACA0OFFCAL;
    register8_t DACA0GAINCAL;
    register8_t DACB0OFFCAL;
    register8_t DACB0GAINCAL;
    register8_t DACA1OFFCAL;
    register8_t DACA1GAINCAL;
    register8_t DACB1OFFCAL;
    register8_t DACB1GAINCAL;
    register8_t reserved_8[16];
} NVM_PROD_SIGNATURES_t;
# 1908 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct SLEEP_struct
{
    register8_t CTRL;
} SLEEP_t;


typedef enum SLEEP_SMODE_enum
{
    SLEEP_SMODE_IDLE_gc = (0x00<<1),
    SLEEP_SMODE_PDOWN_gc = (0x02<<1),
    SLEEP_SMODE_PSAVE_gc = (0x03<<1),
    SLEEP_SMODE_STDBY_gc = (0x06<<1),
    SLEEP_SMODE_ESTDBY_gc = (0x07<<1),
} SLEEP_SMODE_t;
# 1935 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct SPI_struct
{
    register8_t CTRL;
    register8_t INTCTRL;
    register8_t STATUS;
    register8_t DATA;
} SPI_t;


typedef enum SPI_INTLVL_enum
{
    SPI_INTLVL_OFF_gc = (0x00<<0),
    SPI_INTLVL_LO_gc = (0x01<<0),
    SPI_INTLVL_MED_gc = (0x02<<0),
    SPI_INTLVL_HI_gc = (0x03<<0),
} SPI_INTLVL_t;


typedef enum SPI_MODE_enum
{
    SPI_MODE_0_gc = (0x00<<2),
    SPI_MODE_1_gc = (0x01<<2),
    SPI_MODE_2_gc = (0x02<<2),
    SPI_MODE_3_gc = (0x03<<2),
} SPI_MODE_t;


typedef enum SPI_PRESCALER_enum
{
    SPI_PRESCALER_DIV4_gc = (0x00<<0),
    SPI_PRESCALER_DIV16_gc = (0x01<<0),
    SPI_PRESCALER_DIV64_gc = (0x02<<0),
    SPI_PRESCALER_DIV128_gc = (0x03<<0),
} SPI_PRESCALER_t;
# 1977 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct TC0_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t CTRLC;
    register8_t CTRLD;
    register8_t CTRLE;
    register8_t reserved_1[1];
    register8_t INTCTRLA;
    register8_t INTCTRLB;
    register8_t CTRLFCLR;
    register8_t CTRLFSET;
    register8_t CTRLGCLR;
    register8_t CTRLGSET;
    register8_t INTFLAGS;
    register8_t reserved_2[2];
    register8_t TEMP;
    register8_t reserved_3[16];
    __extension__ union { register16_t CNT; struct { register8_t CNTL; register8_t CNTH; }; };
    register8_t reserved_4[4];
    __extension__ union { register16_t PER; struct { register8_t PERL; register8_t PERH; }; };
    __extension__ union { register16_t CCA; struct { register8_t CCAL; register8_t CCAH; }; };
    __extension__ union { register16_t CCB; struct { register8_t CCBL; register8_t CCBH; }; };
    __extension__ union { register16_t CCC; struct { register8_t CCCL; register8_t CCCH; }; };
    __extension__ union { register16_t CCD; struct { register8_t CCDL; register8_t CCDH; }; };
    register8_t reserved_5[6];
    __extension__ union { register16_t PERBUF; struct { register8_t PERBUFL; register8_t PERBUFH; }; };
    __extension__ union { register16_t CCABUF; struct { register8_t CCABUFL; register8_t CCABUFH; }; };
    __extension__ union { register16_t CCBBUF; struct { register8_t CCBBUFL; register8_t CCBBUFH; }; };
    __extension__ union { register16_t CCCBUF; struct { register8_t CCCBUFL; register8_t CCCBUFH; }; };
    __extension__ union { register16_t CCDBUF; struct { register8_t CCDBUFL; register8_t CCDBUFH; }; };
} TC0_t;



typedef struct TC1_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t CTRLC;
    register8_t CTRLD;
    register8_t CTRLE;
    register8_t reserved_1[1];
    register8_t INTCTRLA;
    register8_t INTCTRLB;
    register8_t CTRLFCLR;
    register8_t CTRLFSET;
    register8_t CTRLGCLR;
    register8_t CTRLGSET;
    register8_t INTFLAGS;
    register8_t reserved_2[2];
    register8_t TEMP;
    register8_t reserved_3[16];
    __extension__ union { register16_t CNT; struct { register8_t CNTL; register8_t CNTH; }; };
    register8_t reserved_4[4];
    __extension__ union { register16_t PER; struct { register8_t PERL; register8_t PERH; }; };
    __extension__ union { register16_t CCA; struct { register8_t CCAL; register8_t CCAH; }; };
    __extension__ union { register16_t CCB; struct { register8_t CCBL; register8_t CCBH; }; };
    register8_t reserved_5[10];
    __extension__ union { register16_t PERBUF; struct { register8_t PERBUFL; register8_t PERBUFH; }; };
    __extension__ union { register16_t CCABUF; struct { register8_t CCABUFL; register8_t CCABUFH; }; };
    __extension__ union { register16_t CCBBUF; struct { register8_t CCBBUFL; register8_t CCBBUFH; }; };
} TC1_t;


typedef enum TC_BYTEM_enum
{
    TC_BYTEM_NORMAL_gc = (0x00<<0),
    TC_BYTEM_BYTEMODE_gc = (0x01<<0),
    TC_BYTEM_SPLITMODE_gc = (0x02<<0),
} TC_BYTEM_t;


typedef enum TC_CCAINTLVL_enum
{
    TC_CCAINTLVL_OFF_gc = (0x00<<0),
    TC_CCAINTLVL_LO_gc = (0x01<<0),
    TC_CCAINTLVL_MED_gc = (0x02<<0),
    TC_CCAINTLVL_HI_gc = (0x03<<0),
} TC_CCAINTLVL_t;


typedef enum TC_CCBINTLVL_enum
{
    TC_CCBINTLVL_OFF_gc = (0x00<<2),
    TC_CCBINTLVL_LO_gc = (0x01<<2),
    TC_CCBINTLVL_MED_gc = (0x02<<2),
    TC_CCBINTLVL_HI_gc = (0x03<<2),
} TC_CCBINTLVL_t;


typedef enum TC_CCCINTLVL_enum
{
    TC_CCCINTLVL_OFF_gc = (0x00<<4),
    TC_CCCINTLVL_LO_gc = (0x01<<4),
    TC_CCCINTLVL_MED_gc = (0x02<<4),
    TC_CCCINTLVL_HI_gc = (0x03<<4),
} TC_CCCINTLVL_t;


typedef enum TC_CCDINTLVL_enum
{
    TC_CCDINTLVL_OFF_gc = (0x00<<6),
    TC_CCDINTLVL_LO_gc = (0x01<<6),
    TC_CCDINTLVL_MED_gc = (0x02<<6),
    TC_CCDINTLVL_HI_gc = (0x03<<6),
} TC_CCDINTLVL_t;


typedef enum TC_CLKSEL_enum
{
    TC_CLKSEL_OFF_gc = (0x00<<0),
    TC_CLKSEL_DIV1_gc = (0x01<<0),
    TC_CLKSEL_DIV2_gc = (0x02<<0),
    TC_CLKSEL_DIV4_gc = (0x03<<0),
    TC_CLKSEL_DIV8_gc = (0x04<<0),
    TC_CLKSEL_DIV64_gc = (0x05<<0),
    TC_CLKSEL_DIV256_gc = (0x06<<0),
    TC_CLKSEL_DIV1024_gc = (0x07<<0),
    TC_CLKSEL_EVCH0_gc = (0x08<<0),
    TC_CLKSEL_EVCH1_gc = (0x09<<0),
    TC_CLKSEL_EVCH2_gc = (0x0A<<0),
    TC_CLKSEL_EVCH3_gc = (0x0B<<0),
    TC_CLKSEL_EVCH4_gc = (0x0C<<0),
    TC_CLKSEL_EVCH5_gc = (0x0D<<0),
    TC_CLKSEL_EVCH6_gc = (0x0E<<0),
    TC_CLKSEL_EVCH7_gc = (0x0F<<0),
} TC_CLKSEL_t;


typedef enum TC_CMD_enum
{
    TC_CMD_NONE_gc = (0x00<<2),
    TC_CMD_UPDATE_gc = (0x01<<2),
    TC_CMD_RESTART_gc = (0x02<<2),
    TC_CMD_RESET_gc = (0x03<<2),
} TC_CMD_t;


typedef enum TC_ERRINTLVL_enum
{
    TC_ERRINTLVL_OFF_gc = (0x00<<2),
    TC_ERRINTLVL_LO_gc = (0x01<<2),
    TC_ERRINTLVL_MED_gc = (0x02<<2),
    TC_ERRINTLVL_HI_gc = (0x03<<2),
} TC_ERRINTLVL_t;


typedef enum TC_EVACT_enum
{
    TC_EVACT_OFF_gc = (0x00<<5),
    TC_EVACT_CAPT_gc = (0x01<<5),
    TC_EVACT_UPDOWN_gc = (0x02<<5),
    TC_EVACT_QDEC_gc = (0x03<<5),
    TC_EVACT_RESTART_gc = (0x04<<5),
    TC_EVACT_FRQ_gc = (0x05<<5),
    TC_EVACT_PW_gc = (0x06<<5),
} TC_EVACT_t;


typedef enum TC_EVSEL_enum
{
    TC_EVSEL_OFF_gc = (0x00<<0),
    TC_EVSEL_CH0_gc = (0x08<<0),
    TC_EVSEL_CH1_gc = (0x09<<0),
    TC_EVSEL_CH2_gc = (0x0A<<0),
    TC_EVSEL_CH3_gc = (0x0B<<0),
    TC_EVSEL_CH4_gc = (0x0C<<0),
    TC_EVSEL_CH5_gc = (0x0D<<0),
    TC_EVSEL_CH6_gc = (0x0E<<0),
    TC_EVSEL_CH7_gc = (0x0F<<0),
} TC_EVSEL_t;


typedef enum TC_OVFINTLVL_enum
{
    TC_OVFINTLVL_OFF_gc = (0x00<<0),
    TC_OVFINTLVL_LO_gc = (0x01<<0),
    TC_OVFINTLVL_MED_gc = (0x02<<0),
    TC_OVFINTLVL_HI_gc = (0x03<<0),
} TC_OVFINTLVL_t;


typedef enum TC_WGMODE_enum
{
    TC_WGMODE_NORMAL_gc = (0x00<<0),
    TC_WGMODE_FRQ_gc = (0x01<<0),
    TC_WGMODE_SINGLESLOPE_gc = (0x03<<0),
    TC_WGMODE_SS_gc = (0x03<<0),
    TC_WGMODE_DSTOP_gc = (0x05<<0),
    TC_WGMODE_DS_T_gc = (0x05<<0),
    TC_WGMODE_DSBOTH_gc = (0x06<<0),
    TC_WGMODE_DS_TB_gc = (0x06<<0),
    TC_WGMODE_DSBOTTOM_gc = (0x07<<0),
    TC_WGMODE_DS_B_gc = (0x07<<0),
} TC_WGMODE_t;
# 2181 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct TC2_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t CTRLC;
    register8_t reserved_1[1];
    register8_t CTRLE;
    register8_t reserved_2[1];
    register8_t INTCTRLA;
    register8_t INTCTRLB;
    register8_t reserved_3[1];
    register8_t CTRLF;
    register8_t reserved_4[2];
    register8_t INTFLAGS;
    register8_t reserved_5[19];
    register8_t LCNT;
    register8_t HCNT;
    register8_t reserved_6[4];
    register8_t LPER;
    register8_t HPER;
    register8_t LCMPA;
    register8_t HCMPA;
    register8_t LCMPB;
    register8_t HCMPB;
    register8_t LCMPC;
    register8_t HCMPC;
    register8_t LCMPD;
    register8_t HCMPD;
} TC2_t;


typedef enum TC2_BYTEM_enum
{
    TC2_BYTEM_NORMAL_gc = (0x00<<0),
    TC2_BYTEM_BYTEMODE_gc = (0x01<<0),
    TC2_BYTEM_SPLITMODE_gc = (0x02<<0),
} TC2_BYTEM_t;


typedef enum TC2_CLKSEL_enum
{
    TC2_CLKSEL_OFF_gc = (0x00<<0),
    TC2_CLKSEL_DIV1_gc = (0x01<<0),
    TC2_CLKSEL_DIV2_gc = (0x02<<0),
    TC2_CLKSEL_DIV4_gc = (0x03<<0),
    TC2_CLKSEL_DIV8_gc = (0x04<<0),
    TC2_CLKSEL_DIV64_gc = (0x05<<0),
    TC2_CLKSEL_DIV256_gc = (0x06<<0),
    TC2_CLKSEL_DIV1024_gc = (0x07<<0),
    TC2_CLKSEL_EVCH0_gc = (0x08<<0),
    TC2_CLKSEL_EVCH1_gc = (0x09<<0),
    TC2_CLKSEL_EVCH2_gc = (0x0A<<0),
    TC2_CLKSEL_EVCH3_gc = (0x0B<<0),
    TC2_CLKSEL_EVCH4_gc = (0x0C<<0),
    TC2_CLKSEL_EVCH5_gc = (0x0D<<0),
    TC2_CLKSEL_EVCH6_gc = (0x0E<<0),
    TC2_CLKSEL_EVCH7_gc = (0x0F<<0),
} TC2_CLKSEL_t;


typedef enum TC2_CMD_enum
{
    TC2_CMD_NONE_gc = (0x00<<2),
    TC2_CMD_RESTART_gc = (0x02<<2),
    TC2_CMD_RESET_gc = (0x03<<2),
} TC2_CMD_t;


typedef enum TC2_CMDEN_enum
{
    TC2_CMDEN_LOW_gc = (0x01<<0),
    TC2_CMDEN_HIGH_gc = (0x02<<0),
    TC2_CMDEN_BOTH_gc = (0x03<<0),
} TC2_CMDEN_t;


typedef enum TC2_HUNFINTLVL_enum
{
    TC2_HUNFINTLVL_OFF_gc = (0x00<<2),
    TC2_HUNFINTLVL_LO_gc = (0x01<<2),
    TC2_HUNFINTLVL_MED_gc = (0x02<<2),
    TC2_HUNFINTLVL_HI_gc = (0x03<<2),
} TC2_HUNFINTLVL_t;


typedef enum TC2_LCMPAINTLVL_enum
{
    TC2_LCMPAINTLVL_OFF_gc = (0x00<<0),
    TC2_LCMPAINTLVL_LO_gc = (0x01<<0),
    TC2_LCMPAINTLVL_MED_gc = (0x02<<0),
    TC2_LCMPAINTLVL_HI_gc = (0x03<<0),
} TC2_LCMPAINTLVL_t;


typedef enum TC2_LCMPBINTLVL_enum
{
    TC2_LCMPBINTLVL_OFF_gc = (0x00<<2),
    TC2_LCMPBINTLVL_LO_gc = (0x01<<2),
    TC2_LCMPBINTLVL_MED_gc = (0x02<<2),
    TC2_LCMPBINTLVL_HI_gc = (0x03<<2),
} TC2_LCMPBINTLVL_t;


typedef enum TC2_LCMPCINTLVL_enum
{
    TC2_LCMPCINTLVL_OFF_gc = (0x00<<4),
    TC2_LCMPCINTLVL_LO_gc = (0x01<<4),
    TC2_LCMPCINTLVL_MED_gc = (0x02<<4),
    TC2_LCMPCINTLVL_HI_gc = (0x03<<4),
} TC2_LCMPCINTLVL_t;


typedef enum TC2_LCMPDINTLVL_enum
{
    TC2_LCMPDINTLVL_OFF_gc = (0x00<<6),
    TC2_LCMPDINTLVL_LO_gc = (0x01<<6),
    TC2_LCMPDINTLVL_MED_gc = (0x02<<6),
    TC2_LCMPDINTLVL_HI_gc = (0x03<<6),
} TC2_LCMPDINTLVL_t;


typedef enum TC2_LUNFINTLVL_enum
{
    TC2_LUNFINTLVL_OFF_gc = (0x00<<0),
    TC2_LUNFINTLVL_LO_gc = (0x01<<0),
    TC2_LUNFINTLVL_MED_gc = (0x02<<0),
    TC2_LUNFINTLVL_HI_gc = (0x03<<0),
} TC2_LUNFINTLVL_t;
# 2317 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct TWI_MASTER_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t CTRLC;
    register8_t STATUS;
    register8_t BAUD;
    register8_t ADDR;
    register8_t DATA;
} TWI_MASTER_t;



typedef struct TWI_SLAVE_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t STATUS;
    register8_t ADDR;
    register8_t DATA;
    register8_t ADDRMASK;
} TWI_SLAVE_t;



typedef struct TWI_struct
{
    register8_t CTRL;
    TWI_MASTER_t MASTER;
    TWI_SLAVE_t SLAVE;
} TWI_t;


typedef enum TWI_MASTER_BUSSTATE_enum
{
    TWI_MASTER_BUSSTATE_UNKNOWN_gc = (0x00<<0),
    TWI_MASTER_BUSSTATE_IDLE_gc = (0x01<<0),
    TWI_MASTER_BUSSTATE_OWNER_gc = (0x02<<0),
    TWI_MASTER_BUSSTATE_BUSY_gc = (0x03<<0),
} TWI_MASTER_BUSSTATE_t;


typedef enum TWI_MASTER_CMD_enum
{
    TWI_MASTER_CMD_NOACT_gc = (0x00<<0),
    TWI_MASTER_CMD_REPSTART_gc = (0x01<<0),
    TWI_MASTER_CMD_RECVTRANS_gc = (0x02<<0),
    TWI_MASTER_CMD_STOP_gc = (0x03<<0),
} TWI_MASTER_CMD_t;


typedef enum TWI_MASTER_INTLVL_enum
{
    TWI_MASTER_INTLVL_OFF_gc = (0x00<<6),
    TWI_MASTER_INTLVL_LO_gc = (0x01<<6),
    TWI_MASTER_INTLVL_MED_gc = (0x02<<6),
    TWI_MASTER_INTLVL_HI_gc = (0x03<<6),
} TWI_MASTER_INTLVL_t;


typedef enum TWI_MASTER_TIMEOUT_enum
{
    TWI_MASTER_TIMEOUT_DISABLED_gc = (0x00<<2),
    TWI_MASTER_TIMEOUT_50US_gc = (0x01<<2),
    TWI_MASTER_TIMEOUT_100US_gc = (0x02<<2),
    TWI_MASTER_TIMEOUT_200US_gc = (0x03<<2),
} TWI_MASTER_TIMEOUT_t;


typedef enum TWI_SLAVE_CMD_enum
{
    TWI_SLAVE_CMD_NOACT_gc = (0x00<<0),
    TWI_SLAVE_CMD_COMPTRANS_gc = (0x02<<0),
    TWI_SLAVE_CMD_RESPONSE_gc = (0x03<<0),
} TWI_SLAVE_CMD_t;


typedef enum TWI_SLAVE_INTLVL_enum
{
    TWI_SLAVE_INTLVL_OFF_gc = (0x00<<6),
    TWI_SLAVE_INTLVL_LO_gc = (0x01<<6),
    TWI_SLAVE_INTLVL_MED_gc = (0x02<<6),
    TWI_SLAVE_INTLVL_HI_gc = (0x03<<6),
} TWI_SLAVE_INTLVL_t;


typedef enum TWI_SDAHOLD_enum
{
    TWI_SDAHOLD_OFF_gc = (0x00<<1),
    TWI_SDAHOLD_50NS_gc = (0x01<<1),
    TWI_SDAHOLD_300NS_gc = (0x02<<1),
    TWI_SDAHOLD_400NS_gc = (0x03<<1),
} TWI_SDAHOLD_t;
# 2418 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct USART_struct
{
    register8_t DATA;
    register8_t STATUS;
    register8_t reserved_1[1];
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t CTRLC;
    register8_t BAUDCTRLA;
    register8_t BAUDCTRLB;
} USART_t;


typedef enum USART_CHSIZE_enum
{
    USART_CHSIZE_5BIT_gc = (0x00<<0),
    USART_CHSIZE_6BIT_gc = (0x01<<0),
    USART_CHSIZE_7BIT_gc = (0x02<<0),
    USART_CHSIZE_8BIT_gc = (0x03<<0),
    USART_CHSIZE_9BIT_gc = (0x07<<0),
} USART_CHSIZE_t;


typedef enum USART_CMODE_enum
{
    USART_CMODE_ASYNCHRONOUS_gc = (0x00<<6),
    USART_CMODE_SYNCHRONOUS_gc = (0x01<<6),
    USART_CMODE_IRDA_gc = (0x02<<6),
    USART_CMODE_MSPI_gc = (0x03<<6),
} USART_CMODE_t;


typedef enum USART_DREINTLVL_enum
{
    USART_DREINTLVL_OFF_gc = (0x00<<0),
    USART_DREINTLVL_LO_gc = (0x01<<0),
    USART_DREINTLVL_MED_gc = (0x02<<0),
    USART_DREINTLVL_HI_gc = (0x03<<0),
} USART_DREINTLVL_t;


typedef enum USART_PMODE_enum
{
    USART_PMODE_DISABLED_gc = (0x00<<4),
    USART_PMODE_EVEN_gc = (0x02<<4),
    USART_PMODE_ODD_gc = (0x03<<4),
} USART_PMODE_t;


typedef enum USART_RXCINTLVL_enum
{
    USART_RXCINTLVL_OFF_gc = (0x00<<4),
    USART_RXCINTLVL_LO_gc = (0x01<<4),
    USART_RXCINTLVL_MED_gc = (0x02<<4),
    USART_RXCINTLVL_HI_gc = (0x03<<4),
} USART_RXCINTLVL_t;


typedef enum USART_TXCINTLVL_enum
{
    USART_TXCINTLVL_OFF_gc = (0x00<<2),
    USART_TXCINTLVL_LO_gc = (0x01<<2),
    USART_TXCINTLVL_MED_gc = (0x02<<2),
    USART_TXCINTLVL_HI_gc = (0x03<<2),
} USART_TXCINTLVL_t;
# 2491 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct USB_EP_struct
{
    register8_t STATUS;
    register8_t CTRL;
    __extension__ union { register16_t CNT; struct { register8_t CNTL; register8_t CNTH; }; };
    __extension__ union { register16_t DATAPTR; struct { register8_t DATAPTRL; register8_t DATAPTRH; }; };
    __extension__ union { register16_t AUXDATA; struct { register8_t AUXDATAL; register8_t AUXDATAH; }; };
} USB_EP_t;



typedef struct USB_struct
{
    register8_t CTRLA;
    register8_t CTRLB;
    register8_t STATUS;
    register8_t ADDR;
    register8_t FIFOWP;
    register8_t FIFORP;
    __extension__ union { register16_t EPPTR; struct { register8_t EPPTRL; register8_t EPPTRH; }; };
    register8_t INTCTRLA;
    register8_t INTCTRLB;
    register8_t INTFLAGSACLR;
    register8_t INTFLAGSASET;
    register8_t INTFLAGSBCLR;
    register8_t INTFLAGSBSET;
    register8_t reserved_1[44];
    register8_t CAL0;
    register8_t CAL1;
} USB_t;



typedef struct USB_EP_TABLE_struct
{
    USB_EP_t EP0OUT;
    USB_EP_t EP0IN;
    USB_EP_t EP1OUT;
    USB_EP_t EP1IN;
    USB_EP_t EP2OUT;
    USB_EP_t EP2IN;
    USB_EP_t EP3OUT;
    USB_EP_t EP3IN;
    USB_EP_t EP4OUT;
    USB_EP_t EP4IN;
    USB_EP_t EP5OUT;
    USB_EP_t EP5IN;
    USB_EP_t EP6OUT;
    USB_EP_t EP6IN;
    USB_EP_t EP7OUT;
    USB_EP_t EP7IN;
    USB_EP_t EP8OUT;
    USB_EP_t EP8IN;
    USB_EP_t EP9OUT;
    USB_EP_t EP9IN;
    USB_EP_t EP10OUT;
    USB_EP_t EP10IN;
    USB_EP_t EP11OUT;
    USB_EP_t EP11IN;
    USB_EP_t EP12OUT;
    USB_EP_t EP12IN;
    USB_EP_t EP13OUT;
    USB_EP_t EP13IN;
    USB_EP_t EP14OUT;
    USB_EP_t EP14IN;
    USB_EP_t EP15OUT;
    USB_EP_t EP15IN;
    register8_t reserved_1[16];
    register8_t FRAMENUML;
    register8_t FRAMENUMH;
} USB_EP_TABLE_t;


typedef enum USB_EP_BUFSIZE_enum
{
    USB_EP_BUFSIZE_8_gc = (0x00<<0),
    USB_EP_BUFSIZE_16_gc = (0x01<<0),
    USB_EP_BUFSIZE_32_gc = (0x02<<0),
    USB_EP_BUFSIZE_64_gc = (0x03<<0),
    USB_EP_BUFSIZE_128_gc = (0x04<<0),
    USB_EP_BUFSIZE_256_gc = (0x05<<0),
    USB_EP_BUFSIZE_512_gc = (0x06<<0),
    USB_EP_BUFSIZE_1023_gc = (0x07<<0),
} USB_EP_BUFSIZE_t;


typedef enum USB_EP_TYPE_enum
{
    USB_EP_TYPE_DISABLE_gc = (0x00<<6),
    USB_EP_TYPE_CONTROL_gc = (0x01<<6),
    USB_EP_TYPE_BULK_gc = (0x02<<6),
    USB_EP_TYPE_ISOCHRONOUS_gc = (0x03<<6),
} USB_EP_TYPE_t;


typedef enum USB_INTLVL_enum
{
    USB_INTLVL_OFF_gc = (0x00<<0),
    USB_INTLVL_LO_gc = (0x01<<0),
    USB_INTLVL_MED_gc = (0x02<<0),
    USB_INTLVL_HI_gc = (0x03<<0),
} USB_INTLVL_t;
# 2601 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct VPORT_struct
{
    register8_t DIR;
    register8_t OUT;
    register8_t IN;
    register8_t INTFLAGS;
} VPORT_t;
# 2617 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct WDT_struct
{
    register8_t CTRL;
    register8_t WINCTRL;
    register8_t STATUS;
} WDT_t;


typedef enum WDT_PER_enum
{
    WDT_PER_8CLK_gc = (0x00<<2),
    WDT_PER_16CLK_gc = (0x01<<2),
    WDT_PER_32CLK_gc = (0x02<<2),
    WDT_PER_64CLK_gc = (0x03<<2),
    WDT_PER_128CLK_gc = (0x04<<2),
    WDT_PER_256CLK_gc = (0x05<<2),
    WDT_PER_512CLK_gc = (0x06<<2),
    WDT_PER_1KCLK_gc = (0x07<<2),
    WDT_PER_2KCLK_gc = (0x08<<2),
    WDT_PER_4KCLK_gc = (0x09<<2),
    WDT_PER_8KCLK_gc = (0x0A<<2),
} WDT_PER_t;


typedef enum WDT_WPER_enum
{
    WDT_WPER_8CLK_gc = (0x00<<2),
    WDT_WPER_16CLK_gc = (0x01<<2),
    WDT_WPER_32CLK_gc = (0x02<<2),
    WDT_WPER_64CLK_gc = (0x03<<2),
    WDT_WPER_128CLK_gc = (0x04<<2),
    WDT_WPER_256CLK_gc = (0x05<<2),
    WDT_WPER_512CLK_gc = (0x06<<2),
    WDT_WPER_1KCLK_gc = (0x07<<2),
    WDT_WPER_2KCLK_gc = (0x08<<2),
    WDT_WPER_4KCLK_gc = (0x09<<2),
    WDT_WPER_8KCLK_gc = (0x0A<<2),
} WDT_WPER_t;
# 2663 "C:\\Program Files (x86)\\Atmel\\Studio\\7.0\\Packs\\Atmel\\XMEGAA_DFP\\1.1.136\\include/avr/iox32a4u.h" 3
typedef struct OCD_struct
{
    register8_t OCDR0;
    register8_t OCDR1;
} OCD_t;
# 489 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3
# 627 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\portpins.h" 1 3
# 628 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\common.h" 1 3
# 630 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3

# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\version.h" 1 3
# 632 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\xmega.h" 1 3
# 635 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3



# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\fuse.h" 1 3
# 231 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\fuse.h" 3
typedef struct
{
    unsigned char byte[6];
} __fuse_t;
# 639 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3


# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\lock.h" 1 3
# 642 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\io.h" 2 3
# 38 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 2 3
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\interrupt.h" 1 3
# 39 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\util\\atomic.h" 2 3



static __inline__ uint8_t __iSeiRetVal(void)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("sei" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    __asm__ __volatile__ ("cli" ::: "memory");
    __asm__ volatile ("" ::: "memory");
    (void)__s;
}

static __inline__ void __iRestore(const uint8_t *__s)
{
    (*(volatile uint8_t *)(0x003F)) = *__s;
    __asm__ volatile ("" ::: "memory");
}
# 24 ".././sboxnet.c" 2
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 1 3 4
# 149 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 328 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\lib\\gcc\\avr\\5.4.0\\include\\stddef.h" 3 4
typedef int wchar_t;
# 25 ".././sboxnet.c" 2

# 1 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 1
# 25 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
# 1 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\cpufunc.h" 1 3
# 91 "c:\\program files (x86)\\atmel\\studio\\7.0\\toolchain\\avr8\\avr8-gnu-toolchain\\avr\\include\\avr\\cpufunc.h" 3
void ccp_write_io (uint8_t *__ioaddr, uint8_t __value);
# 26 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 2
# 65 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"

# 65 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
static inline void port_ctrl_opc(PORT_t* p, uint8_t bv, uint8_t opc) {
    if (bv & 0x01)
        p->PIN0CTRL = (p->PIN0CTRL & ~
# 67 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 67 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
    if (bv & 0x02)
        p->PIN1CTRL = (p->PIN1CTRL & ~
# 69 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 69 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
    if (bv & 0x04)
        p->PIN2CTRL = (p->PIN2CTRL & ~
# 71 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 71 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
    if (bv & 0x08)
        p->PIN3CTRL = (p->PIN3CTRL & ~
# 73 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 73 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
    if (bv & 0x10)
        p->PIN4CTRL = (p->PIN4CTRL & ~
# 75 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 75 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
    if (bv & 0x20)
        p->PIN5CTRL = (p->PIN5CTRL & ~
# 77 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 77 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
    if (bv & 0x40)
        p->PIN6CTRL = (p->PIN6CTRL & ~
# 79 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 79 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
    if (bv & 0x80)
        p->PIN7CTRL = (p->PIN7CTRL & ~
# 81 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h" 3
                                     0x38
# 81 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
                                                ) | opc;
}
# 121 "C:\\Users\\balagi\\Documents\\git/avrutilslib/defines.h"
static inline uint8_t rol_byte(uint8_t v) {
    return (v << 1) + (v & 0x80 ? 1 : 0);
}

static inline uint16_t rol_word(uint16_t v) {
    return (v << 1) + (v & 0x8000 ? 1 : 0);
}
# 27 ".././sboxnet.c" 2
# 1 "C:\\Users\\balagi\\Documents\\git/avrutilslib/random.h" 1
# 25 "C:\\Users\\balagi\\Documents\\git/avrutilslib/random.h"
static inline uint8_t prng_xorshift8(uint8_t x) {
    x ^= (x << 1);
    x ^= (x >> 1);
    x ^= (x * 4);
    return x;
}

static inline uint16_t prng_xorshift16(uint16_t x) {
    x ^= (x << 1);
    x ^= (x >> 5);
    x ^= (x << 2);
    return x;
}
# 28 ".././sboxnet.c" 2

# 1 "C:\\Users\\balagi\\Documents\\git/sboxnet/sboxnet.h" 1
# 49 "C:\\Users\\balagi\\Documents\\git/sboxnet/sboxnet.h"
# 1 "C:\\Users\\balagi\\Documents\\git/sboxnet/sboxnet-struct.h" 1
# 45 "C:\\Users\\balagi\\Documents\\git/sboxnet/sboxnet-struct.h"
struct sboxnet_msg_header {
    uint8_t dstaddr;
    uint8_t srcaddr;
    uint8_t seq;
    struct opt {
        unsigned len : 6;
        unsigned flags : 2;
    } opt;
    uint8_t cmd;
    uint8_t data[0];
} __attribute__ ((packed));







struct sboxnet_msg_max {
    struct sboxnet_msg_header msgh;
    uint8_t data[63 +1];
};


struct sboxnet_debug_info {
    uint16_t recv_byte;
    uint16_t recv_msg_got;
    uint16_t recv_msg_fetched;
    uint16_t tmit_byte;
    uint16_t tmit_msg_tosend;
    uint16_t tmit_msg_sent;
    uint16_t collisions;
    uint16_t coll_rxc;
    uint16_t coll_fe;
    uint16_t coll_udr;
    uint16_t retries;
    uint16_t recverrors;
    uint16_t recverr_fe;
    uint16_t recverr_pe;
    uint16_t recverr_dor;
    uint16_t recverr_proto;
    uint16_t recverr_size;
    uint16_t crcerrors;
    uint16_t tmiterrors;
};
# 50 "C:\\Users\\balagi\\Documents\\git/sboxnet/sboxnet.h" 2
# 80 "C:\\Users\\balagi\\Documents\\git/sboxnet/sboxnet.h"
struct sboxnet_ring_buffer {
    uint8_t rd;
    uint8_t rd_count;
    uint8_t rd_rollback;
    uint8_t wr;
    uint8_t wr_count;
    uint8_t wr_rollback;
    uint8_t count;
    uint8_t size;
    uint8_t buf[0];
};

struct sboxnet_recv_ring_buffer {
    struct sboxnet_ring_buffer rb;
    uint8_t buf[(2*((63 +(5 +1))+1))];
};
struct sboxnet_tmit_ring_buffer {
    struct sboxnet_ring_buffer rb;
    uint8_t buf[(2*((63 +(5 +1))+1))];
};


struct sboxnet_device {
    uint8_t state;
    uint8_t flags;
    uint8_t retry_counter;
    uint8_t tmit_cnt;
    uint8_t tmit_bytes;
    uint8_t tmit_lastbyte;
    uint8_t backoff_bits;
    uint8_t recv_len;
    uint8_t prng_seed;
    struct sboxnet_recv_ring_buffer recv_buf;
    struct sboxnet_tmit_ring_buffer tmit_buf;




};
# 30 ".././sboxnet.c" 2
# 243 ".././sboxnet.c"
 static inline uint8_t sboxnet_crc8_init(void) {
    return 0xff;
}

 static uint8_t sboxnet_crc8_add(uint8_t crc, uint8_t v) {
    return _crc_ibutton_update(crc, v);
}

 static inline uint8_t sboxnet_crc8_ok(uint8_t crc) {
    return crc == 0x00;
}



 static uint8_t sboxnet_prandom(void) {
    SBOXNET_VAR->prng_seed = prng_xorshift8(SBOXNET_VAR->prng_seed);
    return SBOXNET_VAR->prng_seed;
}




 static void sboxnet_rb_init(struct sboxnet_ring_buffer* rb, uint8_t size) {
    rb->rd = 0;
    rb->rd_count = 0;
    rb->rd_rollback = 0;
    rb->wr = 0;
    rb->wr_count = 0;
    rb->wr_rollback = 0;
    rb->count = 0;
    rb->size = size;
}


 static inline uint8_t sboxnet_rb_getcount(struct sboxnet_ring_buffer* rb) {
    return rb->count;
}
 static inline uint8_t sboxnet_rb_getfree(struct sboxnet_ring_buffer* rb) {
    return rb->size - rb->count - rb->wr_count;
}

 static inline void sboxnet_rb_write_commit(struct sboxnet_ring_buffer* rb) {





    rb->count += rb->wr_count;
    rb->wr_count = 0;
    rb->wr_rollback = rb->wr;
}

 static void sboxnet_rb_write_rollback(struct sboxnet_ring_buffer* rb) {
    rb->wr_count = 0;
    rb->wr = rb->wr_rollback;
}

 static uint8_t sboxnet_rb_write(struct sboxnet_ring_buffer* rb, uint8_t a_v) {
    uint8_t rc = 0;
    if ((uint8_t)(rb->count + rb->wr_count) < rb->size) {
        rb->wr_count++;
        rb->buf[rb->wr] = a_v;
        rb->wr++;
        if (rb->wr >= rb->size) {
            rb->wr = 0;
        }
        rc = 1;
    } else {



        rc = 0;
    }
    return rc;
}

 static void sboxnet_rb_put_first(struct sboxnet_ring_buffer* rb, uint8_t v) {
    rb->buf[rb->wr_rollback] = v;
}

 static inline uint8_t sboxnet_rb_write_count(struct sboxnet_ring_buffer* rb) {
    return rb->wr_count;
}

 static void sboxnet_rb_read_commit(struct sboxnet_ring_buffer* rb) {





    rb->count -= rb->rd_count;
    rb->rd_count = 0;
    rb->rd_rollback = rb->rd;
}

 static void sboxnet_rb_read_rollback(struct sboxnet_ring_buffer* rb) {
    rb->rd_count = 0;
    rb->rd = rb->rd_rollback;
}

 static uint8_t sboxnet_rb_read(struct sboxnet_ring_buffer* rb) {
    uint8_t v = 0;
    if (rb->count > rb->rd_count) {
        rb->rd_count++;
        v = rb->buf[rb->rd];
        rb->rd++;
        if (rb->rd >= rb->size) {
            rb->rd = 0;
        }
    } else {



    }
    return v;
}

 static uint8_t sboxnet_rb_read_getone(struct sboxnet_ring_buffer* rb) {
    uint8_t v = 0;
    if (rb->count > rb->rd_count) {
        v = rb->buf[rb->rd];
    } else {



    }
    return v;
}

 static inline uint8_t sboxnet_rb_can_read_bytes(struct sboxnet_ring_buffer* rb) {
    return rb->count - rb->rd_count;
}





 __attribute__((noinline)) __attribute__((used)) static void sboxnet_receiver_enable(void) {

    SBOXNET_USART_ID.CTRLA = (
# 382 ".././sboxnet.c" 3
                             (*(USART_t *) 0x08A0)
# 382 ".././sboxnet.c"
                                    .CTRLA & ~
# 382 ".././sboxnet.c" 3
                                              0x30
# 382 ".././sboxnet.c"
                                                                ) | USART_RXCINTLVL_MED_gc;

    ((SBOXNET_USART_ID.CTRLB) |= (
# 384 ".././sboxnet.c" 3
   0x10
# 384 ".././sboxnet.c"
   |
# 384 ".././sboxnet.c" 3
   0x02
# 384 ".././sboxnet.c"
   ));
}
# 394 ".././sboxnet.c"
 __attribute__((noinline)) __attribute__((used)) static void sboxnet_init(void) {

    struct sboxnet_device *dev = SBOXNET_VAR;

    memset(dev, 0, sizeof(struct sboxnet_device));

    dev->state = 0;

    dev->prng_seed = SBOXNET_PRNG_SEED;

    dev->retry_counter = 25;


    sboxnet_rb_init(&dev->recv_buf.rb, sizeof(dev->recv_buf.buf));

    sboxnet_rb_init(&dev->tmit_buf.rb, sizeof(dev->tmit_buf.buf));


    (
# 412 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 412 ".././sboxnet.c"
   ).DIRCLR = ((1<<(2)));

    port_ctrl_opc(&(
# 414 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 414 ".././sboxnet.c"
   ), (1<<(2)), PORT_OPC_PULLUP_gc);


    (
# 417 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 417 ".././sboxnet.c"
   ).OUTSET = ((1<<(3)));
    (
# 418 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 418 ".././sboxnet.c"
   ).DIRSET = ((1<<(3)));




    SBOXNET_TIMER.CTRLB = TC_WGMODE_NORMAL_gc;
    SBOXNET_TIMER.CTRLD = 0;
    SBOXNET_TIMER.CTRLE = 0;
    SBOXNET_TIMER.INTCTRLA = TC_OVFINTLVL_MED_gc;
    SBOXNET_TIMER.INTCTRLB = 0;
    SBOXNET_TIMER.INTFLAGS = 0xff;
    SBOXNET_TIMER.PER = SBOXNET_TC_PERIOD;
    SBOXNET_TIMER.CTRLA = SBOXNET_TC_PRESCALER;





    
# 436 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 436 ".././sboxnet.c"
        .INTCTRL &= ~
# 436 ".././sboxnet.c" 3
                     0x03
# 436 ".././sboxnet.c"
                                    ;

    
# 438 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 438 ".././sboxnet.c"
        .INT0MASK = (1<<(2));

    
# 440 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 440 ".././sboxnet.c"
        .INTFLAGS = (1<<(
# 440 ".././sboxnet.c" 3
                    0
# 440 ".././sboxnet.c"
                    ));




    SBOXNET_USART_ID.BAUDCTRLB = ((uint8_t)((((F_CPU / 16 / 250000) - 1)) >> 8)) & 0x0f;

    SBOXNET_USART_ID.BAUDCTRLA = ((uint8_t)(((F_CPU / 16 / 250000) - 1)));


    SBOXNET_USART_ID.STATUS = (1<<(
# 450 ".././sboxnet.c" 3
                             6
# 450 ".././sboxnet.c"
                             ));

    SBOXNET_USART_ID.CTRLA = USART_RXCINTLVL_OFF_gc|USART_TXCINTLVL_OFF_gc|USART_DREINTLVL_OFF_gc;

    SBOXNET_USART_ID.CTRLB = (0 << (
# 454 ".././sboxnet.c" 3
                            4
# 454 ".././sboxnet.c"
                            ))|(0 << (
# 454 ".././sboxnet.c" 3
                                                 3
# 454 ".././sboxnet.c"
                                                 ))|(0 << (
# 454 ".././sboxnet.c" 3
                                                                      2
# 454 ".././sboxnet.c"
                                                                      ))|(1 << (
# 454 ".././sboxnet.c" 3
                                                                                            1
# 454 ".././sboxnet.c"
                                                                                            ));

    SBOXNET_USART_ID.CTRLC = USART_CMODE_ASYNCHRONOUS_gc|USART_PMODE_EVEN_gc|(0 << (
# 456 ".././sboxnet.c" 3
                                                                            3
# 456 ".././sboxnet.c"
                                                                            ))|USART_CHSIZE_9BIT_gc;
    ((SBOXNET_USART_ID.CTRLB) |= (1<<(
# 457 ".././sboxnet.c" 3
   3
# 457 ".././sboxnet.c"
   )));

    sboxnet_receiver_enable();
}
# 469 ".././sboxnet.c"
 void sboxnet_set_timer(uint16_t offset) {

 uint8_t sr = 
# 471 ".././sboxnet.c" 3
             (*(volatile uint8_t *)(0x003F))
# 471 ".././sboxnet.c"
                 ;
 
# 472 ".././sboxnet.c" 3
__asm__ __volatile__ ("cli" ::: "memory")
# 472 ".././sboxnet.c"
     ;
    register uint16_t ocr;


        ocr = SBOXNET_TIMER.CNT;


    ocr = (ocr + offset) & SBOXNET_TIMER_PERIOD_MASK;



        SBOXNET_TIMER.SBOXNET_TIMER_CCBUF = ocr;


    SBOXNET_TIMER.INTFLAGS = (1<<(SBOXNET_TIMER_CCIF));

    SBOXNET_TIMER.INTCTRLB = (SBOXNET_TIMER.INTCTRLB & ~SBOXNET_TIMER_CCINTLVL_MASK) | SBOXNET_TIMER_CCINTLVL;
 
# 489 ".././sboxnet.c" 3
(*(volatile uint8_t *)(0x003F)) 
# 489 ".././sboxnet.c"
     = sr;
}





 static inline void sboxnet_clear_line_sensor(void) {
    
# 497 ".././sboxnet.c" 3
   (*(PORT_t *) 0x0680)
# 497 ".././sboxnet.c"
        .INTFLAGS = (1<<(SBOXNET_HW_SENSOR_INTF_BIT));
}






 static inline uint8_t sboxnet_line_sensor_changed(void) {
    return 
# 506 ".././sboxnet.c" 3
          ((*(volatile uint8_t *)(((uint16_t) &((*(PORT_t *) 0x0680)
# 506 ".././sboxnet.c"
          .INTFLAGS
# 506 ".././sboxnet.c" 3
          )))) & (1 << (
# 506 ".././sboxnet.c"
          SBOXNET_HW_SENSOR_INTF_BIT
# 506 ".././sboxnet.c" 3
          )))
# 506 ".././sboxnet.c"
                                                                ;
}
# 516 ".././sboxnet.c"
 void sboxnet_set_backoff_with_offset(uint16_t offset) {


    sboxnet_clear_line_sensor();

    SBOXNET_VAR->state = 1;


    sboxnet_set_timer(SBOXNET_TIMER_BIT_TICKS * 15 + offset);
}
# 534 ".././sboxnet.c"
 void sboxnet_intr_usart_rx(void) {

    uint8_t rxb8, rxb, rflags;
    struct sboxnet_device *dev = SBOXNET_VAR;
    __asm__ __volatile__ ("" : "+r"(dev) ::);

    rflags = SBOXNET_USART_ID.STATUS;
    rxb8 = 
# 541 ".././sboxnet.c" 3
          ((*(volatile uint8_t *)(((uint16_t) &(
# 541 ".././sboxnet.c"
          rflags
# 541 ".././sboxnet.c" 3
          )))) & (1 << (0)))
# 541 ".././sboxnet.c"
                                           ;
    rxb = SBOXNET_USART_ID.DATA;
    rflags &= (
# 543 ".././sboxnet.c" 3
              0x10
# 543 ".././sboxnet.c"
                           |
# 543 ".././sboxnet.c" 3
                            0x08
# 543 ".././sboxnet.c"
                                           |
# 543 ".././sboxnet.c" 3
                                            0x04
# 543 ".././sboxnet.c"
                                                         );
    if (rflags) {
       

       
       
       
        goto receive_reset;

    } else if (rxb8) {
        if (sboxnet_rb_write_count(&dev->recv_buf.rb) != 0) {
           
           
            sboxnet_rb_write_rollback(&dev->recv_buf.rb);
        }
        if (rxb == SBOXNET_DEVICE_ADDR || rxb == 255



        ) {
            ((SBOXNET_USART_ID.CTRLB) &= ~(1<<(
# 563 ".././sboxnet.c" 3
           1
# 563 ".././sboxnet.c"
           )));
            if (!sboxnet_rb_write(&dev->recv_buf.rb, 0)) {
                goto rec_dor;
            }
            if (sboxnet_rb_write(&dev->recv_buf.rb, rxb)) {
               
                dev->recv_len = (5 +1);
            } else {
                rec_dor:
               
                goto receive_error;
            }
        } else {

            goto receive_reset;
        }

    } else {
        uint8_t writecount = sboxnet_rb_write_count(&dev->recv_buf.rb);
        if (writecount > dev->recv_len) {
           
            goto receive_error;
        } else {
            if (writecount == (
# 586 ".././sboxnet.c" 3 4
                              __builtin_offsetof (
# 586 ".././sboxnet.c"
                              struct sboxnet_msg_header
# 586 ".././sboxnet.c" 3 4
                              , 
# 586 ".././sboxnet.c"
                              opt
# 586 ".././sboxnet.c" 3 4
                              )
# 586 ".././sboxnet.c"
                                                                      +1)) {
                dev->recv_len = (5 +1) + (rxb & 0x3f);
            }
            if (!sboxnet_rb_write(&dev->recv_buf.rb, rxb)) {
               
                goto receive_error;
            }
           
            if (sboxnet_rb_write_count(&dev->recv_buf.rb) == dev->recv_len+1) {
                sboxnet_rb_put_first(&dev->recv_buf.rb, dev->recv_len);
                dev->recv_len = 0;
                ((SBOXNET_USART_ID.CTRLB) |= (1<<(
# 597 ".././sboxnet.c" 3
               1
# 597 ".././sboxnet.c"
               )));
                sboxnet_rb_write_commit(&dev->recv_buf.rb);
               
            }
        }
    }
    return;

    receive_error:
   
    receive_reset:
    dev->recv_len = 0;
    ((SBOXNET_USART_ID.CTRLB) |= (1<<(
# 609 ".././sboxnet.c" 3
   1
# 609 ".././sboxnet.c"
   )));

    sboxnet_rb_write_rollback(&dev->recv_buf.rb);
}





 void sboxnet_check_try_transmit(void) {

    struct sboxnet_device *dev = SBOXNET_VAR;
    __asm__ __volatile__ ("" : "+r"(dev) ::);

    if (dev->tmit_bytes == 0 && sboxnet_rb_getcount(&dev->tmit_buf.rb) > (5 +1)) {
        dev->tmit_cnt = 0;
        dev->tmit_bytes = sboxnet_rb_read(&dev->tmit_buf.rb);
    }
    if (dev->tmit_bytes > 0 && dev->tmit_cnt == 0) {
        if (dev->state == 0) {
            uint16_t offset = sboxnet_prandom() & SBOXNET_TIMER_RANDOM_MASK;
            sboxnet_set_backoff_with_offset((uint16_t)dev->retry_counter * (SBOXNET_TIMER_BIT_TICKS / 4) + SBOXNET_TIMER_BIT_TICKS*2 + offset);
        }
    }
}




 void sboxnet_intr_usart_tx(void) {

    struct sboxnet_device *dev = SBOXNET_VAR;
    __asm__ __volatile__ ("" : "+r"(dev) ::);


    uint8_t ucsra = SBOXNET_USART_ID.STATUS;
    uint8_t crxc = !(ucsra & 
# 645 ".././sboxnet.c" 3
                            0x80
# 645 ".././sboxnet.c"
                                          );
    uint8_t cfe = (ucsra & (
# 646 ".././sboxnet.c" 3
                            0x10
# 646 ".././sboxnet.c"
                                         |
# 646 ".././sboxnet.c" 3
                                          0x04
# 646 ".././sboxnet.c"
                                                       ));
    uint8_t cudr = (SBOXNET_USART_ID.DATA != dev->tmit_lastbyte);
    if (crxc || cfe || cudr) {
       
       
       

        (SBOXNET_TxD_PORT).OUTCLR = ((1<<(SBOXNET_TxD_BIT)));




        dev->state = 2;
       
        if (dev->retry_counter > 0) {
            dev->retry_counter--;
            sboxnet_rb_read_rollback(&dev->tmit_buf.rb);

           
        } else {
            while (dev->tmit_cnt < dev->tmit_bytes) {
                sboxnet_rb_read(&dev->tmit_buf.rb);
                dev->tmit_cnt++;
            }
            dev->tmit_cnt = dev->tmit_bytes = 0;
            dev->retry_counter = 25;
            sboxnet_rb_read_commit(&dev->tmit_buf.rb);
           
        }
        dev->tmit_cnt = dev->tmit_bytes = 0;

        sboxnet_set_timer(SBOXNET_TIMER_BIT_TICKS * 16);
        return;
    }

    ((SBOXNET_USART_ID.CTRLB) &= ~(1<<(
# 681 ".././sboxnet.c" 3
   4
# 681 ".././sboxnet.c"
   )));
    SBOXNET_USART_ID.CTRLA &= ~(
# 682 ".././sboxnet.c" 3
                               0x30
# 682 ".././sboxnet.c"
                                                 );
    ((SBOXNET_USART_ID.CTRLB) |= (1<<(
# 683 ".././sboxnet.c" 3
   4
# 683 ".././sboxnet.c"
   )));


    if (dev->tmit_cnt < dev->tmit_bytes) {
        uint8_t v = sboxnet_rb_read(&dev->tmit_buf.rb);
        dev->tmit_cnt++;
        dev->tmit_lastbyte = v;

        ((SBOXNET_USART_ID.CTRLB) &= ~(1<<(
# 691 ".././sboxnet.c" 3
       0
# 691 ".././sboxnet.c"
       )));
        SBOXNET_USART_ID.DATA = v;
    } else {
        SBOXNET_USART_ID.CTRLA &= ~(
# 694 ".././sboxnet.c" 3
                                   0x0C
# 694 ".././sboxnet.c"
                                                     );

        dev->tmit_bytes = 0;
        dev->tmit_cnt = 0;
        sboxnet_rb_read_commit(&dev->tmit_buf.rb);
       

        sboxnet_receiver_enable();
        if (dev->state == 3) {
            dev->state = 0;
        }
        dev->retry_counter = 25;
        sboxnet_check_try_transmit();
    }
   
}

 
# 711 ".././sboxnet.c" 3
               void 
# 711 ".././sboxnet.c"
               SBOXNET_USART_RxC_vect 
# 711 ".././sboxnet.c" 3
               (void) __attribute__ ((signal,used, externally_visible)) ; void 
# 711 ".././sboxnet.c"
               SBOXNET_USART_RxC_vect 
# 711 ".././sboxnet.c" 3
               (void) 
# 711 ".././sboxnet.c"
                                           {
    sboxnet_intr_usart_rx();
}

 
# 715 ".././sboxnet.c" 3
               void 
# 715 ".././sboxnet.c"
               SBOXNET_USART_TxC_vect 
# 715 ".././sboxnet.c" 3
               (void) __attribute__ ((signal,used, externally_visible)) ; void 
# 715 ".././sboxnet.c"
               SBOXNET_USART_TxC_vect 
# 715 ".././sboxnet.c" 3
               (void) 
# 715 ".././sboxnet.c"
                                           {
    sboxnet_intr_usart_tx();
}



 void sboxnet_timer_bit(void) {

    struct sboxnet_device *dev = SBOXNET_VAR;

    SBOXNET_TIMER.INTCTRLB &= ~SBOXNET_TIMER_CCINTLVL_MASK;


 volatile uint8_t st = dev->state;

    if (dev->state == 1) {

        if (dev->tmit_bytes > 0 && dev->tmit_cnt == 0) {



            uint8_t d = sboxnet_rb_read_getone(&dev->tmit_buf.rb);


            (SBOXNET_TxD_PORT).OUTSET = ((1<<(SBOXNET_TxD_BIT)));

            ((SBOXNET_USART_ID.CTRLB) |= (
# 741 ".././sboxnet.c" 3
           0x08
# 741 ".././sboxnet.c"
           |
# 741 ".././sboxnet.c" 3
           0x01
# 741 ".././sboxnet.c"
           ));

            if (sboxnet_line_sensor_changed() || 
# 743 ".././sboxnet.c" 3
                                                (!((*(volatile uint8_t *)(((uint16_t) &(
# 743 ".././sboxnet.c"
                                                (SBOXNET_RxD_PORT).IN
# 743 ".././sboxnet.c" 3
                                                )))) & (1 << (
# 743 ".././sboxnet.c"
                                                SBOXNET_RxD_BIT
# 743 ".././sboxnet.c" 3
                                                ))))
# 743 ".././sboxnet.c"
                                                                                                        ) {
                uint16_t offset = sboxnet_prandom() & SBOXNET_TIMER_RANDOM_MASK;
                sboxnet_set_backoff_with_offset((uint16_t)dev->retry_counter * (SBOXNET_TIMER_BIT_TICKS / 4) + offset);

            } else {

                ((SBOXNET_USART_ID.CTRLB) &= ~(1<<(
# 749 ".././sboxnet.c" 3
               4
# 749 ".././sboxnet.c"
               )));
                SBOXNET_USART_ID.CTRLA &= ~(
# 750 ".././sboxnet.c" 3
                                           0x30
# 750 ".././sboxnet.c"
                                                             |
# 750 ".././sboxnet.c" 3
                                                              0x0C
# 750 ".././sboxnet.c"
                                                                                );
                ((SBOXNET_USART_ID.CTRLB) |= (1<<(
# 751 ".././sboxnet.c" 3
               4
# 751 ".././sboxnet.c"
               )));
                SBOXNET_USART_ID.CTRLA |= SBOXNET_USART_TXCINTLVL;
                SBOXNET_USART_ID.DATA = d;
                ((SBOXNET_USART_ID.CTRLB) &= ~(1<<(
# 754 ".././sboxnet.c" 3
               1
# 754 ".././sboxnet.c"
               )));

                sboxnet_rb_read(&dev->tmit_buf.rb);
                dev->tmit_lastbyte = d;
                dev->tmit_cnt++;
                dev->state = 3;
            }
        } else {
            dev->state = 0;
        }
        return;
    }

    if (dev->state == 2) {
        (SBOXNET_TxD_PORT).OUTSET = ((1<<(SBOXNET_TxD_BIT)));
        dev->state = 4;
        sboxnet_set_timer(SBOXNET_TIMER_BIT_TICKS * 4);
        sboxnet_clear_line_sensor();
        return;
    }

    if (dev->state == 4) {
        if (!sboxnet_line_sensor_changed() && 
# 776 ".././sboxnet.c" 3
                                             ((*(volatile uint8_t *)(((uint16_t) &(
# 776 ".././sboxnet.c"
                                             (SBOXNET_RxD_PORT).IN
# 776 ".././sboxnet.c" 3
                                             )))) & (1 << (
# 776 ".././sboxnet.c"
                                             SBOXNET_RxD_BIT
# 776 ".././sboxnet.c" 3
                                             )))
# 776 ".././sboxnet.c"
                                                                                                   ) {
            sboxnet_receiver_enable();
            dev->state = 0;
            sboxnet_check_try_transmit();
        } else {
            sboxnet_clear_line_sensor();
            sboxnet_set_timer(SBOXNET_TIMER_BIT_TICKS * 4);
        }
        return;
    }
}



 __attribute__((noinline)) __attribute__((used)) static int8_t sboxnet_receive_msg(struct sboxnet_msg_header* pmsg, uint8_t maxmsglen) {
    if (maxmsglen < (5 +1))
        return (-3);

    struct sboxnet_device *dev = SBOXNET_VAR;
    uint8_t msglen = 0;
    uint8_t maxb = (5 +1);
    uint8_t avail;
    
# 798 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 798 ".././sboxnet.c"
                                     {
        avail = sboxnet_rb_can_read_bytes(&dev->recv_buf.rb);
        if (avail > (5 +1))
            msglen = sboxnet_rb_read_getone(&dev->recv_buf.rb);
    }
    if (msglen < maxb ) {
        return (-1);
    }
    if ((msglen+1) > avail) {
        return (-1);
    }
    if (msglen > maxmsglen) {
        return (-3);
    }
    if (msglen > (63 +(5 +1))) {
        return (-4);
    }
    
# 815 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 815 ".././sboxnet.c"
                                     {
        sboxnet_rb_read(&dev->recv_buf.rb);
    }
    uint8_t* p = (uint8_t*)pmsg;
    uint8_t crc = sboxnet_crc8_init();
    for (uint8_t i = 0; i < msglen; i++) {
        uint8_t v;
        
# 822 ".././sboxnet.c" 3
       for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 822 ".././sboxnet.c"
                                         {
            v = sboxnet_rb_read(&dev->recv_buf.rb);
        }
        if (i == 
# 825 ".././sboxnet.c" 3 4
                __builtin_offsetof (
# 825 ".././sboxnet.c"
                struct sboxnet_msg_header
# 825 ".././sboxnet.c" 3 4
                , 
# 825 ".././sboxnet.c"
                opt
# 825 ".././sboxnet.c" 3 4
                )
# 825 ".././sboxnet.c"
                                                        ) {
            maxb += (v & 0x3f);
        }
        crc = sboxnet_crc8_add(crc, v);
        *p++ = v;
    }
    
# 831 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 831 ".././sboxnet.c"
                                     {
        sboxnet_rb_read_commit(&dev->recv_buf.rb);
    }

    if (!sboxnet_crc8_ok(crc)) {
       
       
        return (-2);
    } else {
       
    }
    return msglen;
}



 __attribute__((used)) __attribute__((noinline)) uint8_t sboxnet_send_msg(struct sboxnet_msg_header* pmsg) {

    struct sboxnet_device *dev = SBOXNET_VAR;

    uint8_t msglen = (5 +1) + pmsg->opt.len;
    uint8_t free;
    
# 853 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 853 ".././sboxnet.c"
                                     {

        free = sboxnet_rb_getfree(&dev->tmit_buf.rb);
    }

    uint8_t RC = 0;
    if (!(free > msglen)) {

        g_dev_errflags |= DEV_ERR_FLG_TMITNOTFREE;
        RC = DEV_ERR_FLG_TMITNOTFREE;
        return 2;
    }
    uint8_t rc;
    
# 866 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 866 ".././sboxnet.c"
                                     {

        rc = sboxnet_rb_write(&dev->tmit_buf.rb, msglen);
    }
    if (!rc) {
        RC = DEV_ERR_FLG_TMITNOTENOUGBUF;
        goto send_error;
    }
    uint8_t crc = sboxnet_crc8_init();
    uint8_t i;
    for (i = 0; i < (msglen-1); i++) {
        uint8_t d;
        if (i == 1) {
            d = SBOXNET_DEVICE_ADDR;
        } else {
            d = ((uint8_t*)pmsg)[i];
        }
        crc = sboxnet_crc8_add(crc, d);
        
# 884 ".././sboxnet.c" 3
       for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 884 ".././sboxnet.c"
                                         {

            rc = sboxnet_rb_write(&dev->tmit_buf.rb, d);
        }
        if (!rc) {
            RC = DEV_ERR_FLG_TMITCANNOTPUTINTORINGBUF;
            goto send_error;
        }
    }
    
# 893 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 893 ".././sboxnet.c"
                                     {

        rc = sboxnet_rb_write(&dev->tmit_buf.rb, crc);
    }
    if (!rc) {
        send_error:
        
# 899 ".././sboxnet.c" 3
       for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 899 ".././sboxnet.c"
                                         {
            sboxnet_rb_write_rollback(&dev->tmit_buf.rb);
        }
        return RC;
    }
    
# 904 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 904 ".././sboxnet.c"
                                     {
        sboxnet_rb_write_commit(&dev->tmit_buf.rb);
        sboxnet_check_try_transmit();
    }
   
    return 0;
}

 __attribute__((noinline)) uint8_t sboxnet_can_send_msg(struct sboxnet_msg_header* pmsg) {
    uint8_t msglen = (5 +1) + pmsg->opt.len;
    uint8_t free;
    
# 915 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 915 ".././sboxnet.c"
                                     {
        free = sboxnet_rb_getfree(&SBOXNET_VAR->tmit_buf.rb);
    }
    return (free > msglen);
}
 __attribute__((noinline)) static uint8_t sboxnet_all_sent(void) {
    return sboxnet_rb_getcount(&SBOXNET_VAR->tmit_buf.rb) == 0;
}
 __attribute__((noinline)) static uint8_t sboxnet_can_read(void) {
    uint8_t b;
    
# 925 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 925 ".././sboxnet.c"
                                     {
        b = sboxnet_rb_can_read_bytes(&SBOXNET_VAR->recv_buf.rb);
    }
    return (b >= (5 +1));
}
 __attribute__((noinline)) static uint8_t sboxnet_can_send(void) {
    uint8_t free;
    
# 932 ".././sboxnet.c" 3
   for ( uint8_t sreg_save __attribute__((__cleanup__(__iRestore))) = (*(volatile uint8_t *)(0x003F)), __ToDo = __iCliRetVal(); __ToDo ; __ToDo = 0 ) 
# 932 ".././sboxnet.c"
                                     {
        free = sboxnet_rb_getfree(&SBOXNET_VAR->tmit_buf.rb);
    }
    return (free > (5 +1));
}

 static __attribute__((noinline)) void sboxnet_set_sniffer_mode(uint8_t on) {
    if (on) {
        ((SBOXNET_VAR->flags) |= (1<<(0)));
    } else {
        ((SBOXNET_VAR->flags) &= ~(1<<(0)));
    }
}
